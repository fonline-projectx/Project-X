//
// FOnline: 2238
// Rotators
//
// cheats.fos
//

// various commands

#include "_animation.fos"
#include "_ai.fos"
#include "_basetypes.fos"
#include "_macros.fos"
#include "_scripts.fos"
#include "_vals.fos"

#include "achievements_h.fos"
#include "backend_h.fos"
#include "broadcast_h.fos"
#include "buffer_h.fos"
#include "cheats_core_h.fos"
#include "combat_h.fos"
#include "combat_msg.fos"
#include "config_file_h.fos"
#include "critter_age_h.fos"
#include "debug_h.fos"
#include "economy_h.fos"
#include "entire.fos"
#include "follower_common_h.fos"
#include "follower_h.fos"
#include "factions_h.fos"
#include "factions_bases_h.fos"
#include "gm.fos"
#include "lexems_h.fos"
#include "mapdata_h.fos"
#include "minigames_h.fos"
#include "npc_ai.fos"
#include "npc_common_h.fos"
#include "npc_names_h.fos"
#include "npc_planes_h.fos"
#include "serializator.fos"
#include "town_h.fos"
#include "traps_h.fos"
#include "triggers_h.fos"
#include "utils_h.fos"
#include "weather_h.fos"
#include "world_common_h.fos"
#include "worldmap_h.fos"
#include "_colors.fos"
// #include "cheats_help.fos"

// #include "event_teleporter_h.fos"

/**
 * \~english @defgroup CheatsGroup Cheats
 * Cheat module with various commands.
 * \~ @ingroup FOnline2238
 */
/*@{*/

#define GETACCESS_CFG    "config/GetAccess.cfg"
#define CHEATS_CFG       "config/Cheats.cfg"
#define CFG_TRACKING     "Tracking"
#define MODE_EXT_GOD     (0x00020000)

// imports
// import void start() from "game";

// import void ExecUsedAmmo(Critter@ player) from "ammolog";

import void            AffectRadiation(Critter& cr, int value) from "radiation";
import void            DropDrugEffects(Critter& cr, bool dropAddictions) from "drugs";
import void            DropPoison(Critter& cr) from "poison";
import void            DropRadiation(Critter& cr) from "radiation";
import void            Explode(Map@ map, uint16 hexX, uint16 hexY, Critter@ cr, uint16 explodePid, uint ownerId, int bonusDamage, int bonusRadius) from "explode";
import void            ExplodeEx(Map& map, uint16 hexX, uint16 hexY, uint16 effectPid, uint effectRadius, uint damage, uint damageType, uint damageRadius, uint ownerId, uint16 explodePid) from "explode";
import bool            GetBaseType(const string& in, int& out) from "main";
import bool            GetItemPid(const string& in, int& out) from "main";
import bool            GetMapData(const string& in, int& out) from "main";
import bool            GetVarId(const string& in, int& out) from "main";
import void            InitPrices() from "economy";
import void            InjureCritter(Critter& cr, uint dmg, uint dmgType, uint8 dir, uint attackerId) from "combat";
import bool            IsGrenade(Item& item) from "throwing";
import uint            numDigits(int number) from "critter_description";
import void            SetCritterEvents(Critter& cr) from "logging_critter";
import void            SetWear(Item& item, int wearProcent) from "repair";
import int             stringReplaceText(string& s, string@ f, string@ t) from "config_file";
import array<Critter@> WorldmapGetPlayers(uint zx, uint zy) from "worldmap_players";
import int             WorldmapGetTotalValue() from "worldmap";

#define _SetSpawner                      \
    # (__item, __cr) { if(valid(__item)) \
                           __item.Val9 = _AsNotLegit(__cr.Id); }
#define _SetSpawnerLegit                 \
    # (__item, __cr) { if(valid(__item)) \
                           __item.Val9 = __cr.Id; }
#define _GetSpawner      # (__item) _AsLegit(__item.Val9)

// globals

bool CheatsInitialized = false;

// list of maps identifiers
dictionary Maps;

// items and critters spawned during event
array<int> eventItems;
array<int> eventCritters;

// Remember to wear protective goggles :)
string[] commandlist =
{
    "accesslist", "addbankmoney", "addfollower", "addmob", "addnpc", "airstrike", "alts",
    "animate", "antiblock", "append", "aura", "auracleanup",
    "bc", "blockers", "broadcast",
    "ces", "changefaction", "changerank", "checkbank", "checkbankaccount",
    "checkbankaccounts", "checktown", "cleanup", "clearallillegalflags",
    "clearenemystack", "clearenemystacks", "clearinventory", "clearillegalflags",
    "cleartimeouts", "clone", "condition", "controlmobs", "controlnpc", "corecheats",
    "countitems", "createlocation", "crinfo", "criticalchance", "critterinfo",
    "cto",
    "damage", "deathincarnate", "deathmatch", "deletelocation", "devenable",
    "dialog", "disguise", "disabledismantling", "disablegrids", "disablepvp",
    "disabletb", "disguiseinfo", "dismiss", "dismissteam", "dropalltimeouts",
    "dropdrugs", "dropitems",
    "emote", "emoteh", "enabledismantling", "enablegrids", "enablepvp", "enabletb",
    "explode",
    "factioninfo", "factionnews", "factiononline", "findchars", "finditems",
    "findnpc", "flash", "foart",
    "gaintowncontrol", "gameinfo", "getclaim", "getclaimtime", "getcolor",
    "getitems", "getleader", "getleadertime", "getuvar", "getvar", "give",
    "givekey", "goto", "gototeam",
    "heal", "healall", "help", "hideloc", "hidemap",
    "id2name", "iddqd", "idkfa", "inspect", "irradiate", "itemflags", "itemlight",
    "itemproto",
    "karma", "karmateam", "kill", "killeradmin", "killmobs",
    "la", "lastregistered", "lastspawned", "listauthenticated",     "listcommands",
    "listfollowers", "listfactions", "listmaps", "listplayers",     "listtents",
    "listtracked", "lock", "lockcar", "log", "lp", "lt",
    "makeencounter", "mapinfo", "masssetanim", "massslap", "modchar", "move",
    "name2id", "netmsg", "normaldeadly", "numplayers",
    "param", "perkadjust", "pickitems", "phase", "phaseteam", "playerkarma",
    "playmusic", "playsound", "playspeech", "profadjust",
    "registerfaction", "removebankmoney", "removefaction", "removeitems",
    "reservednickname", "resetalldisguises", "resetprices", "resetreputations",
    "resettown", "resettowns", "resetworldmap", "respawn", "revive", "respawnall",
    "reviveall", "respawnallplayers", "reviveallplayers", "rotate", "rundialog",
    "saferegen", "say", "sayh", "setfaction", "setmapdata", "setanim", "sethp",
    "setlexem", "setperk", "setreputation", "setrep", "settimeout", "sto",
    "setuvar", "setvar", "setlocvisibility", "setrain", "shift", "shiftteam", "shout",
    "shouth", "showhands", "showloc", "showvars", "slap", "spawncar", "spawnitem",
    "spawnpoint", "stoptrackplayer", "suicide", "summon", "summonteam",
    "team", "tentinfo", "tp", "teleport", "teleporter", "teleportteam", "toglobal", "trackplayer",
    "usedammo", "unlockcar",
    "whisper", "whisperh",
    "virtualmoney",
    "xp", "xpteam",
    "zeroext", "zone", "zoneplayers"
};

string[] gmcommandlist =
{
    "addfollower", "addmob", "addnpc", "animate", "antiblock", "append", "alts",
    "bc", "broadcast", "blockers",
    "changefaction", "changerank", "checkbank", "checkbankaccount",
    "checkbankaccounts", "cleanup", "clearenemystack", "clearenemystacks",
    "clearillegalflags", "clearinventory", "ces", "cleartimeouts", "clone",
    "corecheats", "cto", "countitems", "createlocation", "criticalchance",
    "critterinfo", "crinfo",
    "devenable", "dialog", "disguise", "disguiseinfo", "disabletb", "dismiss",
    "dismissteam", "dropalltimeouts", "dropdrugs", "dropitems",
    "emote", "emoteh", "enabletb", "explode",
    "factioninfo", "factionnews", "factiononline", "findchars", "finditems",
    "findnpcs", "flash", "foart",
    "gameinfo", "getclaim", "getclaimtime", "getcolor", "getitems", "getleader",
    "getleadertime", "getuvar", "getvar", "give", "givekey", "goto", "gototeam",
    "heal", "healall", "help", "hideloc", "hidemap",
    "id2name", "inspect", "irradiate", "itemflags", "itemlight", "itemproto",
    "karma", "karmateam", "killmobs",
    "la", "lastregistered", "lastspawned", "listauthenticated",     "listcommands",
    "listfollowers", "listfactions", "listmaps", "listplayers",     "listtents",
    "listtracked", "lp", "lt", "lock", "lockcar", "log",
    "makeencounter", "mapinfo", "massslap", "modchar",
    "name2id", "netmsg", "normaldeadly", "numplayers",
    "param", "pickitems", "phase", "phaseteam", "playerkarma", "playmusic",
    "playsound", "playspeech",
    "reservednickname", "resetreputations", "resetworldmap", "respawn", "revive",
    "respawnall", "respawnallplayers", "rotate", "rundialog",
    "saferegen", "say", "sayh", "setmapdata", "setperk", "setreputation", "setrep",
    "settimeout", "sto", "setanim", "setuvar", "setvar", "slap", "shift",
    "shiftteam", "shout", "shouth", "showhands", "showloc", "showvars",
    "showhands", "spawncar", "spawnitem", "spawnpoint", "stoptrackplayer",
    "suicide", "summon", "summonteam",
    "team", "tentinfo", "tp", "teleport", "teleporter", "teleportteam", "toglobal", "trackplayer",
    "usedammo", "unlockcar",
    "virtualmoney",
    "whisper", "whisperh",
    "xp", "xpteam",
    "zone"
};

string[] testercommandlist =
{
    "alts", "animate",
    "blockers",
    "ces", "changefaction", "changerank", "clearillegalflags", "clearenemystack",
    "clearenemystacks", "cleartimeouts", "countitems", "crinfo", "critterinfo",
    "cto",
    "devenable", "dismiss", "dismissteam", "dropitems",
    "finditems",
    "gameinfo", "getcolor", "getvar", "goto", "gototeam",
    "heal", "healall", "help",
    "id2name",
    "lastregistered", "listcommands", "listfactions", "listfollowers", "listmaps",
    "listplayers", "listtents", "listtracked", "lp", "lt", "log",
    "mapinfo",
    "name2id", "netmsg", "numplayers",
    "pickitems", "playerkarma", "playmusic", "playsound", "playspeech",
    "revive", "resetworldmap", "respawnall", "respawnplayers", "rotate",
    "say", "sayh", "setanim", "showhands", "shout", "shouth", "showvars", "slap",
    "suicide", "summon", "summonteam",
    "team", "tentinfo", "tp", "teleport", "teleportteam", "toglobal", "trackplayer",
    "whisper", "whisperh"
};

int[] testerparamlist =
{
    // various statistics
    ST_ACTION_POINTS,
    ST_AGE,
    ST_ARMOR_CLASS,
    ST_CARRY_WEIGHT,
    ST_GENDER,
    ST_HEALING_RATE,
    ST_LEVEL,
    ST_MAX_LIFE,
    ST_SEQUENCE,
    ST_RADIATION_RESISTANCE, ST_POISON_RESISTANCE,

    ST_NORMAL_ABSORB, ST_LASER_ABSORB, ST_FIRE_ABSORB, ST_PLASMA_ABSORB, ST_ELECTRO_ABSORB, ST_EMP_ABSORB, ST_EXPLODE_ABSORB,
    ST_NORMAL_RESIST, ST_LASER_RESIST, ST_FIRE_RESIST, ST_PLASMA_RESIST, ST_ELECTRO_RESIST, ST_EMP_RESIST, ST_EXPLODE_RESIST,

    ST_DESCRIPTION1, ST_DESCRIPTION2,

    // 3d
    #ifdef PLAYERS_3D
    (ST_ANIM3D_LAYERS + 0),     // 150
    (ST_ANIM3D_LAYERS + 1),
    (ST_ANIM3D_LAYERS + 2),
    (ST_ANIM3D_LAYERS + 3),
    (ST_ANIM3D_LAYERS + 4),
    (ST_ANIM3D_LAYERS + 5),
    (ST_ANIM3D_LAYERS + 6),
    (ST_ANIM3D_LAYERS + 7),
    (ST_ANIM3D_LAYERS + 8),
    (ST_ANIM3D_LAYERS + 9),
    (ST_ANIM3D_LAYERS + 10),    // 160
    (ST_ANIM3D_LAYERS + 11),
    (ST_ANIM3D_LAYERS + 12),
    (ST_ANIM3D_LAYERS + 13),
    (ST_ANIM3D_LAYERS + 14),
    (ST_ANIM3D_LAYERS + 15),
    (ST_ANIM3D_LAYERS + 16),
    (ST_ANIM3D_LAYERS + 17),
    (ST_ANIM3D_LAYERS + 18),
    (ST_ANIM3D_LAYERS + 19),
    (ST_ANIM3D_LAYERS + 20),    // 170
    (ST_ANIM3D_LAYERS + 21),
    (ST_ANIM3D_LAYERS + 22),
    (ST_ANIM3D_LAYERS + 23),
    (ST_ANIM3D_LAYERS + 24),
    (ST_ANIM3D_LAYERS + 25),
    (ST_ANIM3D_LAYERS + 26),
    (ST_ANIM3D_LAYERS + 27),
    (ST_ANIM3D_LAYERS + 28),
    (ST_ANIM3D_LAYERS + 29), // 179
    #endif                   // PLAYERS_3D

    // SPECIAL
    ST_STRENGTH, ST_PERCEPTION, ST_ENDURANCE, ST_CHARISMA, ST_INTELLECT, ST_AGILITY, ST_LUCK,

    // skills
    SK_SMALL_GUNS, SK_BIG_GUNS, SK_ENERGY_WEAPONS, SK_UNARMED, SK_MELEE_WEAPONS, SK_THROWING, SK_FIRST_AID, SK_DOCTOR, SK_SNEAK, SK_LOCKPICK, SK_STEAL, SK_TRAPS, SK_SCIENCE, SK_REPAIR, SK_SPEECH, SK_BARTER, SK_GAMBLING, SK_OUTDOORSMAN,

    // tag skills
    TAG_SKILL1, TAG_SKILL2, TAG_SKILL3, TAG_SKILL4,

    // modes
    MODE_NO_AIM,
    MODE_NO_KNOCK,
    MODE_NO_PUSH,
    MODE_NO_PVP,
    MODE_NO_RUN,
    MODE_NO_UNARMED,
    MODE_NO_WALK,
    MODE_RANGE_HTH,
    MODE_UNLIMITED_AMMO
};

void SetMapId(string location, uint mapprotoid)
{
    Map@ map = GetMapByPid(mapprotoid, 0);
    if(!valid(map))
    {
        DLog("Couldn't find map object for " + location);
        return;
    }

    WLog("cheats", "Setting mapid for " + location + " to " + map.Id);
    Maps.set(location, map.Id);
}

void RefreshAliases(Critter& player, int, int, int)   // ~runscript cheats RefreshAliases 0 0 0
{
    SetAliases();
}

void SetAliases()
{
    // Fallout 1
    SetMapId("junktown",    MAP_Junktown);
    SetMapId("jt",                  MAP_Junktown);
    SetMapId("hub",                 MAP_HubDowntown);
    SetMapId("glow",                MAP_Glow_Entrance);
    SetMapId("gunrunners",  MAP_Gunrunner);
    SetMapId("fortress",    MAP_Gunrunner);
    SetMapId("adytum",              MAP_Adytum);
    SetMapId("scavenger",   MAP_Blade);
    SetMapId("library",             MAP_Library);
    SetMapId("lh",                  MAP_LostHills_Entrance);
    SetMapId("v13",                 MAP_Vault13Level1);
    SetMapId("necropolis",  MAP_NecropolisHotel);

    // Fallout 2
    SetMapId("arroyo",              MAP_ArroyoTemple);
    SetMapId("den",                 MAP_DenBusiness);
    SetMapId("klamath",             MAP_KlamathDowntown);
    SetMapId("klamcave",    MAP_KlamathToxicCaves1);
    SetMapId("modoc",               MAP_ModocLarge);
    SetMapId("vc",                  MAP_VaultCityDowntown);
    SetMapId("gecko",               MAP_GeckoSettlement);
    SetMapId("bh",                  MAP_BrokenHills);
    SetMapId("broken",              MAP_BrokenHills);
    SetMapId("nr",                  MAP_NewReno1);
    SetMapId("gasstation",  MAP_NewRenoChopShop);
    SetMapId("tray",                MAP_NewRenoChopShop);
    SetMapId("t-ray",               MAP_NewRenoChopShop);
    SetMapId("sad",                 MAP_SierraArmyDepot_TheBattlefield);
    SetMapId("v15",                 MAP_Vault15Surface);
    SetMapId("ncr",                 MAP_NCR);
    SetMapId("shady",               MAP_NCR);
    SetMapId("shadysands",  MAP_NCR);
    SetMapId("cathedral",   MAP_Cathedral_Enter);
    SetMapId("mariposa",    MAP_MilitaryBaseEntrance);
    SetMapId("redding",             MAP_Redding);
    SetMapId("sf",                  MAP_SanFranChina);
    SetMapId("navarro",             MAP_Navarro);
    SetMapId("golgotha",    MAP_NewReno_Golgotha);
    SetMapId("raiders1",    MAP_KhansCaveEntrance);
    SetMapId("khans",               MAP_KhansCaveEntrance);
    SetMapId("raiders2",    MAP_KhansHQ);

    // 2238-specific
    SetMapId("repl1",               MAP_Replication1);
    SetMapId("repl2",               MAP_Replication2);
    SetMapId("repl3",               MAP_Replication3);
    SetMapId("repl4",               MAP_Replication4);
    SetMapId("repl5",               MAP_Replication5);
    SetMapId("repl6",               MAP_Replication6);
    SetMapId("repl7",               MAP_Replication7);
    SetMapId("repl8",               MAP_SalvagerCamp);

    // Fixed Mining Sides
    SetMapId("bh_mine",             MAP_BrokenHillsMine);
    SetMapId("broken_mine", MAP_BrokenHillsMine);
    SetMapId("klamath_mine", MAP_KlamathMiningSite);
    SetMapId("ncr_mine",    MAP_NCRMiningSite);
    SetMapId("redding_mine", MAP_ReddingMine);
    SetMapId("sf_mine",             MAP_SanFranciscoMiningSite);
    SetMapId("jt_mine",             MAP_JunktownMiningSite);
    SetMapId("vc_mine",             MAP_VaultCityMiningSite);

    // Trainyards
    SetMapId("sf_train",    MAP_SanFransiscoTrainStation);
    SetMapId("la_train",    MAP_BoneyardTrainStation);
    SetMapId("ncr_train",   MAP_NCRTrainStation);
    SetMapId("vc_train",    MAP_VaultCityTrainStation);

    SetMapId("train1",              MAP_SanFransiscoTrainStation);
    SetMapId("train2",              MAP_BoneyardTrainStation);
    SetMapId("train3",              MAP_NCRTrainStation);
    SetMapId("train4",              MAP_VaultCityTrainStation);

    // Slaver Camps
    SetMapId("slaver1",             MAP_SlaverCamp);
    /* Used in future
       SetMapId("slaver2",		569);
       SetMapId("slaver3",		570);
       SetMapId("slaver4",		571);
     */

    SetMapId("ares",                MAP_AresMilitaryBase_Entrance);
    SetMapId("gasstation2", MAP_GordonsGasStation);
    SetMapId("hinkley",             MAP_Arena);
    SetMapId("hub_arena",   MAP_HubArena);
    SetMapId("junkyard",    MAP_Junkyard);
    SetMapId("tesla",               MAP_TeslaTower);
    SetMapId("themepark",   MAP_Themepark);
    SetMapId("waterworks",  MAP_Waterworks);
    SetMapId("ncr_army",    MAP_MilitaryCamp);
    SetMapId("ncrcf",               MAP_NCRCF);
    SetMapId("prison",              MAP_NCRCF);
    SetMapId("ncr_rails",   MAP_Rails);

    // Special maps
    SetMapId("npcmap",              MAP_BufferMap);
    SetMapId("jail",                MAP_Jail);
	SetMapId("cubik",                MAP_Cubik);
	SetMapId("bg", MAP_BarterGround);
	SetMapId("barterground", MAP_BarterGround);
}

class CNPC
{
    uint          protoId;
    uint          dialogId;
    array<string> names;

    CNPC(uint protoId, uint dialogId)
    {
        this.protoId  = protoId;
        this.dialogId = dialogId;
        names.resize(0);
    }

    bool IsImportant(Critter& cr)
    {
        if(cr.GetProtoId() == this.protoId &&
           cr.Param[ST_DIALOG_ID] == int(this.dialogId))
            return(true);
        else
            return(false);
    }

    CNPC@ Name(string& name)
    {
        this.names.insertLast(name);

        return(this);
    }
};
array<CNPC@> INPC;

CNPC@ ImportantNpc(uint protoId, uint dialogId)
{
    INPC.insertLast(CNPC(protoId, dialogId));
    return(INPC.last());
}

void SetImportantNpcs()
{
    // ImportantNpc( critter_pid, dialog_id )

    // Broken Hills
    ImportantNpc(161, 625)
    .Name("marcus")
    .Name("town_leader")
    ;
    ImportantNpc(119, 650)
    .Name("mercs")
    ;
    // Frisco
    ImportantNpc(58, 9300)
    .Name("banker")
    ;
    ImportantNpc(297, 1405)
    .Name("dr_fung")
    .Name("doctor")
    ;
    ImportantNpc(308, 1403)
    .Name("lao_chou")
    .Name("trader")
    ;
    ImportantNpc(300, 1402)
    .Name("mai_da_chiang")
    .Name("trader");
    ImportantNpc(300, 772)
    .Name("mercs")
    ;
    ImportantNpc(472, 46)
    .Name("tatoo")
    ;
    // Gordon's Gas Station
    ImportantNpc(149, 10701)
    .Name("tamira")
    .Name("pe_ranger")
    .Name("support_perk")
    ;
    // Junktown
    ImportantNpc(100, 1713)
    .Name("boyce")
    .Name("pe_dismantrler")
    .Name("support_perk")
    ;
    // Raiders
    ImportantNpc(409, 2722)
    .Name("gomes")
    .Name("raiders")
    ;
    // Shady Sands
    ImportantNpc(150, 1002)
    .Name("buster")
    .Name("trader_ncr")
    .Name("trader")
    ;
    ImportantNpc(139, 1025)
    .Name("hoss")
    .Name("pe_cautious_nature")
    .Name("pe_pathfinder")
    .Name("pe_awareness")
    .Name("support_perk")
    ;
    ImportantNpc(20,  1048)
    .Name("sha_enin")
    .Name("trader_ncr")
    .Name("trader")
    ;
    ImportantNpc(144, 1035)
    .Name("tandi")
    ;
}

//////////////////////////////////
//
// Protection of GM-spawned items
//
//

// Checks if item can be used by critter with optional deletion if not.
// Returns true if item is illegal (not-legit item in legit map or not-legit
// item in not-legit map, if the critter carries a stackable legit item
// with the same pid). Called on item transfers and picking up / skills.
//
bool GuardNotLegit(Critter@ cr, Item@ item, bool deleteItem)   // export
{

	/*
    if(_IsNotLegit(item.Val9))
    {
        if(_IsRealPlayer(cr) || cr.IsNpc())
        {
            Map@ map = cr.GetMap();
            if(valid(map) && _IsNotLegit(map.GetData(MAP_DATA_SPAWNER)))
            {
                Item@ item2 = cr.GetItem(item.GetProtoId(), -1);
                if(!valid(item2))
                {
                    return false;
                }
                if(_IsNotLegit(item2.Val9) || !item2.IsStackable())
                {
                    return false;
                }
            }
            if(deleteItem)
            {
                DeleteItem(item);
                cr.Say(SAY_NETMSG, "Not legit item removed.");
            }
            return true;
        }
    }
    return false;
	*/
	return false;
}

// Removes all not legit items from a critter. Called when a critter moves from
// a not-legit map to WM or to a legit map.
//
void RemoveNotLegit(Critter@ cr)   // export
{
	/*
    bool         foundNotLegit = false;
    array<Item@> items;
    uint         num = cr.GetItems(-1, items);
    for(uint i = 0; i < num; i++)
    {
        if(_IsNotLegit(items[i].Val9))
        {
            DeleteItem(items[i]);
            foundNotLegit = true;
        }
    }
    if(foundNotLegit)
    {
        cr.Say(SAY_NETMSG, "Not legit items removed.");
    }*/
	return;
};



//////////////////////////////////////////////////////////////////////////////////////////////
//
//	GET CHEAT OPTIONS - NEW UTILITY USED BY BLOCKERS COMMAND (AND MAYBE OTHER IN THE FUTURE)
//	Gets option by reference and returns a string with option value, with optional
//	[default] note if the option can't be found in command.
//

string cheatGetOption(array<string@>@ command, int& option, string optionSwitch)
{
    if(StrToInt(GetParameterString(command, optionSwitch), option))
    {
        return option + "";
    }
    else
    {
        return option + " [default]";
    }
}

string cheatGetOption(array<string@>@ command, uint& option, string optionSwitch)
{
    if(StrToInt(GetParameterString(command, optionSwitch), option))
    {
        return option + "";
    }
    else
    {
        return option + " [default]";
    }
}

string cheatGetOption(array<string@>@ command, int16& option, string optionSwitch)
{
    if(StrToInt(GetParameterString(command, optionSwitch), option))
    {
        return option + "";
    }
    else
    {
        return option + " [default]";
    }
}

string cheatGetOption(array<string@>@ command, uint16& option, string optionSwitch)
{
    if(StrToInt(GetParameterString(command, optionSwitch), option))
    {
        return option + "";
    }
    else
    {
        return option + " [default]";
    }
}

string cheatGetOption(array<string@>@ command, bool& option, string optionSwitch)
{
    if(GetIndexOfString(command, optionSwitch) != -1)
    {
        option = true;
        return option + "";
    }
    else
    {
        return option + " [default]";
    }
}

void InitCheats(bool fromGame)
{
    if(!fromGame)
    {
        // Todo: Restart other things ?
        // game init
        // start();
    }

    SetAliases();
    SetImportantNpcs();
    LoadEventSpawns();
    // LoadRiddles();

    CheatsInitialized = true;
}

void SaveCheats()
{
    /*
       Log( "Saving cheats..." );
       SaveRiddles();
       Log( "Saved cheats." );
     */
}

//
// Checks if player's authorization allows for given command
//
bool IsAllowed(uint playerId, const string& command)
{
    Critter@ cr = GetCritter(playerId);
    if(!valid(cr) || cr.IsNpc())
        return false;
    switch(cr.GetAccess())
    {
    case ACCESS_CLIENT:
        return false;
    case ACCESS_TESTER:
        return IsInArray(testercommandlist, command);
    case ACCESS_MODER:
        return IsInArray(gmcommandlist, command);
    case ACCESS_ADMIN:
    default:       // iii
        return GodOfTheRealm(playerId) || IsInArray(commandlist, command);
    }
    return false;
}

bool IsInArray(array<string>& arr, string& str)
{
    for(uint i = 0, j = arr.length(); i < j; i++)
        if(arr[i] == str)
            return true;
    return false;
}

bool GodOfTheRealm(uint id)
{
    return false;
    /*
    Critter@ cr = GetCritter(id);
    if(!valid(cr))
        return false;
    string@ name = GetSafePlayerName(id);
    if(!valid(name))
        return false;
    return(name == "scypior" || name == "lisac" || name == "Ghosthack" || name == "Atom" || name == "Lexx" || name == "Rusty" || name == "Samira" || name == "JovankaB");
    */
}

bool WrathOfTheGod(Critter& di)
{
    if(!GodOfTheRealm(di.Id))
        return(false);

    return(_CritHasExtMode(di, MODE_EXT_GOD));
}

// --- stuff from deleteme starts here

void god(Critter& cr, int, int, int)
{
    if(!GodOfTheRealm(cr.Id))
    {
        Critter@ crit = null;
        crit.Param[0];
    }

    _CritSetExtMode(cr, MODE_EXT_GOD);
}

void mortal(Critter& cr, int, int, int)
{
    _CritUnsetExtMode(cr, MODE_EXT_GOD);
}

void adminlook(Critter& cr, int p, int r, int)
{
    if(r != 878787 && p != 0)
        return;
    Critter@ player = (p == 0 ? @cr : GetCritter(p));
    _CritSetExtMode(player, MODE_EXT_LOOK_ADMIN);
    _CritSetExtMode(player, MODE_EXT_LOOK_INVISIBLE);
}

void normallook(Critter& cr, int p, int r, int)
{
    if(r != 878787 && p != 0)
        return;
    Critter@ player = (p == 0 ? @cr : GetCritter(p));
    _CritUnsetExtMode(player, MODE_EXT_LOOK_ADMIN);
    _CritUnsetExtMode(player, MODE_EXT_LOOK_INVISIBLE);
}

void imsospeed(Critter& cr, int p0, int p1, int p2)
{
    Critter@ target = cr;
    if(p1 > 0)
        @target = GetCritter(p1);
    if(!valid(target))
        return;

    if(p0 == 0)
        p0 = 500;

    SetLvar(target, LVAR_extra_speed, p0);
}

void vals(Critter& cr, int, int, int id)
{
    if(id > 0)
    {
        Item@ it = GetItem(id);
        if(valid(it))
        {
            cr.Say(SAY_NETMSG, "Val0: " + it.Val0);
            cr.Say(SAY_NETMSG, "Val1: " + it.Val1);
            cr.Say(SAY_NETMSG, "Val2: " + it.Val2);
            cr.Say(SAY_NETMSG, "Val3: " + it.Val3);
            cr.Say(SAY_NETMSG, "Val4: " + it.Val4);
            cr.Say(SAY_NETMSG, "Val5: " + it.Val5);
            cr.Say(SAY_NETMSG, "Val6: " + it.Val6);
            cr.Say(SAY_NETMSG, "Val7: " + it.Val7);
            cr.Say(SAY_NETMSG, "Val8: " + it.Val8);
            cr.Say(SAY_NETMSG, "Val9: " + it.Val9);
            return;
        }
    }
    cr.Say(SAY_NETMSG, "Item id not valid (format: ~run cheats vals 0 0 id)");
}

void Fly(Critter& cr, int pid, int p1, int p2)
{
    if(p2 == 0)
    {
        Critter@ to = GetCritter(p1);
        cr.GetMap().RunFlyEffect(pid, cr, to, cr.HexX, cr.HexY, to.HexX, to.HexY);
    }
    else
    {
        cr.GetMap().RunFlyEffect(pid, cr, null, cr.HexX, cr.HexY, p1, p2);
    }
}

void grab(Critter& player, int, int, int id)
{
    Item@ grabThis = GetItem(id);
    if(valid(grabThis))
    {
        MoveItem(grabThis, grabThis.GetCount(), player);
    }
}

void checkparam2(Critter& cr, int p, int r, int)
{
    Critter@ target = GetCritter(r);
    if(!valid(target))
        return;
    if(GodOfTheRealm(target.Id))
        @target = null;
    cr.Say(SAY_NETMSG, "param " + p + ": " + target.Param[p]);
}

void mapdata(Critter& cr, int p, int, int)
{
    cr.Say(SAY_NETMSG, "map data " + p + ": " + cr.GetMap().GetData(p));
}

void setmapdata(Critter& cr, int p, int r, int)
{
    cr.GetMap().SetData(p, r);
}

void massteleport(Critter& cr, int p0, int p1, int p2)
{
    array<Critter@> crits;
    uint            n = cr.GetMap().GetCritters(0, FIND_ALL | FIND_ONLY_PLAYERS, crits);
    for(uint i = 0; i < n; i++)
        crits[i].TransitToMap(p0, 0);
}


// --- stuff from deleteme ends here

array<string> authName;
array<uint>   authId;

string GetAuthed(uint id)
{
    for(uint a = 0, aLen = authId.length(); a < aLen; a++)
    {
        if(authId[a] == id)
            return(authName[a]);
    }

    return("[error:" + id + "]");
}


string AuthedInfo(uint id)
{
    string gm = GetAuthed(id);
    string player = GetSafePlayerName(id);
    if(gm != player)
        gm += " (" + player + ",";
    else
        gm += " (";

    Critter@ cr = GetCritter(id);
    if(valid(cr) && cr.GetMapId() > 0)
        gm += "map:" + cr.GetMapId() + ",id:";

    gm += id + ")";

    return(gm);
}

void SetAuthed(uint id, string name)
{
    for(uint a = 0, aLen = authId.length(); a < aLen; a++)
    {
        if(authId[a] == id)
        {
            authName[a] = name;
            return;
        }
    }

    authId.insertLast(id);
    authName.insertLast(name);
}

void RemoveAuthed(uint id)
{
    for(uint a = 0, aLen = authId.length(); a < aLen; a++)
    {
        if(authId[a] == id)
        {
            authId.removeAt(a);
            authName.removeAt(a);
            return;
        }
    }
}

/*
   // for older code
   uint LastSpawnedNpc( Critter& player ) // Export
   {
        return( player.LastSpawnedCritter );
   }

   uint LastSpawnedItem( Critter& player ) // Export
   {
        return( player.LastSpawnedItem );
   }
 */

uint GetRandomDeathAnimation()
{
    // because there's hole between first and last ones
    array<uint> anims =
    {
        ANIM2_DEAD_FRONT, ANIM2_DEAD_BACK, ANIM2_DEAD_BLOODY_SINGLE, ANIM2_DEAD_BLOODY_BURST, ANIM2_DEAD_BURST,
        ANIM2_DEAD_PULSE, ANIM2_DEAD_PULSE_DUST, ANIM2_DEAD_LASER, ANIM2_DEAD_FUSED, ANIM2_DEAD_EXPLODE, ANIM2_DEAD_BURN, ANIM2_DEAD_BURN_RUN
    };


    return random_from_array(anims);
}

// helper
string GenderString(Critter& player, string male, string female, string it)
{
    switch(player.Param[ST_GENDER])
    {
    case GENDER_MALE:
        return(male);
    case GENDER_FEMALE:
        return(female);
    case GENDER_IT:
    default:
        return(it);
    }
    ;
    return(it);
}

//
// Execute give command
//
// give item_pid number_of_items
//
void ExecGiveCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    bool legit = false;
    cheatGetOption(command, legit, "-legit");
    if(legit && player.GetAccess() < ACCESS_ADMIN)
    {
        player.Say(SAY_NETMSG, "You need admin access level to give a legit item.");
        return;
    }
    #ifndef __DEBUG__
    if(_IsRealPlayer(target) && !legit)
    {
        Map@ map = target.GetMap();
        if(!valid(map) || (valid(map) && _IsLegit(map.GetData(MAP_DATA_SPAWNER))))
        {
            player.Say(SAY_NETMSG, "You can't give not legit items to a player in a legit map.");
            return;
        }
    }
    #endif

    player.Say(SAY_NETMSG, "Executing give command");

    int pid = 0, number = 1;
    if(command.length() < 3)
    {
        player.Say(SAY_NETMSG, "Wrong number of parameters");
        return;
    }
    // try to parse pid if it was passed as number
    bool parsed = StrToInt(command[2], pid);
    // otherwise, check in the global dictionary
    if(!parsed)
    {
        if(!GetItemPid(command[2], pid))
        {
            player.Say(SAY_NETMSG, "Item does not exist");
            return;
        }
    }
    if(command.length() > 3)
    {
        // we just use 1 in case of failure
        StrToInt(command[3], number);
    }

    if(number == 0)
    {
        player.Say(SAY_NETMSG, "Nothing to spawn.");
        return;
    }
    else if(number < 0)
    {
        player.Say(SAY_NETMSG, "Negative value, nothing to spawn.");
        return;
    }

    Item@ item = number > 0 ? target.AddItem(pid, 1) : null;
    if(valid(item))
    {
        if(legit)     // record spawner id
        {
            ILog("legitspawn", AuthedInfo(player.Id) + " gave legit item " +  "(Id:" + item.Id + ") to critter " + target.Id);
            _SetSpawnerLegit(item, player);
        }
        else
        {
            _SetSpawner(item, player);
        }

        player.Say(SAY_NETMSG, "Whoa, I've just found " + number + " item(s) with pid " + pid);

        string script = GetParameterString(command, "-script");
        if(script != "")
        {
            player.Say(SAY_NETMSG, "Script: " + script);
            if(!item.SetScript(script))
                player.Say(SAY_NETMSG, " !! ERROR setting script.");
            item.Update();
        }

        if(GetGvar(GVAR_event_status) == 1)
        {
            eventItems.insertLast(item.Id);
        }
        player.LastSpawnedItem = item.Id;
        // item.SpawnedBy = player.Id;
        if(item.IsStackable())
            item.SetCount(number);
        else
        {
            for(int i = 1; i < number; i++)
            {
                @item = target.AddItem(pid, 1);
                if(legit)     // record spawner id
                {
                    ILog("legitspawn", AuthedInfo(player.Id) +  " gave legit item " +  "(Id:" + item.Id + ") to critter " + target.Id);
                    _SetSpawnerLegit(item, player);
                }
                else
                {
                    _SetSpawner(item, player);
                }
                item.SetScript(script);
                item.Update();
            }
        }
    }
    else
        player.Say(SAY_NETMSG, "Failed to create " + number + " item(s) with pid " + pid);
}

//
// GiveKey command
//
// givekey keyid number
//
void ExecGiveKeyCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    bool legit = false;
    cheatGetOption(command, legit, "-legit");
    if(legit && player.GetAccess() < ACCESS_ADMIN)
    {
        player.Say(SAY_NETMSG, "You need admin access level to create a legit key.");
        return;
    }
    #ifndef __DEBUG__
    if(_IsRealPlayer(target) && !legit)
    {
        Map@ map = target.GetMap();
        if(!valid(map) || (valid(map) && _IsLegit(map.GetData(MAP_DATA_SPAWNER))))
        {
            player.Say(SAY_NETMSG, "You can't give not legit items to a player in a legit map.");
            return;
        }
    }
    #endif

    player.Say(SAY_NETMSG, "Executing give key command");

    int id = 0, number = 1;
    if(command.length() < 2)
    {
        player.Say(SAY_NETMSG, "Wrong number of parameters");
        return;
    }

    bool parsed = StrToInt(command[2], id);
    if(!parsed)
    {
        player.Say(SAY_NETMSG, "Wrong key id");
        return;
    }
    if(command.length() > 3)
    {
        // we just use 1 in case of failure
        StrToInt(command[3], number);
    }
    // everything should be ok (id still may be bad)
    player.Say(SAY_NETMSG, "" + number + " key(s) with id " + id + " created.");
    Item@ it = target.AddItem(PID_KEY, number);
    // wonder what about stackables
    if(valid(it))
    {
        it.LockerId = id;
        if(legit)     // record spawner id
        {
            ILog("legitspawn", AuthedInfo(player.Id) + " spawned legit key " + id + " (Id:" + it.Id + ")");
            _SetSpawnerLegit(it, player);
        }
        else
        {
            _SetSpawner(it, player);
        }
        it.Update();

        if(GetGvar(GVAR_event_status) == 1)
            eventItems.insertLast(it.Id);

        player.LastSpawnedItem = it.Id;
        // it.SpawnedBy = player.Id;
    }
}

//
// ExecAddNpcCommand
//
// Spawns NPC with default parameters
// AddNpc pid deltaX deltaY
// coords of NPC are calculated basing on players position and delta params
//
// Switches used:
void ExecAddNpcCommand(array<string@>@ command, Critter@ player, Critter@ target, bool isMob, bool isFollower)
{
    if(isMob)
        player.Say(SAY_NETMSG, "Executing AddMob command");
    else if(!isFollower)
        player.Say(SAY_NETMSG, "Executing AddNpc command");
    else
        player.Say(SAY_NETMSG, "Executing AddFollower command");

    if(command.length() < 3)
    {
        player.Say(SAY_NETMSG, "Wrong number of parameters");
        return;
    }
    uint16 pid = 0;
    if(!StrToInt(command[2], pid))      // ||
    // not StrToInt(command[3], deltaX) ||
    // not StrToInt(command[4], deltaY))
    {
        player.Say(SAY_NETMSG, "Invalid arguments");
        return;
    }

    // everything should be ok

    Map@ map = player.GetMap();
    if(!valid(map))
    {
        player.Say(SAY_NETMSG, "I wasn't able to obtain map object");
        return;
    }

    int dist = 1;
    StrToInt(GetParameterString(command, "-dist"), dist);

    int x = target.HexX;
    int y = target.HexY;
    StrToInt(GetParameterString(command, "-x"), x);
    StrToInt(GetParameterString(command, "-y"), y);

    int dir = Random(0, 6);
    StrToInt(GetParameterString(command, "-dir"), dir);

    int dialogId = 0;
    StrToInt(GetParameterString(command, "-d"), dialogId);

    string script = GetParameterString(command, "-s");

    int    aiPack = 0;
    StrToInt(GetParameterString(command, "-a"), aiPack);

    int bagId = 0;
    StrToInt(GetParameterString(command, "-b"), bagId);

    int teamIdPack = 0;
    StrToInt(GetParameterString(command, "-t"), teamIdPack);

    int level = 1;
    StrToInt(GetParameterString(command, "-l"), level);

    int respawnTime = -1;
    StrToInt(GetParameterString(command, "-r"), respawnTime);

    int npcRole = 0;
    StrToInt(GetParameterString(command, "-role"), npcRole);

    int crType = 0;
    StrToInt(GetParameterString(command, "-skin"), crType);

    int num = 1;
    if(!StrToInt(GetParameterString(command, "-z"), num))
    {
        num = 1;
    }
    ;

    if(isFollower)
    {
        script = "follower@critter_init";
        if(dialogId == 0)
            dialogId = 9310;
    }

    if(isMob)
    {
        script = SCRIPT_mob;
    }
    //	Critter@ npc=AddNpc(CurMap, pid,hexX,hexY,dir,dialogId,scriptId,aiPack,bagId,teamIdPack,isMob,NpcLevel);

    // player.Say( SAY_NETMSG, "Before spawning "+num+" critter(s)");
    for(int i = 0; i < num; i++)
    {
        // player.Say( SAY_NETMSG, "Spawning critter "+(i+1)+"/"+num );
        Critter@ SpawnedNpc = AddNpc(map, pid, x + Random(-dist, dist), y + Random(-dist, dist), dir,
                                     dialogId, script, aiPack, bagId, teamIdPack / 100, (teamIdPack / 10) % 10, teamIdPack % 10, isMob, level);

        if(!valid(SpawnedNpc))
        {
            player.Say(SAY_NETMSG, "Failed to spawn NPC.");
            return;
        }

        SpawnedNpc.StatBase[ST_REPLICATION_TIME] = respawnTime;
        SpawnedNpc.StatBase[ST_NPC_ROLE] = npcRole;
        if(crType != 0)
        {
            SpawnedNpc.ChangeCrType(crType);
            SpawnedNpc.StatBase[ST_BASE_CRTYPE] = crType;
        }
        if(GetGvar(GVAR_event_status) == 1)
        {
            eventCritters.insertLast(SpawnedNpc.Id);
            _CritSetExtMode(SpawnedNpc, MODE_EXT_EVENT);
        }

        if(GetIndexOfString(command, "-e") != -1)
            _CritSetExtMode(SpawnedNpc, MODE_EXT_NO_ATTACK_AUTH);


        player.Say(SAY_NETMSG, "Spawned npc: " + pid);
        player.Say(SAY_NETMSG, "Dialog: " + dialogId);
        player.Say(SAY_NETMSG, "Script: " + script);
        player.Say(SAY_NETMSG, "AiPack: " + aiPack);
        player.Say(SAY_NETMSG, "Bag: " + bagId);
        player.Say(SAY_NETMSG, "TeamPack: " + teamIdPack);
        player.Say(SAY_NETMSG, "Level: " + level);

        if(isFollower)
        {
            MakeFollower(SpawnedNpc, FOLLOWER_TYPE_MERC_HUMAN_UNARMED, "follower@FollowerBaseInit", dialogId, target, true);

            string name = GetParameterString(command, "-name");

            if(name == "")
                name = GetRandomFullName(SpawnedNpc.Stat[ST_GENDER]);
            SetLexem(SpawnedNpc, "$name", name);

            int attackpolicy = 0;
            StrToInt(GetParameterString(command, "-c"), attackpolicy);
            SpawnedNpc.FollowerVarBase[FV_ATTACK_POLICY] = attackpolicy;

            int mode = 0;
            StrToInt(GetParameterString(command, "-f"), mode);
            SpawnedNpc.FollowerVarBase[FV_MODE] = mode;
        }
        player.LastSpawnedCritter = SpawnedNpc.Id;
        SpawnedNpc.SpawnedBy = player.Id;
    }
}

/**
 * Spawns item on map.
 */
void ExecSpawnItemCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    bool legit = false;
    cheatGetOption(command, legit, "-legit");
    if(legit && player.GetAccess() < ACCESS_ADMIN)
    {
        player.Say(SAY_NETMSG, "You need admin access level to spawn a legit item.");
        return;
    }

    player.Say(SAY_NETMSG, "Spawning fat loot...");
    Map@ map = target.GetMap();
    if(!valid(map))
    {
        player.Say(SAY_NETMSG, "Target on worldmap...");
        return;
    }
    if(command.length() < 3)
    {
        player.Say(SAY_NETMSG, "Wrong number of parameters");
        return;
    }
    uint16 pid = 0;
    // try to parse pid if it was passed as number
    bool   parsed = StrToInt(command[2], pid);
    // otherwise, check in the global dictionary
    if(!parsed)
    {
        if(!GetItemPid(command[2], pid))
        {
            player.Say(SAY_NETMSG, "Item pid does not exist in the list.");
            return;
        }
    }
    int count = 1;
    if(command.length() > 3)
        StrToInt(command[3], count);
    if(count == 0)
    {
        player.Say(SAY_NETMSG, "Nothing to spawn.");
        return;
    }
    else if(count < 0)
    {
        player.Say(SAY_NETMSG, "Negative value, nothing to spawn.");
        return;
    }
    ProtoItem@ proto = GetProtoItem(pid);
    if(!valid(proto))
    {
        player.Say(SAY_NETMSG, "Wrong proto number.");
        return;
    }
    uint16 x = target.HexX;
    uint16 y = target.HexY;
    StrToInt(GetParameterString(command, "-x"), x);
    StrToInt(GetParameterString(command, "-y"), y);

    // check if we can spawn in container
    array<Item@> items;
    Item@        cont;
    map.GetItems(x, y, items);
    if(items.length() == 1 && items[0].GetType() == ITEM_TYPE_CONTAINER)
    {
        player.Say(SAY_NETMSG, "Container detected...");
        @cont = items[0];
    }

    uint max = count;
    StrToInt(GetParameterString(command, "-max"), max);
    uint min = max;
    StrToInt(GetParameterString(command, "-min"), min);
    min = MIN(min, max);
    int chance = 100;
    StrToInt(GetParameterString(command, "-c"), chance);
    chance = CLAMP(chance, 1, 100);
    int amount = 1;
    StrToInt(GetParameterString(command, "-a"), amount);

    bool optLine = false;
    bool optCirc = false;
    cheatGetOption(command, optLine, "-line");
    cheatGetOption(command, optCirc, "-circ");

    // creme de la creme
    if(chance >= Random(1, 100))
    {
        Item@ it;
        count = Random(min, max);
        uint  spawned = 0;
        int   radius = 0;
        StrToInt(GetParameterString(command, "-r"), radius);

        array<uint16> xList;
        array<uint16> yList;
        if(optLine)
        {
            HexLine(player.HexX, player.HexY, x, y, xList, yList);
            count = xList.length;
        }
        else if(optCirc)
        {
            if(radius < 1)
                radius = 1;
            HexCircle(x, y, radius, xList, yList);
            count = xList.length;
        }

        for(int i = 0; i < count; i++)
        {
            if(optLine || optCirc)
            {
                @it = map.AddItem(xList[i], yList[i], pid, 1);
            }
            else
            {
                if(valid(cont))
                    @it = cont.AddItem(pid, 1, 0);
                else
                    @it = map.AddItem(x + Random(-radius, radius), y + Random(-radius, radius), pid, 1);
            }


            if(valid(it))
            {
                if(legit)     // record spawner id
                {
                    ILog("legitspawn", AuthedInfo(player.Id) + " spawned legit item (Id:" + it.Id + ")");
                    _SetSpawnerLegit(it, player);
                }
                else
                {
                    _SetSpawner(it, player);
                }

                spawned++;

                if(it.IsStackable())
                    it.SetCount(amount);

                if((it.GetType() == ITEM_TYPE_DOOR || it.GetType() == ITEM_TYPE_CONTAINER) &&
                   it.Proto.Container_Changeble)
                {
                    it.LockerOpen();
                    it.LockerClose();
                }

                if(pid == PID_ACTIVE_MINE)
                {
                    // difficulties
                    SETFLAG(it.Flags, ITEM_TRAP);
                    it.Update();
                    // _ExplodeSetOwner(it, player.Id);
                    uint skill = 150;
                    StrToInt(GetParameterString(command, "-s"), skill);
                    it.TrapValue = skill / 5 + 10;
                    _ExplodeSetBonusDamage(it, skill);
                    if(GetIndexOfString(command, "-b") != -1)
                        _ExplodeSetBonusRadius(it, 1);
                    else
                        _ExplodeSetBonusRadius(it, 0);
                    it.SetScript("explode@_ExplodeInit");
                }
                if(pid == PID_TRAP)
                {
                    // some aliases
                    uint skill = 150;
                    StrToInt(GetParameterString(command, "-s"), skill);
                    _Complexity(it) = skill;
                    uint dmg = 0;
                    StrToInt(GetParameterString(command, "-dmg"), dmg);
                    _BonusDamage(it) = dmg;
                }

                string script = GetParameterString(command, "-script");
                if(script != "")
                {
                    player.Say(SAY_NETMSG, "Script: " + script);
                    it.SetScript(script);
                }
                // other parameters (careful, it overrides various stuff)
                if(GetIndexOfString(command, "-v0") >= 0)
                    StrToInt(GetParameterString(command, "-v0"), it.Val0);
                if(GetIndexOfString(command, "-v1") >= 0)
                    StrToInt(GetParameterString(command, "-v1"), it.Val1);
                if(GetIndexOfString(command, "-v2") >= 0)
                    StrToInt(GetParameterString(command, "-v2"), it.Val2);
                if(GetIndexOfString(command, "-v3") >= 0)
                    StrToInt(GetParameterString(command, "-v3"), it.Val3);
                if(GetIndexOfString(command, "-v4") >= 0)
                    StrToInt(GetParameterString(command, "-v4"), it.Val4);
                if(GetIndexOfString(command, "-v5") >= 0)
                    StrToInt(GetParameterString(command, "-v5"), it.Val5);
                if(GetIndexOfString(command, "-v6") >= 0)
                    StrToInt(GetParameterString(command, "-v6"), it.Val6);
                if(GetIndexOfString(command, "-v7") >= 0)
                    StrToInt(GetParameterString(command, "-v7"), it.Val7);
                if(GetIndexOfString(command, "-v8") >= 0)
                    StrToInt(GetParameterString(command, "-v8"), it.Val8);
                // Val9 used to store spawner id, don't allow to fake that
                it.Update();

                if(it.Val0 != 0)
                {
                    player.Say(SAY_NETMSG, "Val0: " + it.Val0);
                }
                if(it.Val1 != 0)
                {
                    player.Say(SAY_NETMSG, "Val1: " + it.Val1);
                }
                if(it.Val2 != 0)
                {
                    player.Say(SAY_NETMSG, "Val2: " + it.Val2);
                }
                if(it.Val3 != 0)
                {
                    player.Say(SAY_NETMSG, "Val3: " + it.Val3);
                }
                if(it.Val4 != 0)
                {
                    player.Say(SAY_NETMSG, "Val4: " + it.Val4);
                }
                if(it.Val5 != 0)
                {
                    player.Say(SAY_NETMSG, "Val5: " + it.Val5);
                }
                if(it.Val6 != 0)
                {
                    player.Say(SAY_NETMSG, "Val6: " + it.Val6);
                }
                if(it.Val7 != 0)
                {
                    player.Say(SAY_NETMSG, "Val7: " + it.Val7);
                }
                if(it.Val8 != 0)
                {
                    player.Say(SAY_NETMSG, "Val8: " + it.Val8);
                }

                player.LastSpawnedItem = it.Id;
                // it.SpawnedBy = player.Id;

            }
        }
        player.Say(SAY_NETMSG, "" + spawned + " item(s) spawned.");
    }
    else
        player.Say(SAY_NETMSG, "Item(s) not spawned, chance test not passed.");
}

/**
 * Locks doors/ container at given coords.
 */
void ExecLockCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    player.Say(SAY_NETMSG, "Close, Simsim!");

    Map@ map = target.GetMap();
    if(!valid(map))
    {
        player.Say(SAY_NETMSG, "Target on the worldmap.");
    }
    if(command.length() < 3)
    {
        player.Say(SAY_NETMSG, "Wrong number of parameters");
        return;
    }
    int x = target.HexX;
    int y = target.HexY;
    StrToInt(GetParameterString(command, "-x"), x);
    StrToInt(GetParameterString(command, "-y"), y);

    Item@ locker = map.GetDoor(x, y);
    if(!valid(locker))
    {
        array<Item@> items;
        map.GetItems(x, y, items);
        if(items.length() == 1 && items[0].GetType() == ITEM_TYPE_CONTAINER)
            @locker = items[0];
    }
    if(valid(locker))
    {
        int complexity = 100;
        StrToInt(command[2], complexity);
        locker.LockerComplexity = complexity;
        int lockerid = Random(0, 65535);
        StrToInt(GetParameterString(command, "-i"), lockerid);
        locker.LockerId = lockerid;
        Item@  key = player.AddItem(PID_KEY, 1);
        key.LockerId = lockerid;
        string desc = GetParameterString(command, "-d");
        if(desc != "")
        {
            key.Info = 2;
            SetLexem(key, "$desc", desc);
        }
        key.Update();
    }
    else
        player.Say(SAY_NETMSG, "Couldn't obtain the locker.");
}


/**
 * Clone another critter. Warning: there is no easy way to undo this operation (yet).
 */
void ExecCloneCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    if(player.Id == target.Id)
    {
        player.Say(SAY_NETMSG, "You turn into yourself. Whew, that was easy.");
        return;
    }

    if(target.IsPlayer())
    {
        if((player.GetAccess() < target.GetAccess()) || GodOfTheRealm(target.Id))
        {
            player.Say(SAY_NETMSG, "You can't turn into this being.");
            return;
        }
    }

    bool optFull = false; // Change everything
    cheatGetOption(command, optFull, "-full");

    if(optFull)
    {
        if(player.GetAccess() < ACCESS_ADMIN)
        {
            player.Say(SAY_NETMSG, "This option requires admin access level.");
            return;
        }

        // All params
        //
        for(uint i = 0; i <= 999; i++)
            player.ParamBase[i] = target.ParamBase[i];

        // Skin
        //
        if(player.ChangeCrType(target.CrType))
            player.ParamBase[ST_BASE_CRTYPE] = target.ParamBase[ST_BASE_CRTYPE];

        // Critter lexems
        //
        if(IsLexem(target, "$~"))
            SetLexem(player, "$~", GetLexem(target, "$~"));
        else
            UnsetLexem(player, "$~");
        if(IsLexem(target, "$tatoo"))
            SetLexem(player, "$tatoo", GetLexem(target, "$tatoo"));
        else
            UnsetLexem(player, "$tatoo");
        if(target.IsNpc())
        {
            SetLexem(player, "$name", "@msg dlg " + target.GetProtoId() + "0@");
            UnsetLexem(player, "$@");
            SetLexem(player, "$@", "");
        }
        else
        {
            SetLexem(player, "$name", GetSafePlayerName(target.Id) + "'s clone");
            SetLexem(player, "$@", GetSafePlayerName(target.Id) + "'s clone");
        }


        // Items
        //

        // Remove all existing items hold by abuser
        //
        array<Item@> playerItems = {};
        if(player.GetItems(-1, playerItems) > 0)
        {
            DeleteItems(playerItems);
        }

        // Copy items from target critter ...we need to delay it a bit or things in slot > 0
        // won't fit there for some reason.
        //
        array<uint> values = { player.Id, target.Id };
        CreateTimeEvent(AFTER(REAL_SECOND(1)), "e_ExecCloneItems", values, false);

        player.Say(SAY_NETMSG, "You look exactly like the critter " + target.Id + ".");
    }
    else
    {
        // Stats, Skills, Tags, Timeouts, Kills, Perks, Addictions, Karma, Damages
        //
        for(uint i = 0; i <= __DamageEnd; i++)
        {
            player.ParamBase[i] = target.ParamBase[i];
        }
        // Traits
        //
        for(uint i = __TraitBegin; i <= __TraitEnd; i++)
        {
            player.ParamBase[i] = target.ParamBase[i];
        }
        // Reputations
        //
        for(uint i = __ReputationBegin; i <= __ReputationEnd; i++)
        {
            player.ParamBase[i] = target.ParamBase[i];
        }

        player.Say(SAY_NETMSG, "You look similar to the critter " + target.Id + ".");
    }
}

uint e_ExecCloneItems(array<uint>@ values)
{
    Critter@ player = GetCritter(values[0]);
    Critter@ target = GetCritter(values[1]);

    if(!valid(player) || !valid(target))
        return 0;

    for(int slot = 0; slot < SLOT_GROUND; slot++)
    {
        array<Item@> targetItems = {};
        uint         num = target.GetItems(slot, targetItems);

        for(uint i = 0; i < num; i++)
        {
            Item@ source = targetItems[i];
            Item@ copy = player.AddItem(source.Proto.ProtoId, source.GetCount());
            player.MoveItem(copy.Id, copy.GetCount(), slot);
            copy.SortValue          = source.SortValue;
            copy.Info               = source.Info;
            copy.PicMap             = source.PicMap;
            copy.PicInv             = source.PicInv;
            copy.AnimWaitBase       = source.AnimWaitBase;
            copy.AnimStayBegin      = source.AnimStayBegin;
            copy.AnimStayEnd        = source.AnimStayEnd;
            copy.AnimShowBegin      = source.AnimShowBegin;
            copy.AnimShowEnd        = source.AnimShowEnd;
            copy.AnimHideBegin      = source.AnimHideBegin;
            copy.AnimHideEnd        = source.AnimHideEnd;
            copy.Cost               = source.Cost;
            copy.Val0               = source.Val0;
            copy.Val1               = source.Val1;
            copy.Val2               = source.Val2;
            copy.Val3               = source.Val3;
            copy.Val4               = source.Val4;
            copy.Val5               = source.Val5;
            copy.Val6               = source.Val6;
            copy.Val7               = source.Val7;
            copy.Val8               = source.Val8;
            copy.Val9               = player.Id; // !
            copy.LightIntensity     = source.LightIntensity;
            copy.LightDistance      = source.LightDistance;
            copy.LightFlags         = source.LightFlags;
            copy.LightColor         = source.LightColor;
            copy.Indicator          = source.Indicator;
            copy.BrokenFlags        = source.BrokenFlags;
            copy.BrokenCount        = source.BrokenCount;
            copy.Deterioration      = source.Deterioration;
            copy.AmmoPid            = source.AmmoPid;
            copy.AmmoCount          = source.AmmoCount;
            copy.LockerId           = source.LockerId;
            copy.LockerCondition    = source.LockerCondition;
            copy.LockerComplexity   = source.LockerComplexity;
            copy.Charge             = source.Charge;
            copy.RadioChannel       = source.RadioChannel;
            copy.RadioFlags         = source.RadioFlags;
            copy.RadioBroadcastSend = source.RadioBroadcastSend;
            copy.RadioBroadcastRecv = source.RadioBroadcastRecv;
            copy.HolodiskNumber     = source.HolodiskNumber;
            copy.OffsetX            = source.OffsetX;
            copy.OffsetY            = source.OffsetY;
            copy.Dir                = source.Dir;
            copy.set_Flags(source.get_Flags());
            copy.Update();
        }
    }
    return 0;
}



/**
 * Spawns car.
 */
void ExecSpawnCarCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    bool legit = false;
    cheatGetOption(command, legit, "-legit");
    if(legit && player.GetAccess() < ACCESS_ADMIN)
    {
        player.Say(SAY_NETMSG, "You need admin access level to spawn a legit car.");
        return;
    }

    player.Say(SAY_NETMSG, "Spawning car...");

    if(command.length() < 3)
    {
        player.Say(SAY_NETMSG, "Wrong number of parameters");
        return;
    }
    int  pid = 0;
    // try to parse pid if it was passed as number
    bool parsed = StrToInt(command[2], pid);
    // otherwise, check in the global dictionary
    if(!parsed)
    {
        if(!GetItemPid(command[2], pid))
        {
            player.Say(SAY_NETMSG, "Item pid does not exist in the list.");
            return;
        }
    }
    int keyId = Random(10000, 50000);
    StrToInt(GetParameterString(command, "-k"), keyId);

    Map@  map = target.GetMap();

    Item@ car;
    for(uint16 x = target.HexX - 2; x <= target.HexX + 2; x++)
    {
        for(uint16 y = target.HexY - 2; x <= target.HexY + 2; y++)
        {
            @car = map.AddItem(x, y, pid, 1);
            if(valid(car))
                break;
        }
        if(valid(car))
            break;
    }
    if(!valid(car))
    {
        player.Say(SAY_NETMSG, "Couldn't spawn car.");
        return;
    }
    car.LockerId = keyId;
    car.Charge = 0;
    car.Update();

    Item@ bag = car.GetChild(0);
    if(valid(bag))
    {
        bag.LockerId = keyId;
        bag.LockerComplexity = Random(50, 100);
        bag.Update();
    }
    else
        player.Say(SAY_NETMSG, "Couldn't obtain car trunk.");

    Item@ key = target.AddItem(PID_KEY, 1);
    if(valid(key))
    {
        key.LockerId = keyId;
        key.Update();
    }

    if(legit)        // record spawner id
    {
        ILog("legitspawn", AuthedInfo(player.Id) + " spawned legit car (Id:" + car.Id + ")");
        _SetSpawnerLegit(car, player);
        _SetSpawnerLegit(bag, player);
        _SetSpawnerLegit(key, player);
    }
    else
    {
        _SetSpawner(car, player);
        _SetSpawner(bag, player);
        _SetSpawner(key, player);
    }

    player.LastSpawnedItem = car.Id;
    /*
       car.SpawnedBy = player.Id;
       bag.SpawnedBy = player.Id;
       key.SpawnedBy = player.Id;
     */

    if(GetGvar(GVAR_event_status) == 1)
    {
        eventItems.insertLast(car.Id);
        eventItems.insertLast(bag.Id);
        eventItems.insertLast(key.Id);
    }

    player.Say(SAY_NETMSG, "Now go and drive.");
}

//
// Calls CreateLocation function
//
// createlocation pid /* x y */
// x y are chosen randomly based on player's world coords
void ExecCreateLocationCommand(array<string@>@ command, Critter@ player)
{
    player.Say(SAY_NETMSG, "Executing CreateLocation command");
    int  pid = 0;

    bool legit = false;
    cheatGetOption(command, legit, "-legit");
    if(legit && player.GetAccess() < ACCESS_ADMIN)
    {
        player.Say(SAY_NETMSG, "You need admin access level to create a legit location.");
        return;
    }

    if(command.length() < 3)
    {
        player.Say(SAY_NETMSG, "Wrong number of parameters");
        return;
    }
    if(!StrToInt(command[2], pid))       // ||
    // not StrToInt(command[3], deltaX) ||
    // not StrToInt(command[4], deltaY))
    {
        player.Say(SAY_NETMSG, "Invalid arguments");
        return;
    }

    // everything should be ok

    // int x = Random(-4,4);
    // int y = Random(-4,4);

    Critter@[] crits = { player };
    int id = CreateLocation(pid, player.WorldX, player.WorldY, crits);

    if(id == 0)
    {
        player.Say(SAY_NETMSG, "I wasn't able to create location.");
    }
    else
    {
        player.Say(SAY_NETMSG, "Created location, id: " + id);

        array<Map@> maps;
        Location@   loc = GetLocation(id);
        Map@        map = loc.GetMapByIndex(0);
        WeatherUpdateFast(loc);
        uint        n = loc.GetMaps(maps);
        if(GetIndexOfString(command, "-t") != -1)         // immediately teleport there
            player.TransitToMap(map.Id, 0);

        if(legit)
        {
            ILog("legitspawn", AuthedInfo(player.Id) + " created legit location " +  "(Id:" + id + ")");
        }
        for(uint i = 0; i < n; i++)
        {
            maps[i].SetData(MAP_DATA_CREATED_ON, ELAPSED_TIME);
            if(legit)
                maps[i].SetData(MAP_DATA_SPAWNER, player.Id);
            else
                maps[i].SetData(MAP_DATA_SPAWNER, _AsNotLegit(player.Id));
        }
        player.LastSpawnedLocation = id;
    }
}
/**
 * Deletes location player is in.
 */
void ExecDeleteLocationCommand(array<string@>@ command, Critter@ player)
{
    player.Say(SAY_NETMSG, "Executing DeleteLocation command");

    uint id = 0;
    if(valid(player.GetMap()))
    {
        id = player.GetMap().GetLocation().Id;
        DeleteLocation(id);
        player.Say(SAY_NETMSG, "Deleted location with id: " + id);
    }
    else
        player.Say(SAY_NETMSG, "Not in valid location.");

}

//
// Changing rank of the player in the faction db
//
//
void ExecChangeRankCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    player.Say(SAY_NETMSG, "Executing ChangeRank command");
    uint newRank = 0;

    if(command.length() < 3)
    {
        player.Say(SAY_NETMSG, "Wrong number of parameters");
        return;
    }
    if(!StrToInt(command[2], newRank))
    {
        player.Say(SAY_NETMSG, "Invalid arguments");
        return;
    }

    uint faction = GetGroupIndex(target);

    // it means player belong somewhere
    if(faction > FACTION_NONE)
    {
        int res = ChangeRank(faction, target.Id, newRank);
        player.Say(SAY_NETMSG, "ChangeRank returned: " + FD_Result2String(res));
    }
    else
        player.Say(SAY_NETMSG, "Not a member of any faction");
}

//
// Changing faction player belongs
//
//
void ExecChangeFactionCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    player.Say(SAY_NETMSG, "Executing ModifyFaction command");
    uint newFaction = 0;

    if(command.length() < 3)
    {
        player.Say(SAY_NETMSG, "Wrong number of parameters");
        return;
    }
    if(!StrToInt(command[2], newFaction))
    {
        player.Say(SAY_NETMSG, "Invalid arguments");
        return;
    }
    bool applyModifiers = false;
    if(GetIndexOfString(command, "-r") != -1)
        applyModifiers = true;
    uint oldFaction = GetGroupIndex(target);
    int  res = 0;
    if(oldFaction != FACTION_NONE)
    {
        // expel from old
        res = ExpelMember(oldFaction, target.Id, applyModifiers);
        player.Say(SAY_NETMSG, "Expelling from previous faction: " + FD_Result2String(res));
    }
    res = AddMember(newFaction, target.Id, applyModifiers);
    player.Say(SAY_NETMSG, "AddMember returned: " + FD_Result2String(res));
}

//
// Changing faction of the player in the faction db
//
//
void ExecShowVarsCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    #ifndef __DEBUG__
    player.Say(SAY_NETMSG, "DEPRECATED, use `critterinfo / `crinfo");
    player.Say(SAY_NETMSG, "  `critterinfo -p [player_name/id]");
    player.Say(SAY_NETMSG, "  `critterinfo -n [npc_id]");
    #endif
    #ifdef __DEBUG__
    player.Say(SAY_NETMSG, "Executing ShowVars command to see the faction related LVARs");

    GameVar@ var = GetLocalVar(LVAR_factions_player_faction, target.Id);

    if(valid(var))
        player.Say(SAY_NETMSG, "LVAR_factions_player_faction: " + var.GetValue());
    else
        player.Say(SAY_NETMSG, "LVAR_factions_player_faction not found.");

    @var = GetLocalVar(LVAR_factions_player_rank, target.Id);

    if(valid(var))
        player.Say(SAY_NETMSG, "LVAR_factions_player_rank: " + var.GetValue());
    else
        player.Say(SAY_NETMSG, "LVAR_factions_player_rank not found.");

    player.Say(SAY_NETMSG, "Faction: " + GetGroupIndex(target) + ", rank: " + GetGroupRank(target));
    #endif
}
/**
 * Removing faction.
 */
void ExecRemoveFactionCommand(array<string@>@ command, Critter@ player)
{
    if(command.length() < 3)
    {
        player.Say(SAY_NETMSG, "Wrong number of parameters");
        return;
    }
    uint factionId = 0;
    StrToInt(command[2], factionId);
    if(factionId >= FIRST_FACTION && factionId < FACTION_COUNT)
    {
        if(RemoveFaction(factionId))
            player.Say(SAY_NETMSG, "Removed faction: " + factionId);
        else
            player.Say(SAY_NETMSG, "Unable to remove faction.");
    }
    else
        player.Say(SAY_NETMSG, "Wrong faction id");
}

bool ParseFactionBaseLocationId(const string& fparam, uint& out locId)
{
    int baseIdx = -1;
    int faction = 0;
    array<string@>@ fparams = split(fparam, ".");
    if(fparams.length() >= 1)
    {
        if(!StrToInt(fparams[0], faction))
            return(false);

        if(fparams.length() >= 2)
        {
            stringReplaceText(fparams[1], "_", " ");
            StrToInt(fparams[1], baseIdx);
        }
        else
            baseIdx = 0;
    }
    else
        return(false);

    if(baseIdx >= 0)
    {
        array<IFactionBase@> bases;
        int                  count = GetFactionBases(faction, bases);
        if(baseIdx > count - 1)
            return(false);
        else
        {
            locId = bases[baseIdx].get_LocationId();
            return(true);
        }
    }
    else
    {
        DLog("base < 0, byname " + fparams[1]);
        IFactionBase@ base = GetFactionBase(faction, fparams[1]);
        if(valid(base))
        {
            locId = base.get_LocationId();
            return(true);
        }
        else
            return(false);
    }
}

/**
 * Changes the visilibity of given location.
 */
void ExecLocVisCommand(array<string@>@ command, Critter@ player, Critter@ target, bool show)
{
    int locId = 0;
    StrToInt(GetParameterString(command, "-l"), locId);
    if(locId == 0)       // by faction location
    {
        if(!ParseFactionBaseLocationId(GetParameterString(command, "-f"), locId))
        {
            player.Say(SAY_NETMSG, "Unable to parse faction location param. Must be in form <faction_id>_<basename>.");
            return;
        }
    }
    if(locId == 0)
    {
        player.Say(SAY_NETMSG, "Couldn't obtain location id.");
        return;
    }
    if(show)
    {
        player.Say(SAY_NETMSG, "Showing location " + locId + " to " + target.Name);
        target.SetKnownLoc(true, locId);
    }
    else
    {
        player.Say(SAY_NETMSG, "Hiding location " + locId + " from " + target.Name);
        target.UnsetKnownLoc(true, locId);
    }
}

//
// Sets the TRANSFER timeout for safe travels
//
//
void ExecSetTimeoutCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    player.Say(SAY_NETMSG, "Executing settimeout command");

    int to = 0;
    if(command.length() == 2)
    {
        _SetTimeout(player, TO_TRANSFER, REAL_DAY(1));
        return;
    }

    if(!StrToInt(command[2], to))
    {
        player.Say(SAY_NETMSG, "Invalid arguments");
        return;
    }
    _SetTimeout(target, TO_TRANSFER, to);
}

//
// Shows the value of the local variable specified in the parameter
//
void ExecGetVarCommand(array<string@>@ command, Critter@ player, uint targetId)
{
    player.Say(SAY_NETMSG, "Executing GetVar command");

    int id = 0;
    if(command.length() < 2)
    {
        player.Say(SAY_NETMSG, "Wrong number of parameters");
        return;
    }
    // try to parse id if it was passed as number
    bool parsed = StrToInt(command[2], id);
    // otherwise, check in the global dictionary
    if(!parsed)
    {
        if(!GetVarId(command[2], id))
        {
            player.Say(SAY_NETMSG, "LVAR does not exist");
            return;
        }
    }

    // everything should be ok (id still may be bad)
    GameVar@ var = GetLocalVar(id, targetId);
    if(valid(var))
        player.Say(SAY_NETMSG, GetSafePlayerName(targetId) + "'s " + "Var value is: " + var.GetValue());
    else
        player.Say(SAY_NETMSG, "LVAR not found");
}

//
// Sets the value of the local variable specified in the parameter
//
void ExecSetVarCommand(array<string@>@ command, Critter@ player, uint targetId)
{
    player.Say(SAY_NETMSG, "Executing SetVar command");

    int id = 0;
    if(command.length() < 3)
    {
        player.Say(SAY_NETMSG, "Wrong number of parameters");
        return;
    }
    // try to parse id if it was passed as number
    bool parsed = StrToInt(command[2], id);
    // otherwise, check in the global dictionary
    if(!parsed)
    {
        if(!GetVarId(command[2], id))
        {
            player.Say(SAY_NETMSG, "LVAR does not exist");
            return;
        }
    }
    int val = 0;
    if(!StrToInt(command[3], val))
    {
        player.Say(SAY_NETMSG, "Wrong value");
        return;
    }

    // everything should be ok (id still may be bad)
    GameVar@ var = GetLocalVar(id, targetId);
    if(valid(var))
    {
        player.Say(SAY_NETMSG, GetSafePlayerName(targetId) + "'s " + "Var value is: " + var.GetValue() + ", changing to: " + val);
        var = val;
    }
    else
        player.Say(SAY_NETMSG, "LVAR not found");
}

//
// Shows the value of the specified unique variable for the critters in sight
// default master-slave: critter-player
// with switch r, player become master, critter slave
//
void ExecGetUVarCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    player.Say(SAY_NETMSG, "Executing GetUVar command");

    int id = 0;
    if(command.length() < 3)
    {
        player.Say(SAY_NETMSG, "Wrong number of parameters");
        return;
    }
    // try to parse id if it was passed as number
    bool parsed = StrToInt(command[2], id);
    // otherwise, check in the global dictionary
    if(!parsed)
    {
        if(!GetVarId(command[2], id))
        {
            player.Say(SAY_NETMSG, "UVAR does not exist");
            return;
        }
    }

    // everything should be ok
    // get critters in sight
    array<Critter@> critters;
    uint            num = target.GetCritters(false, FIND_ALL, critters);
    GameVar@        var;
    for(uint i = 0; i < num; i++)
    {
        if(GetIndexOfString(command, "-r") != -1)
            @var = GetUnicumVar(id, target.Id, critters[i].Id);
        else
            @var = GetUnicumVar(id, critters[i].Id, target.Id);

        if(valid(var))
            critters[i].Say(SAY_NORM, "Var value is: " + var.GetValue());
        else
            critters[i].Say(SAY_NORM, "UVAR null");
    }
}

//
// Sets the value of the unique variable for the critter in front of player
//
void ExecSetUVarCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    player.Say(SAY_NETMSG, "Executing SetUVar command");

    int id = 0;
    if(command.length() < 4)
    {
        player.Say(SAY_NETMSG, "Wrong number of parameters");
        return;
    }
    // try to parse id if it was passed as number
    bool parsed = StrToInt(command[2], id);
    // otherwise, check in the global dictionary
    if(!parsed)
    {
        if(!GetVarId(command[2], id))
        {
            player.Say(SAY_NETMSG, "LVAR does not exist");
            return;
        }
    }
    int val = 0;
    if(!StrToInt(command[3], val))
    {
        player.Say(SAY_NETMSG, "Wrong value");
        return;
    }

    // get critters in sight
    array<Critter@> critters;
    uint            num = target.GetCritters(false, FIND_ALL, critters);
    GameVar@        var;
    bool            set = false;
    for(uint i = 0; i < num; i++)
    {
        if(GetDistantion(target.HexX, target.HexY, critters[i].HexX, critters[i].HexY) > 1)
            continue;

        if(GetDirection(target.HexX, target.HexY, critters[i].HexX, critters[i].HexY) != target.Dir)
            continue;

        if(GetIndexOfString(command, "-r") != -1)
            @var = GetUnicumVar(id, target.Id, critters[i].Id);
        else
            @var = GetUnicumVar(id, critters[i].Id, target.Id);
        if(valid(var))
        {
            var = val;
            critters[i].Say(SAY_NORM, "Setting var value to: " + var.GetValue());
            set = true;
        }
        else
            critters[i].Say(SAY_NORM, "UVAR null");
    }
    if(!set)
        player.Say(SAY_NETMSG, "Critter should be in front of target");
}

//
// Kills the critter in front of player, without consequences
// or kills player with specified name
void ExecKillCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    player.Say(SAY_NETMSG, "Executing... critter?");

    // Try to kill a critter in front of the player
    if(command.length() < 3)
    {
        uint16 frontHexX = player.HexX;
        uint16 frontHexY = player.HexY;
        Map@   map = player.GetMap();
        if(valid(map))
        {
            map.MoveHexByDir(frontHexX, frontHexY, player.Dir, 1);
            Critter@ cr = map.GetCritter(frontHexX, frontHexY);
            if(valid(cr))
            {
                if(cr.IsPlayer())
                    _CritSetMode(cr, MODE_NO_LOOT);
                cr.ToDead(GetRandomDeathAnimation(), null);
            }
            else
                player.Say(SAY_NETMSG, "Nobody to kill.");
        }
        else
            player.Say(SAY_NETMSG, "Nobody to kill.");
    }
    else
    {
        if(command[2] == "players")
        {
            player.Say(SAY_NETMSG, "Killing all Players in sight...");
            array<Critter@> critters;
            uint            num = player.GetCritters(false, FIND_ONLY_PLAYERS | FIND_LIFE, critters);
            for(uint i = 0; i < num; i++)
            {
                _CritSetMode(target, MODE_NO_LOOT);
                critters[i].ToDead(GetRandomDeathAnimation(), null);
            }
        }
        else if(command[2] == "npcs")
        {
            player.Say(SAY_NETMSG, "Killing all NPCs in sight...");
            array<Critter@> critters;
            uint            num = player.GetCritters(false, FIND_ONLY_NPC | FIND_LIFE, critters);
            for(uint i = 0; i < num; i++)
            {
                if(_IsTrueNpc(critters[i]))
                    critters[i].ToDead(GetRandomDeathAnimation(), null);
            }
        }
        else if(command[2] == "all")
        {
            player.Say(SAY_NETMSG, "Killing all critters in sight...");
            array<Critter@> critters;
            uint            num = player.GetCritters(false, FIND_LIFE, critters);
            for(uint i = 0; i < num; i++)
            {
                if(critters[i].IsPlayer())
                    _CritSetMode(target, MODE_NO_LOOT);
                critters[i].ToDead(GetRandomDeathAnimation(), null);
            }
        }
        else
        {
            // otherwise, specified target
            if(player.Id == target.Id)
            {
                player.Say(SAY_NETMSG, "Are you crazy?");
                return;
            }

            if(valid(target))
            {
                target.Say(SAY_NETMSG, "Out of a sudden, you decided to be a little bit dead. Sleep tight.");
                if(target.IsPlayer())
                    _CritSetMode(target, MODE_NO_LOOT);
                target.ToDead(GetRandomDeathAnimation(), null);
                player.Say(SAY_NETMSG, GetSafePlayerName(target.Id) + " died a painful death. You feel quite good about it.");
            }
            else
                player.Say(SAY_NETMSG, "Player not found");
        }
    }
}


//
// Register new faction with specified id and name
//
void ExecRegisterFactionCommand(array<string@>@ command, Critter@ player)
{
    player.Say(SAY_NETMSG, "Executing RegisterFaction command");

    int id = 0;
    if(command.length() < 4)
    {
        player.Say(SAY_NETMSG, "Wrong number of parameters");
        return;
    }
    if(!StrToInt(command[2], id))
    {
        player.Say(SAY_NETMSG, "Invalid parameters");
        return;
    }
    int res = RegisterFaction(id, command[3], true);
    if(res == REGRESULT_SUCCESS)
        player.Say(SAY_NETMSG, "Faction registered");
    else
        player.Say(SAY_NETMSG, "Faction couln't be registered");
}

//
// Teleports target to some location (or target and his team)
//
void ExecTeleportCommand(array<string@>@ command, Critter@ player, Critter@ target, bool team)
{
    player.Say(SAY_NETMSG, "Teleporting");

    uint mapId = 0;
    uint entId = 0;
    int  hexX = -1, hexY = -1;
    bool toHex = false;
    if(command.length() > 2)
    {
        if(GetIndexOfString(command, "-f") == -1)
        {
            if(!StrToInt(command[2], mapId))
            {
                if(Maps.exists(command[2]))
                    Maps.get(command[2], mapId);
                else
                    mapId = 0;
            }
        }
        else     // Faction base
        {
            uint locid = 0;
            if(ParseFactionBaseLocationId(command[2], locid))
            {
                Location@ loc = GetLocation(locid);
                if(valid(loc))
                {
                    Map@ map = loc.GetMapByIndex(0);
                    if(valid(map))
                    {
                        mapId = map.Id;
                    }
                }
            }
            else
            {
                player.Say(SAY_NETMSG, "To teleport to faction base, command parameter must be in form:");
                player.Say(SAY_NETMSG, " teleport <factionId> -f (translated to <faction_id>.0)");
                player.Say(SAY_NETMSG, " teleport <factionId>.<baseNumber> -f (starting from 0)");
                player.Say(SAY_NETMSG, " teleport <factionId>.<baseName> -f (use _ instead of whitespace)");
                return;
            }
        }
    }
    if(mapId == 0)
    {
        if(target.GetMapId() != 0)
            mapId = target.GetMapId();
        else
        {
            player.Say(SAY_NETMSG, "Invalid parameters. Your current map is worldmap.");
            return;
        }
    }
    // try hexes
    StrToInt(GetParameterString(command, "-x"), hexX);
    StrToInt(GetParameterString(command, "-y"), hexY);
    if(hexX != -1 && hexY != -1)
        toHex = true;

    if(!toHex && command.length() > 3)
    {
        if(!StrToInt(command[3], entId))
            entId = 0;
    }

    if(team)
    {
        // make it so target is leader of the group our desired target belongs to(if any)
        if(valid(target.GetFollowLeader()))
            @target = @target.GetFollowLeader();

        array<Critter@> followers;
        uint            num = target.GetFollowGroup(FIND_ALL, followers);
        for(uint i = 0; i < num; i++)
        {
            if(toHex)
                followers[i].TransitToMap(mapId, hexX, hexY, followers[i].Dir);
            else
                followers[i].TransitToMap(mapId, entId);
        }
    }

    if(toHex)
    {
        if(target.TransitToMap(mapId, hexX, hexY, target.Dir))
            player.Say(SAY_NETMSG, "Teleported to location " + mapId + " at position: " + hexX + ", " + hexY);
        else
            player.Say(SAY_NETMSG, "Couldn't teleport to location " + mapId + " at position: " + hexX + ", " + hexY);
    }
    else
    {
        if(target.TransitToMap(mapId, entId))
            player.Say(SAY_NETMSG, "Teleported to location " + mapId + " at entrance: " + entId);
        else
            player.Say(SAY_NETMSG, "Couldn't teleport to location " + mapId + " at entrance: " + entId);
    }

}

/* TODO
   void ExecTeleporterCommand(array<string@>@ command, Critter@ player)
   {
        uint16 hx = player.HexX;
        uint16 hy = player.HexY;

        int dir = Random(0, 6);

    bool allowItems = false;

        bool _in = false;
        bool _out = false;

        cheatGetOption(command, _in, "-in" );
        cheatGetOption(command, _out, "-out" );

        if( !_in && !_out )
        {
                player.Say( SAY_NETMSG, "You must set -in or -out option" );
                return;
        }
        if( _in && _out )
        {
                player.Say( SAY_NETMSG, "You can't set -in and -out option at same time" );
                return;
        }

        Critter@ link;
        if( _in )
        {
                uint linkId = 0;
                string[] __in = { "-in" };
                if( !StrToInt( GetParameterString( command, __in ), linkId ))
                {
                        player.Say(SAY_NETMSG, "No link set. Use -in <outTeleporterId>");
                        return;
                }

                @link = GetCritter( linkId );
                if( !valid(link) )
                {
                        player.Say(SAY_NETMSG, "Invalid link<"+linkId+"> set (target invalid) Use -in <outTeleporterId>");
                        return;
                }

                if( link.Param[ST_DIALOG_ID] != ETP_DIALOG )
                {
                        player.Say(SAY_NETMSG, "Invalid link<"+linkId+"> set (target has wrong dialog) . Use -in <outTeleporterId>");
                        return;
                }

                if( !FLAG( link.Param[ETP_FLAGS], ETP_MODE_OUT ))
                {
                        player.Say(SAY_NETMSG, "Invalid link<"+linkId+"> set (target isn't in OUT mode). Use -in <outTeleporterId>");
                        return;
                }

                if( link.Param[ETP_LINK] != 0 )
                {
                        player.Say(SAY_NETMSG, "Invalid link<"+linkId+"> set (target is linked to <"+link.Param[ETP_LINK]+">). Use -in <outTeleporterId>");
                        return;
                }
        }

        cheatGetOption(command, hx, "-x");
    cheatGetOption(command, hy, "-y");
        cheatGetOption(command, dir, "-dir");
        dir=dir%6;

        Map@ map=player.GetMap();
        if(!valid(map))
        {
                player.Say(SAY_NETMSG, "You are not on valid map.");
                return;
        }

        SpawnEventTeleporter( player, link, map, hx, hy, dir, "Another Bad, Unbalanced, Silly Event" );
   }
 */

#define WT_NO_ITEMS        (0x01)
#define WT_DELETE_ITEMS    (0x02)
#define WT_NO_FOLLOWERS    (0x04)
void ExecTeleporterCommand(array<string@>@ command, Critter@ player)
{
    uint16 hx = player.HexX;
    uint16 hy = player.HexY;

    uint16 tx = 0;
    uint16 ty = 0;

    uint   mapId  = 0;

    int    dir = Random(0, 6);

    bool   allowItems = false;

    cheatGetOption(command, hx, "-x");
    cheatGetOption(command, hy, "-y");
    cheatGetOption(command, tx, "-tx");
    cheatGetOption(command, ty, "-ty");
    cheatGetOption(command, mapId, "-map");
    cheatGetOption(command, allowItems, "-it");
    cheatGetOption(command, dir, "-dir");
    dir = dir % 6;

    if(mapId == 0)
    {
        player.Say(SAY_NETMSG, "No Map ID given. Use -map <mapId>");
        return;
    }

    if(tx == 0 || ty == 0)
    {
        player.Say(SAY_NETMSG, "No destination coordinates given. Use -tx <X> and -ty <Y>");
        return;
    }

    Map@ map = player.GetMap();
    if(!valid(map))
    {
        player.Say(SAY_NETMSG, "You are not on valid map.");
        return;
    }

    uint     pid = 319;
    uint     dialogId = 10810;
    Critter@ npc = AddNpc(map, pid, hx, hy, dir,
                          dialogId, "", 0, 0, 0, 0, 0, false, 9999);

    if(!valid(npc))
    {
        player.Say(SAY_NETMSG, "Failed to create teleporter npc.");
        return;
    }
    int teleportPolicy = 0;
    SETFLAG(teleportPolicy, WT_NO_FOLLOWERS);
    if(!allowItems)
        SETFLAG(teleportPolicy, WT_NO_ITEMS);
    SetLvar(npc, LVAR_warzone_terminal_policy, teleportPolicy);
    SetLvar(npc, LVAR_warzone_terminal_destination, mapId);
    npc.ParamBase[ST_VAR1] = (((ty << 16) & 0xFFFF0000) | (tx & 0x0000FFFF));
    npc.SpawnedBy = player.Id;
}


//
// Shifts player (and his team) few hexes in the specific direction
//
void ExecShiftCommand(array<string@>@ command, Critter@ player, Critter@ target, bool team, bool random)
{
    player.Say(SAY_NETMSG, "Shifting");
    // hexes
    uint16 hexX, hexY;
    uint   amount = 2;

    if(command.length() > 2)
    {
        StrToInt(command[2], amount);
    }

    hexX = target.HexX;
    hexY = target.HexY;
    // calc target hexes
    if(random)
    {
        hexX += Random(-20, 20);
        hexY += Random(-20, 20);
    }
    else
        player.GetMap().MoveHexByDir(hexX, hexY, target.Dir, amount);

    if(team)
    {
        // make it so target is leader of the group our desired target belongs to(if any)
        if(valid(target.GetFollowLeader()))
            @target = @target.GetFollowLeader();
        hexX = target.HexX;
        hexY = target.HexY;
        // calc  target hexes
        if(random)
        {
            hexX += Random(-20, 20);
            hexY += Random(-20, 20);
        }
        else
            player.GetMap().MoveHexByDir(hexX, hexY, target.Dir, amount);

        array<Critter@> followers;
        uint            num = target.GetFollowGroup(FIND_ALL, followers);
        for(uint i = 0; i < num; i++)
            followers[i].TransitToHex(hexX, hexY, 0xff);
    }
    bool res = target.TransitToHex(hexX, hexY, 0xff);
    if(res)
        player.Say(SAY_NETMSG, "Shifted!");
    else
        player.Say(SAY_NETMSG, "Tsk, tsk");
}

//
// Summons target (and his team) near the player (summoner)
//
// helper
bool Teleport(Critter@ player, Critter@ target, bool Safe)
{
    int ModX = 0;
    int ModY = 0;
    if(Safe)
    {
        (Random(0, 1) == 0 ? ModX = 1 : ModX = -1);
        ModY = ModX;
        ModX *= Random(2, 10);
        ModY *= Random(2, 10);
    }

    if(player.GetMapId() == target.GetMapId() && player.GetMapId() != 0)
        return player.TransitToHex(target.HexX + ModX, target.HexY + ModY, 0xff);
    else if(target.GetMapId() != 0)
        return player.TransitToMap(target.GetMapId(), target.HexX + ModX, target.HexY + ModY, 0xff);
    else
    {
        // if player already on global
        if(player.GetMapId() == 0)
            player.TransitToMap(1, 0);
        return player.TransitToGlobalGroup(target.Id);
    }
}

void ExecSummonCommand(array<string@>@ command, Critter@ player, Critter@ target, bool team)
{
    if(WrathOfTheGod(target))
        @target = player;

    if(team)
        player.Say(SAY_NETMSG, "Summoning team");
    else
        player.Say(SAY_NETMSG, "Summoning");

    if(player.Id == target.Id)
    {
        player.Say(SAY_NETMSG, "Wrong target.");
        return;
    }
    // map id
    uint id = player.GetMapId();

    if(team)
    {
        // make it so target is leader of the group our desired target belongs to(if any)
        if(valid(target.GetFollowLeader()))
            @target = @target.GetFollowLeader();
    }
    // remember previous location
    target.StatBase[ST_VAR7] = target.GetMapId();
    target.StatBase[ST_VAR8] = target.HexX;
    target.StatBase[ST_VAR9] = target.HexY;

    uint num = 0;

    if(team)
    {
        array<Critter@> followers;
        num = target.GetFollowGroup(FIND_ALL, followers);
        for(uint i = 0; i < num; i++)
        {
            // remember previous location
            followers[i].StatBase[ST_VAR7] = followers[i].GetMapId();
            followers[i].StatBase[ST_VAR8] = followers[i].HexX;
            followers[i].StatBase[ST_VAR9] = followers[i].HexY;
            if(Teleport(followers[i], player, false))
                num++;
        }
    }
    // teleport
    if(Teleport(target, player, false))
        num++;
    player.Say(SAY_NETMSG, num + " players summoned");
}

//
// returns target (and his team) to location from which they were summoned
//
void ExecDismissCommand(array<string@>@ command, Critter@ player, Critter@ target, bool team)
{
    if(WrathOfTheGod(target))
        @target = player;

    if(team)
        player.Say(SAY_NETMSG, "Dismissing team");
    else
        player.Say(SAY_NETMSG, "Dismissing");

    if(player.Id == target.Id)
    {
        player.Say(SAY_NETMSG, "Wrong target.");
        return;
    }

    if(team)
    {
        // make it so target is leader of the group our desired target belongs to(if any)
        if(valid(target.GetFollowLeader()))
        {
            @target = @target.GetFollowLeader();
            DPlayerLog(player, "Group leader: " + GetSafePlayerName(target.Id));
        }
    }

    if(team)
    {
        array<Critter@> followers;
        uint            num = target.GetFollowGroup(FIND_ALL, followers);
        DPlayerLog(player, "Num followers: " + num);
        for(uint i = 0; i < num; i++)
        {
            if(followers[i].Stat[ST_VAR7] != target.Stat[ST_VAR7])
            {
                DPlayerLog(player, GetSafePlayerName(followers[i].Id) + " wasn't in team during summoning");
                followers[i].TransitToMap(target.Stat[ST_VAR7], target.Stat[ST_VAR8], target.Stat[ST_VAR9], 0xff);
            }
            else
                // in most cases(or in all cases), this will go to the same map as above
                followers[i].TransitToMap(followers[i].Stat[ST_VAR7], followers[i].Stat[ST_VAR8], followers[i].Stat[ST_VAR9], 0xff);
        }
    }
    // teleport
    target.TransitToMap(target.Stat[ST_VAR7], target.Stat[ST_VAR8], target.Stat[ST_VAR9], 0xff);
    player.Say(SAY_NETMSG, "Dismissed");
}

/**
 * Teleports to given target critter.
 */
void ExecGoToCommand(array<string@>@ command, Critter@ player, Critter@ target, bool team)
{
    if(WrathOfTheGod(target))
        @target = player;

    if(team)
        player.Say(SAY_NETMSG, "Going to with team...");
    else
        player.Say(SAY_NETMSG, "Going to...");

    bool  Safe = (GetIndexOfString(command, "-s") != -1);

    int   ItemId = 0;
    StrToInt(GetParameterString(command, "-i"), ItemId);
    Item@ It = ItemId > 0 ? GetItem(ItemId) : null;
    if(ItemId > 0)
    {
        if(valid(It))
        {
            if(It.Accessory == ACCESSORY_CRITTER)
            {
                Critter@ ItCritter = GetCritter(It.CritId);
                @target = ItCritter;
                string@  carrier = GetSafePlayerName(It.CritId);
                player.Say(SAY_NETMSG, "Item is carried by critter " + It.CritId +
                           (valid(carrier) ? " (" + carrier + ")" : ""));
            }
            else
            {
                @target = null;
                if(player.GetMapId() == It.MapId && player.GetMapId() != 0)
                    player.TransitToHex(It.HexX, It.HexY, 0xff);
                else if(It.MapId != 0)
                    player.TransitToMap(It.MapId, It.HexX, It.HexY, 0xff);
            }
        }
        else
        {
            player.Say(SAY_NETMSG, "Item not valid");
            return;
        }
    }

    if((!valid(target) && !valid(It)) || (valid(target) && target.Id == player.Id))
    {
        player.Say(SAY_NETMSG, "Target not valid");
        return;
    }

    if(target.GetMapId() == 0 && (GetIndexOfString(command, "-f") == -1))
    {
        player.Say(SAY_NETMSG, "Target is on the worldmap. Use -f to go there anyway.");
        return;
    }

    uint num = 0;
    // teleport
    if(valid(target))
    {
        if(Teleport(player, target, Safe))
            num++;
    }
    if(team)
    {
        array<Critter@> followers;
        num = player.GetFollowGroup(FIND_ALL, followers);
        for(uint i = 0; i < num; i++)
        {
            if(Teleport(followers[i], player, false))
                num++;
        }
    }
    if(valid(target))
        player.Say(SAY_NETMSG, num + " players teleported to " + target.Name + " (" + target.GetMapId() + ")");
    else if(valid(It))
        player.Say(SAY_NETMSG, num + " players teleported to item " + It.Id + " (" + It.MapId + ")");
}

void ExecDamageCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    uint val = 0;

    int  damagetype = DAMAGE_NORMAL;
    if(GetParameterString(command, "-t") != "")
        StrToInt(GetParameterString(command, "-t"), damagetype);

    int direction = Random(0, 6);
    if(GetParameterString(command, "-dir") != "")
        StrToInt(GetParameterString(command, "-dir"), direction);

    int owner = 0;
    StrToInt(GetParameterString(command, "-o"), owner);

    int damage = 0;
    StrToInt(GetParameterString(command, "-d"), damage);

    InjureCritter(target, damage, damagetype, direction, owner);
}

void ExecSlapCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    player.Say(SAY_NETMSG, "Slap that bitch up!");

    if(GodOfTheRealm(target.Id) && !GodOfTheRealm(player.Id))
        @target = player;

    uint damagetype = DAMAGE_NORMAL;

    if(GetParameterString(command, "-t") != "")
        StrToInt(GetParameterString(command, "-t"), damagetype);
    uint lostAp = 0;
    StrToInt(GetParameterString(command, "-a"), lostAp);

    // int direction = Random(0, 6);
    // if (GetParameterString(command, "-dir") != "")
    //    StrToInt(GetParameterString(command, "-dir"), direction);

    target.ToKnockout(KNOCKOUT_ANIM2_DEFAULT(Random(0, 1) == 0), lostAp, target.HexX, target.HexY);

    if(GodOfTheRealm(target.Id))
        target.Say(SAY_NETMSG, "You've been slapped by " + player.Name);
}
void ExecMassSlapCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    player.Say(SAY_NETMSG, "Down on your knees faggots!");

    uint lostAp = 0;
    StrToInt(GetParameterString(command, "-a"), lostAp);
    int  r = 0;
    StrToInt(GetParameterString(command, "-r"), r);

    array<Critter@> crits;
    uint            num = player.GetCritters(false, FIND_ALL, crits);
    for(uint i = 0; i < num; i++)
    {
        if(!crits[i].IsDead() && !GodOfTheRealm(crits[i].Id))
            crits[i].ToKnockout(KNOCKOUT_ANIM2_DEFAULT(Random(0, 1) == 0), lostAp, crits[i].HexX + Random(-r, r), crits[i].HexY + Random(-r, r));
    }
}

void ExecSetHPCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    int hp = 0;
    GetParameterString(command, "-h");

    if(valid(target))
        _CritChangeHp(target, hp);
    else
        _CritChangeHp(player, hp);
}

void ExecExplodeCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    if(player.Id == target.Id)
    {
        player.Say(SAY_NETMSG, "You dont't want this.");
        return;
    }
    if(!valid(target))
    {
        player.Say(SAY_NETMSG, "Invalid player");
        return;
    }
    uint16 effectPid = PID_EXPLODE_ROCKET;
    uint   effectRadius = 2;
    uint   damage = Random(300, 400);
    uint   damageType = DAMAGE_EXPLODE;
    uint   damageRadius = 3;

    ExplodeEx(target.GetMap(), target.HexX, target.HexY, effectPid, effectRadius, damage, damageType, damageRadius, 0, 0);
    // Explode(target.GetMap(), target.HexX, target.HexY, PID_PLASTIC_EXPLOSIVES, 0);
}

void ExecAirstrikeCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    if(player.Id == target.Id)
    {
        player.Say(SAY_NETMSG, "You dont't want this.");
        return;
    }
    if(!valid(target))
    {
        player.Say(SAY_NETMSG, "Invalid player");
        return;
    }

    player.Say(SAY_NETMSG, "Airstrike target confirmed. Dropping the payload now.");

    int    amount = 0;

    uint16 effectPid = PID_EXPLODE_ROCKET;
    uint   effectRadius = 2;
    uint   damage = Random(1000, 5000);
    uint   damageType = DAMAGE_EXPLODE;
    uint   damageRadius = 3;

    for(int i = 0; i < 20; i++)
        ExplodeEx(target.GetMap(), target.HexX + Random(-10, 10), target.HexY + Random(-10, 10), effectPid, effectRadius, damage, damageType, damageRadius, 0, 0);
}

void ExecAltsCommand(array<string@>@ command, Critter@ player)
{
    uint optLocation = 0;
    cheatGetOption(command, optLocation, "-l");

    bool optOffline = false;
    cheatGetOption(command, optOffline, "-o");

    array<Critter@> players;
    uint            num = GetAllOnlinePlayers(players);
    uint            totalNum = 0;

    array<uint>     checkedIp;             // Already checked IPs
    bool            nothingFound = true;   // No alts found

    if(optLocation == 0)
        player.Say(SAY_NETMSG, "Possible multilogs:");
    else
        player.Say(SAY_NETMSG, "Possible multilogs in location " + optLocation + ":");

    for(uint p = 0, q = num; p < q; p++)
    {
        if(optLocation > 0)
        {
            Map@ map = players[p].GetMap();
            if(valid(map))
            {
                Location@ loc = map.GetLocation();
                if(loc.Id != optLocation)
                    continue;
            }
            else
                continue;
        }

        totalNum += 1;

        uint ip = players[p].GetIp();
        bool checkAlts = true;
        for(uint i = 0, j = checkedIp.length; i < j; i++)
        {
            if(ip == checkedIp[i])     // This IP was already checked
            {
                checkAlts = false;
                break;
            }
        }
        if(checkAlts)
        {
            checkedIp.insertLast(ip);
            bool foundAlts = false;
            for(uint i = p + 1; i < num; i++)
            {
                if(optLocation > 0)
                {
                    Map@ map = players[i].GetMap();
                    if(valid(map))
                    {
                        Location@ loc = map.GetLocation();
                        if(loc.Id != optLocation)
                            continue;
                    }
                    else
                        continue;
                }

                if(!optOffline && _IsOffline(players[i]))
                    continue;

                if(players[i].GetIp() == ip)
                {
                    if(!foundAlts)
                    {
                        foundAlts = true;
                        player.Say(SAY_NETMSG, "|0x009900 IP: " + IpToString(ip));
                        if(_IsOffline(players[p]))
                            player.Say(SAY_NETMSG, "|0x999999     " + players[p].Name + " (" + players[p].Id + ") in map " + players[p].GetMapId() + " [off]");
                        else
                            player.Say(SAY_NETMSG, "    " + players[p].Name + " (" + players[p].Id + ") in map " + players[p].GetMapId());
                    }
                    if(_IsOffline(players[i]))
                        player.Say(SAY_NETMSG, "|0x999999     " + players[i].Name + " (" + players[i].Id + ") in map " + players[i].GetMapId() + " [off]");
                    else
                        player.Say(SAY_NETMSG, "    " + players[i].Name + " (" + players[i].Id + ") in map " + players[i].GetMapId());
                    nothingFound = false;
                }
            }
        }
    }
    if(nothingFound)
        player.Say(SAY_NETMSG, "    None.");

    player.Say(SAY_NETMSG, "Number of characters: " + totalNum);
    if(totalNum > 0)
    {
        player.Say(SAY_NETMSG, "Number of unique IPs: " + checkedIp.length() + " (" + ((checkedIp.length() * 100) / totalNum) + "%)");
    }

}

void ExecListPlayersCommand(array<string@>@ command, Critter@ player)
{
    array<Critter@> players;
    uint            num = GetAllOnlinePlayers(players);

    for(uint i = 0; i < num; i++)
    {
        if(!valid(players[i]))
            continue;

        if(WrathOfTheGod(players[i]))
            continue;

        if((GetIndexOfString(command, "-f") != -1) && (players[i].GetMapId() == 0))
            continue;

        player.Say(SAY_NETMSG, GetSafePlayerName(players[i].Id) + " (" + players[i].Id + ")" + "(" + players[i].GetMapId() + ")" + "(" + GetPlayerFaction(players[i].Id) + ")");
    }
}

void ExecCritterInfoCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    if(!valid(target))
        return;

    if(WrathOfTheGod(target))
        @target = player;

    string what = "\n";
    if(target.IsPlayer())
        what += "PLAYER " + GetSafePlayerName(target.Id);
    else
        what += "NPC |dlgName" + target.Id + "|";
    // more details here?

    GameVar@ var = null;

    player.Say(SAY_NETMSG, what + " (" + target.Id + ")" + ":");

    player.Say(SAY_NETMSG, "Map ID: " + target.GetMapId());

    player.Say(SAY_NETMSG, "Map Position: " + "x:" + target.HexX + " y:" + target.HexY);

    if(target.IsNpc())
    {
        uint   mapId = 0;
        uint16 hexX = 0, hexY = 0;
        uint8  dir = 0;

        target.GetHomePos(mapId, hexX, hexY, dir);

        player.Say(SAY_NETMSG, "Home Position: (" + mapId + ") " + hexX + "," + hexY + "," + dir);
    }

    player.Say(SAY_NETMSG, "Worldmap position: " + "x:" + target.WorldX + " y:" + target.WorldY);

    if(target.IsNpc() && target.Param[ST_DIALOG_ID] > 0)
        player.Say(SAY_NETMSG, "Dialog: " + target.Param[ST_DIALOG_ID]);

    player.Say(SAY_NETMSG, "Level: " + target.Stat[ST_LEVEL]);

    player.Say(SAY_NETMSG, "SPECIAL:" +
               " ST:" + target.Stat[ST_STRENGTH] +
               " PE:" + target.Stat[ST_PERCEPTION] +
               " EN:" + target.Stat[ST_ENDURANCE] +
               " CH:" + target.Stat[ST_CHARISMA] +
               " IN:" + target.Stat[ST_INTELLECT] +
               " AG:" + target.Stat[ST_AGILITY] +
               " LK:" + target.Stat[ST_LUCK]
               );
    array<string> tag;
    for(uint t = TAG_BEGIN; t <= TAG_END; t++)
    {
        string skill = SkillName(target.Param[t]);
        if(skill.length() > 0)
            tag.insertLast(skill);
        else if(target.Param[t] != 0)
            tag.insertLast("UNKNOWN(" + target.Param[t] + ")");
    }

    if(tag.length() > 0)
    {
        string tagList = "Tag: ";
        tag.sortAsc();
        for(uint t = 0; t < tag.length; t++)
        {
            if(t != 0)
                tagList += ", ";
            tagList += tag[t];
        }
        player.Say(SAY_NETMSG, tagList);
    }

    @var = GetLocalVar(LVAR_factions_player_faction, target.Id);
    if(valid(var))
    {
        int fid = var.GetValue();
        int rank = 0;
        @var = GetLocalVar(LVAR_factions_player_rank, target.Id);
        if(valid(var))
            rank = var.GetValue();
        if(fid > 1 && FactionExists(fid))
        {
            string[] ranks_player =  { "UNKNOWN", "Rookie",   "Accepted",   "Trusted",    "Important", "Leader" };
            string[] ranks_bos =     { "UNKNOWN", "Initiate", "Apprentice", "Senior",     "Elder",     "LEADER" };
            string[] ranks_enclave = { "UNKNOWN", "Boot",     "Trooper",    "Sergeant",   "Officer",   "LEADER" };
            string[] ranks_unity =   { "UNKNOWN", "Initiate", "Child",      "Priest",     "Elder",     "LEADER" };
            string[] ranks_ncr =     { "UNKNOWN", "Democrat", "Citizen",    "Magistrate", "Marshal",   "LEADER" };
            string[] ranks_vc =      { "UNKNOWN", "Admitted", "Citizen",    "Regulator",  "Proconsul", "LEADER" };
            array<string> ranks = ranks_player;
            switch(fid)
            {
            case FACTION_BOS:
                ranks = ranks_bos;
                break;
            case FACTION_ENCLAVE:
                ranks = ranks_enclave;
                break;
            case FACTION_UNITY:
                ranks = ranks_unity;
                break;
            case FACTION_NCR:
                ranks = ranks_ncr;
                break;
            case FACTION_VAULT_CITY:
                ranks = ranks_vc;
                break;
            }

            if(FACTION_VALID(fid))
                player.Say(SAY_NETMSG, "Faction: " + GetFaction(fid).get_Name() + " (" + fid + ")");
            else
                player.Say(SAY_NETMSG, "INVALID FACTION <" + fid + ">");
            if(RANK_VALID(rank) && rank >= 0)
                player.Say(SAY_NETMSG, "Rank: " + ranks[rank] + " (" + rank + ")");
            else
                player.Say(SAY_NETMSG, "INVALID RANK <" + rank + ">");
        }

    }

    // if(target.IsNpc()) -- don't! maybe NPCs will get tents too some day
    @var = GetLocalVar(LVAR_tent_id, target.Id);
    if(valid(var))
    {
        int locId = var.GetValue();
        if(locId > 0)
        {
            Location@ loc = GetLocation(locId);
            if(valid(loc))
            {
                Map@ map = loc.GetMapByIndex(0);
                if(valid(map))
                {
                    player.Say(SAY_NETMSG,
                               "Tent map: " + map.Id + " (" + ZONE_X(loc.WorldX) + ":" + ZONE_Y(loc.WorldY) +
                               ", " + loc.WorldX + "," + loc.WorldY + ")"
                               );
                }
            }
        }
    }

    if(_IsFollower(target))
        player.Say(SAY_NETMSG, "Master: " + GetSafePlayerName(target.FollowerVar[FV_MASTER]) + " (" + target.FollowerVar[FV_MASTER] + ")");

    Critter@ leader = target.GetFollowLeader();
    if(valid(leader))
        player.Say(SAY_NETMSG, "Following: " + GetSafePlayerName(leader.Id) + " (" + leader.Id + ")");

    if(target.IsNpc() && target.SpawnedBy > 0)
        player.Say(SAY_NETMSG, "Spawned by: " + GetSafePlayerName(target.SpawnedBy));

    if(target.DisguisedBy > 0 && target.DisguisedBy != target.Id)
        player.Say(SAY_NETMSG, "Disguised by: " + GetSafePlayerName(target.DisguisedBy));

    bool achievementText = true;
    for(uint8 a = ACHIEVEMENT_MIN; a <= ACHIEVEMENT_MAX; a++)
    {
        if(HaveAchievement(target, a))
        {
            if(achievementText)
            {
                player.Say(SAY_NETMSG, "Achievements:");
                achievementText = false;
            }
            player.SayMsg(SAY_NETMSG, TEXTMSG_TEXT, ACHIEVEMENT_MSG_TITLE(a));
        }
    }
}

void ExecZeroExtCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    if(!valid(target))
        return;
    if(!target.IsPlayer())
        return;

    for(uint i = STAT_EXT_BEGIN; i <= STAT_EXT_END; i++)
        target.StatBase[i] = 0;
}
//
//
//
void ExecGodCommand(array<string@>@ command, Critter@ player)
{
    player.Say(SAY_NETMSG, "Praise");

    for(uint i = ST_STRENGTH; i <= ST_LUCK; i++)
        player.StatBase[i] = 10;
    player.SkillBase[SK_SMALL_GUNS] = player.SkillBase[SK_BIG_GUNS] = player.SkillBase[SK_ENERGY_WEAPONS] =
                                                                          player.SkillBase[SK_UNARMED] = player.SkillBase[SK_MELEE_WEAPONS] = player.SkillBase[SK_THROWING] =
                                                                                                                                                  player.SkillBase[SK_FIRST_AID] = player.SkillBase[SK_DOCTOR] = player.SkillBase[SK_SNEAK] = player.SkillBase[SK_LOCKPICK] = player.SkillBase[SK_STEAL] =
                                                                                                                                                                                                                                                                                  player.SkillBase[SK_TRAPS] = player.SkillBase[SK_SCIENCE] = player.SkillBase[SK_REPAIR] = player.SkillBase[SK_SPEECH] = player.SkillBase[SK_BARTER] =
                                                                                                                                                                                                                                                                                                                                                                                                              player.SkillBase[SK_GAMBLING] = player.SkillBase[SK_OUTDOORSMAN] = 300;

    player.StatBase[ST_ACTION_POINTS] = 80;

    player.StatBase[ST_CRITICAL_CHANCE] = 100;

    // and even more!
    player.ModeBase[MODE_INVULNERABLE] = 1;
}
void ExecIDKFACommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    player.Say(SAY_NETMSG, "IDDQD, IDKFA and send me to hell!");

    Item@ item = target.AddItem(PID_END_BOSS_PLASMA_GUN, 1);
    player.MoveItem(item.Id, 1, SLOT_HAND1);
    player.AddItem(PID_MICRO_FUSION_CELL, 500);
}

void ExecCleanupCommand(array<string@>@ command, Critter@ player)
{
    array<Critter@> crits;
    uint            num = player.GetCritters(false, FIND_ALL, crits);
    uint            count = 0;

    for(uint i = 0; i < num; i++)
    {
        if(crits[i].Cond == COND_DEAD)
        {
            if(crits[i].IsPlayer())
                continue;
            else
            {
                DeleteNpc(crits[i]);
                count++;
            }
        }
    }

    player.Say(SAY_NETMSG, count + " critters sucessfully removed.");
}

//
// Controling npcs
//
bool ControlNpc(Critter& npc, string& cmd, Critter& target, Critter& player, bool setHome)
{
    if(cmd == "move" || cmd == "run")
    {
        if(setHome)
            npc.SetHomePos(target.HexX, target.HexY, target.Dir);
        return AddWalkPlane(npc, 0, target.HexX, target.HexY, Random(0, 5), (cmd == "move") ? false : true, 0);
    }
    else if(cmd == "attack")
        return AttackCritter(npc, target);
    else if(cmd == "kill")
        return AttackCritter(npc, target);
    else if(cmd == "stop")
        return npc.ErasePlane(-1, true) > 0 ? true : false;
    else if(cmd == "halt")
        return npc.ErasePlane(AI_PLANE_WALK, true) > 0 ? true : false;
    return false;
}

//
// Controling npc
//
void ExecControlNpcCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    player.Say(SAY_NETMSG, "Controling npc...");

    string npcTarget = GetParameterString(command, "-t");
    string cmd = GetParameterString(command, "-c");
    bool   setHome = false;
    if(GetIndexOfString(command, "-h") != -1)
        setHome = true;

    if(cmd == "" || !valid(npcTarget))
    {
        player.Say(SAY_NETMSG, "Incorrect parameters");
        return;
    }
    uint npcId = 0;
    StrToInt(npcTarget, npcId);

    Critter@ npc = GetCritter(NPC_ID(npcId));
    if(!valid(npc))
    {
        player.Say(SAY_NETMSG, "Couldn't obtain npc target");
        return;
    }
    if(ControlNpc(npc, cmd, target, player, setHome))
        player.Say(SAY_NETMSG, "OK");
    else
        player.Say(SAY_NETMSG, "Fail");
}

//
// Controling all npcs in sight
//
void ExecControlMobsCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    player.Say(SAY_NETMSG, "Controlling mobs");

    array<Critter@> crits;
    uint            num = player.GetCritters(false, FIND_ALL, crits);

    string          cmd = GetParameterString(command, "-c");
    bool            setHome = false;
    if(GetIndexOfString(command, "-h") != -1)
        setHome = true;

    if((cmd == "") || (!valid(target)))
        return;

    for(uint i = 0; i < num; i++)
    {
        if(crits[i].IsPlayer())
            continue;

        ControlNpc(crits[i], cmd, target, player, setHome);
    }
}

void ExecDeathmatchCommand(array<string@>@ command, Critter@ player)
{
    array<Critter@> crits;
    // Critter@[] alive;
    uint            num = player.GetCritters(false, FIND_LIFE_AND_KO, crits);

    /*for(uint z = 0; z < num; z++)
       {
        if(crits[z].Cond != COND_DEAD)
            alive.insertLast( crits[z] );
       }*/

    for(uint i = 0; i < num; i++)
    {
        if(crits[i].IsDead())
            continue;

        if(crits[i].IsPlayer())
            continue;

        for(uint y = Random(0, num); y < num; y++)
        {
            if(!crits[y].IsDead())
                AddAttackPlane(crits[i], 0, crits[y], -6);
        }
    }
}

//
// Sends debug message to nearby npcs
//
void ExecInspectCommand(array<string@>@ command, Critter@ player)
{
    player.Say(SAY_NETMSG, "Inspecting...");
    // get critters in sight
    array<Critter@> critters;
    uint            num = player.GetCritters(false, FIND_ALL, critters);

    for(uint i = 0; i < num; i++)
    {
        critters[i].Say(SAY_NORM_ON_HEAD, "Hp: " + critters[i].Stat[ST_CURRENT_HP] /*GetStat(ST_MAX_LIFE)*/);
    }
    int val = 0;
    if(command.length() > 2)
        StrToInt(command[2], val);

    player.SendMessage(MSG_DEBUG, val, MESSAGE_TO_IAM_VISIBLE);
}

//
// Xp reward
//
void ExecXpCommand(array<string@>@ command, Critter& player, Critter@ target, bool team)
{
    if(team)
        player.Say(SAY_NETMSG, "Rewarding team " + GetSafePlayerName(target.Id) + " belongs to.");
    else
    {
        if(target.Id == player.Id)
            player.Say(SAY_NETMSG, "Rewarding myself...");
        else
            player.Say(SAY_NETMSG, "Rewarding " + GetSafePlayerName(target.Id));
    }

    uint amount = 1000;
    StrToInt(GetParameterString(command, "-a"), amount);

    string          msg = GetParameterString(command, "-m");

    array<Critter@> followers;
    uint            num = 0;

    if(team)
    {
        // make it so target is leader of the group our desired target belongs to(if any)
        if(valid(target.GetFollowLeader()))
            @target = @target.GetFollowLeader();

        num = target.GetFollowGroup(FIND_ALL, followers);
    }
    followers.insertLast(target);
    num++;
    // credit stuff
    if(GM_IsGameMaster(player.Id))
    {
        uint cr = GM_GetCredit(player.Id);
        if(amount * num > cr)
        {
            player.Say(SAY_NETMSG, "Not enough credit points");
            player.Say(SAY_NETMSG, "Required: " + amount * num + ", you have: " + cr);
            return;
        }
        else
            GM_DeduceCredit(player.Id, amount * num);
    }
    for(uint i = 0; i < num; i++)
    {
        if(msg != "")
            followers[i].Say(SAY_NETMSG, msg);
        followers[i].StatBase[ST_EXPERIENCE] += amount;
        LogExperience(followers[i], amount, "Cheat");
    }
}

//
// Karma modification
//
void ExecKarmaCommand(array<string@>@ command, Critter& player, Critter@ target, bool team)
{
    if(team)
        player.Say(SAY_NETMSG, "Karming team " + GetSafePlayerName(target.Id) + " belongs to.");
    else
    {
        if(target.Id == player.Id)
            player.Say(SAY_NETMSG, "Karming myself...");
        else
            player.Say(SAY_NETMSG, "Karming " + GetSafePlayerName(target.Id));
    }

    uint amount = 10;
    StrToInt(GetParameterString(command, "-a"), amount);

    string          msg = GetParameterString(command, "-m");

    array<Critter@> followers;
    uint            num = 0;
    if(team)
    {
        // make it so target is leader of the group our desired target belongs to(if any)
        if(valid(target.GetFollowLeader()))
            @target = @target.GetFollowLeader();
        num = target.GetFollowGroup(FIND_ALL, followers);
    }
    followers.insertLast(target);
    num++;
    // credit stuff
    if(GM_IsGameMaster(player.Id))
    {
        uint cr = GM_GetCredit(player.Id);
        if(amount * num > cr)
        {
            player.Say(SAY_NETMSG, "Not enough credit points");
            player.Say(SAY_NETMSG, "Required: " + amount * num + ", you have: " + cr);
            return;
        }
        else
            GM_DeduceCredit(player.Id, amount * num);
    }

    for(uint i = 0; i < num; i++)
    {
        if(msg != "")
            followers[i].Say(SAY_NETMSG, msg);
        followers[i].StatBase[ST_KARMA] += amount;
    }
}

void ExecPlayerKarmaCommand(array<string@>@ command, Critter& player, Critter@ target, bool team)
{
    uint amount = 10;
    StrToInt(GetParameterString(command, "-a"), amount);

    string msg = GetParameterString(command, "-m");

    if(target.Id == player.Id)
    {
        player.Say(SAY_NETMSG, "Karming myself...");
        player.StatBase[ST_PLAYER_KARMA] = amount;
    }
    else
    {
        player.Say(SAY_NETMSG, "Karming " + GetSafePlayerName(target.Id));

        target.StatBase[ST_PLAYER_KARMA] = amount;
        if(msg != "")
            target.Say(SAY_NETMSG, msg);
    }
}

//
// Radiation
//
void ExecIrradiateCommand(array<string@>@ command, Critter& player, Critter@ target)
{
    if(target.Id == player.Id)
        player.Say(SAY_NETMSG, "Irradiating myself...");
    else
        player.Say(SAY_NETMSG, "Irradiating " + GetSafePlayerName(target.Id));

    uint amount = 0;
    StrToInt(GetParameterString(command, "-a"), amount);

    if(amount != 0)
        AffectRadiation(target, amount);
    else
        player.Say(SAY_NETMSG, "RadiationLevel: " + target.Stat[ST_RADIATION_LEVEL]);
}

//
// list factions
//
void ExecFactionInfoCommand(array<string@>@ command, Critter& player, Critter@ target, bool all)
{
    int id = -1;
    if(command[1] == "factioninfo")
    {
        if(valid(target) && target.Id != player.Id)
        {
            if(target.Param[ST_TEAM_ID] >= 2)
                id = target.Param[ST_TEAM_ID];
            else
            {
                player.Say(SAY_NETMSG, target.Name + "(" + target.Id + ") doesn't belong to any faction.");
                return;
            }
        }
        else if(!StrToInt(GetParameterString(command, "-f"), id))
        {
            player.Say(SAY_NETMSG, "You must specify faction id.");
            return;
        }
    }

    bool fullLog = false;
    if(GetIndexOfString(command, "-full") != -1)
        fullLog = true;

    uint begin = 2;
    uint end = FACTION_COUNT;
    if(command[1] == "listfactions")
    {
        StrToInt(GetParameterString(command, "-b"), begin);
        StrToInt(GetParameterString(command, "-e"), end);
        player.Say(SAY_NETMSG, "Listing factions from to " + begin + (end != FACTION_COUNT ? " to " + end : "end"));
    }

    string[] _rank   = { "UNKNOWN", "Rookie", "Accepted", "Trusted", "Important", "Leader" };
    string[] _status = { "UNKNOWN", "Friend", "Neutral",  "Enemy",   "Invited" };

    for(uint f = 0, fcount = GetFactionsCount(); f < fcount; f++)
    {
        IFaction@ faction = GetFactionByIdx(f);
        if(!valid(faction))
            continue;
        if((id > 0 && faction.get_Id() != id) ||
           (id < 0 && (faction.get_Id() < int(begin) || faction.get_Id() > int(end))))
            continue;

        int fid = (id > 0 ? id : faction.get_Id());

        player.Say(SAY_NETMSG, "\nFaction " + fid);
        player.Say(SAY_NETMSG, "Name: " + faction.get_Name());
        player.Say(SAY_NETMSG, "Score: " + GetFactionScore(fid));
        // player.Say( SAY_NETMSG, "TTL: "+ );
        player.Say(SAY_NETMSG, "Radio channel: " + GetFactionRadioChannel(fid));

        array<IFactionBase@> base;
        GetFactionBases(fid, base);
        if(base.length() > 0)
        {
            player.Say(SAY_NETMSG, "Base" + (base.length() > 1 ? "s" : "") + " (" + base.length() + "):");
            for(uint b = 0, bcount = base.length(); b < bcount; b++)
            {
                player.Say(SAY_NETMSG, " \"" + base[b].get_Name() + "\" (" + base[b].get_Id() + ")");
                string    _loc = "  Location: " + base[b].get_LocationId();
                Location@ loc = GetLocation(base[b].get_LocationId());
                if(valid(loc))
                {
                    player.Say(SAY_NETMSG, _loc + " " + ZONE_X(loc.WorldX) + ":" + ZONE_Y(loc.WorldY) + " " +
                               loc.WorldX + "," + loc.WorldY);
                    Map@ map = loc.GetMapByIndex(0);
                    if(valid(map))
                        player.Say(SAY_NETMSG, "  Map: " + map.Id);
                }
                else
                    player.Say(SAY_NETMSG, _loc + " (don't exists!)");
            }
        }

        if(!fullLog)
        {
            player.Say(SAY_NETMSG, "------------------------------");
            continue;
        }

        array<uint> member;
        faction.GetMembers(member);
        if(member.length() == 0)
        {
            player.Say(SAY_NETMSG, "No members.");
            continue;
        }

        player.Say(SAY_NETMSG, "Member" + (member.length() > 1 ? "s" : "") + " (" + member.length() + "):");
        for(uint m = 0, mcount = member.length(); m < mcount; m++)
        {
            if(m > 0)
                player.Say(SAY_NETMSG, "-------------------");

            int rank   = faction.GetRank(member[m]);
            int status = faction.GetStatus(member[m]);
            player.Say(SAY_NETMSG, " " + GetSafePlayerName(member[m]) + "(" + m + ")" +
                       (rank > 0 ? " " + _rank[rank] : "") +
                       ((rank > 0 && status > 0) ? "," : "") +
                       (status > 0 ? " " + _status[status] : "")
                       );

        }

        player.Say(SAY_NETMSG, "------------------------------");

    }

}

void ExecFactionOnlineCommand(array<string@>@ command, Critter& player)
{
    uint faction = 0;
    bool found = false;
    if(command.length() < 3)
    {
        player.Say(SAY_NETMSG, "You must specify a faction id.");
        return;
    }

    if(!StrToInt(command[2], faction))
    {
        player.Say(SAY_NETMSG, "You must specify a faction id.");
        return;
    }
    array<Critter@> crs;
    uint            num = GetAllOnlinePlayers(crs);
    uint            index = 0;
    for(uint i = 0; i < num; i++)
    {
        if(IsMember(faction, crs[i]))
        {
            if(!found)
            {
                found = true;
                player.Say(SAY_NETMSG, "Listing members from faction " + faction + " that are online:");
            }
            index++;
            player.Say(SAY_NETMSG, "[" + index + "] " + GetCritterInfo(crs[i]));
        }
    }

    if(!found)
        player.Say(SAY_NETMSG, "Found no members from faction " + faction + " online.");
}

void ExecFindItemsCommand(array<string@>@ command, Critter& player)
{
    int  owner = 0; // spawner, if 0, by game, if not specified, all.
    bool OwnerSpecified = false;
    StrToInt(GetParameterString(command, "-o"), owner);
    if(GetIndexOfString(command, "-o") != -1)
        OwnerSpecified = true;

    if(GetIndexOfString(command, "-pid") == -1)
    {
        player.Say(SAY_NETMSG, "No PID given. Use -pid <pid>");
        return;
    }

    uint   pid = 0;
    string pidString = GetParameterString(command, "-pid");

    uint   From = 0;
    StrToInt(GetParameterString(command, "-f"), From);

    uint KeyId = 0;
    StrToInt(GetParameterString(command, "-k"), KeyId);

    uint To = 0;
    StrToInt(GetParameterString(command, "-t"), To);

    uint Min = 0;
    StrToInt(GetParameterString(command, "-min"), Min);

    bool noInv = (GetIndexOfString(command, "-skipinventory") > 0);
    bool noCont = (GetIndexOfString(command, "-skipcontainer") > 0);
    bool noHex = (GetIndexOfString(command, "-skipground") > 0);

    bool parsed = StrToInt(pidString, pid);
    // otherwise, check in the global dictionary
    if(pidString == "")
        return;
    if(!parsed)
    {
        if(!GetItemPid(pidString, pid))
        {
            player.Say(SAY_NETMSG, "Item does not exist");
            return;
        }
    }


    if(pid == 0 && !OwnerSpecified)
        return;
    // ((FromPid>0&&ToPid>0)?("from "+ FromPid + " to "+ToPid):""+pid)
    player.Say(SAY_NETMSG, "Searching for items with PID " + pid + (owner > 0 ? " spawned by " + owner : "") + ".");

    array<Item@> items;
    uint         n = 0;
    n = GetAllItems(pid, items);

    if(To == 0)
        To = n;
    if(From == 0)
        From = 1;

    uint found = 0;
    uint count = 1;
    for(uint i = From - 1; i < To; i++)
    {
        if(i >= items.length())
            break;

        if(KeyId > 0 && items[i].LockerId != KeyId)
            continue;

        if(noInv && items[i].Accessory == ACCESSORY_CRITTER)
            continue;

        if(noCont && items[i].Accessory == ACCESSORY_CONTAINER)
            continue;

        if(noHex && items[i].Accessory == ACCESSORY_HEX)
            continue;

        if((!OwnerSpecified || _GetSpawner(items[i]) == owner))
        {
            string ownerInfo = "";
            int    spawnerId = _GetSpawner(items[i]);
            if(!OwnerSpecified && spawnerId > 0)
            {
                string sOwner = GetSafePlayerName(spawnerId);
                ownerInfo = " (spawned:" + (sOwner == "[player not found]" ? "" + spawnerId : sOwner + "(" + spawnerId + ")") + ")";
            }
            else if(pid == 0)
            {
                ownerInfo = " PID(" + items[i].GetProtoId() + ")";
            }

            count = items[i].GetCount();
            if(count >= Min)
            {
                found++;
                string pref = "[" + ((From - 1) + found) + "] ";


                if(items[i].Accessory == ACCESSORY_CRITTER)
                    player.Say(SAY_NETMSG, pref + count + " item" + (count > 1 ? "s" : "") + " (" + items[i].Id + ") on critter " + items[i].CritId + ownerInfo);
                else if(items[i].Accessory == ACCESSORY_CONTAINER)
                {
                    Item@ cont = GetItem(items[i].ContainerId);
                    player.Say(SAY_NETMSG, pref + count + " item" + (count > 1 ? "s" : "") + " (" + items[i].Id + ") in container " + items[i].ContainerId + (!valid(cont) ? "(bugged) " : "") + " in map " + cont.MapId + " [" + cont.HexX + "," + cont.HexY + "]" + ownerInfo);
                }
                else if(items[i].Accessory == ACCESSORY_HEX)
                    player.Say(SAY_NETMSG, pref + count + " item" + (count > 1 ? "s" : "") + " (" + items[i].Id + ") on ground in map " + items[i].MapId + " [" + items[i].HexX + "," + items[i].HexY + "]" + ownerInfo);
                else
                    player.Say(SAY_NETMSG, pref + "Didn't find item. Strange.");
            }
        }
    }
    if(found == 0)
        player.Say(SAY_NETMSG, "Found no items.");
}

//
// Forces target to say specific message
//
void ExecSayCommand(array<string@>@ command, Critter& player, Critter@ target, int sayType)
{
    if(sayType == SAY_FLASH_WINDOW)
        player.Say(SAY_NETMSG, "Flashing...");
    else
        player.Say(SAY_NETMSG, "Saying...");

    string msg = GetParameterString(command, "-m");

    if(sayType == SAY_FLASH_WINDOW)
    {
        target.Say(sayType, "flash");
        return;
    }
    if(msg != "")
        target.Say(sayType, msg);
    else
        player.Say(SAY_NETMSG, "Nothing to say");
}

//
// Forces animation
//
/*
   void ExecAnimateCommand(string@[]@ command, Critter& player, Critter@ target)
   {
    player.Say(SAY_NETMSG, "Dance, dance, dance!");

    string animation;

    if(command.length() > 2)
        animation = command[2];
    else
    {
        player.Say(SAY_NETMSG, "Incorrect animation type");
        return;
    }

    if(animation == "use")
        _CritAnimateUse(target);
    else if(animation == "sit")
        _CritAnimateSit(target);
    else if(animation == "punch")
        _CritAnimatePunch(target);
    else if(animation == "kick")
        _CritAnimateKick(target);
    else if(animation == "throw")
        _CritAnimateThrow(target);
    else if(animation == "thrust")
        _CritAnimateThrust(target);
    else if(animation == "swing")
        _CritAnimateSwing(target);
    else if(animation == "single")
        _CritAnimateSingle(target);
    else if(animation == "burst")
        _CritAnimateBurst(target);
        else
        {
                // more sophisticated
                string a1 = GetParameterString(command, "-a");
                string a2 = GetParameterString(command, "-b");
                uint8 anim1 = 0xFF;
                uint8 anim2 = ANIM2_USE;

                if(a1 == "empty")
                        anim1 = ANIM1_EMPTY;
                else if(a1 == "ko")
                        anim1 = ANIM1_KO;
                else if(a1 == "dead")
                        anim1 = ANIM1_DEAD;
                else if(a1 == "knife")
                        anim1 = ANIM1_KNIFE;
                else if(a1 == "club")
                        anim1 = ANIM1_CLUB;
                else if(a1 == "hammer")
                        anim1 = ANIM1_HAMMER;
                else if(a1 == "spear")
                        anim1 = ANIM1_SPEAR;
                else if(a1 == "pistol")
                        anim1 = ANIM1_PISTOL;
                else if(a1 == "uzi")
                        anim1 = ANIM1_UZI;
                else if(a1 == "shotgun")
                        anim1 = ANIM1_SHOOTGUN;
                else if(a1 == "rifle")
                        anim1 = ANIM1_RIFLE;
                else if(a1 == "minigun")
                        anim1 = ANIM1_MINIGUN;
                else if(a1 == "rl")
                        anim1 = ANIM1_ROCKET_LAUNCHER;
                else if(a1 == "rip")
                        anim1 = ANIM1_RIP;

                if(a2 == "ko_up")
                {
                        anim1 = ANIM1_KO;
                        anim2 = ANIM2_KO_UP;
                }
                else if(a2 == "ko_dw")
                {
                        anim1 = ANIM1_KO;
                        anim2 = ANIM2_KO_DW;
                }
                else if(a2 == "stay")
                {
                        anim1 = ANIM1_EMPTY;
                        anim2 = ANIM2_STAY;
                }
                else if(a2 == "show")
                        anim2 = ANIM2_SHOW;
                else if(a2 == "hide")
                        anim2 = ANIM2_HIDE;
                else if(a2 == "miss_weap")
                        anim2 = ANIM2_MISS_WEAP;
                else if(a2 == "miss_empty")
                {
                        anim1 = ANIM1_EMPTY;
                        anim2 = ANIM2_MISS_EMPTY;
                }
                else if(a2 == "act")
                        anim2 = ANIM2_ACT;
                else if(a2 == "unact")
                        anim2 = ANIM2_UNACT;
                else if(a2 == "walk")
                {
                        anim1 = ANIM1_EMPTY;
                        anim2 = ANIM2_WALK;
                }
                else if(a2 == "run")
                {
                        anim1 = ANIM1_EMPTY;
                        anim2 = ANIM2_RUN;
                }
                else if(a2 == "use")
                {
                        anim1 = ANIM1_EMPTY;
                        anim2 = ANIM2_USE;
                }
                else if(a2 == "sit")
                {
                        anim1 = ANIM1_EMPTY;
                        anim2 = ANIM2_SIT;
                }
                else if(a2 == "defeat_front")
                        anim2 = ANIM2_DEFEAT_FRONT;
                else if(a2 == "defeat_rear")
                        anim2 = ANIM2_DEFEAT_REAR;
                else if(a2 == "punch")
                {
                        anim1 = ANIM1_EMPTY;
                        anim2 = ANIM2_PUNCH;
                }
                else if(a2 == "kick")
                {
                        anim1 = ANIM1_EMPTY;
                        anim2 = ANIM2_KICK;
                }
                else if(a2 == "throw_weap")
                        anim2 = ANIM2_THROW_WEAP;
                else if(a2 == "throw_empty")
                {
                        anim1 = ANIM1_EMPTY;
                        anim2 = ANIM2_THROW_EMPTY;
                }
                else if(a2 == "thrust")
                        anim2 = ANIM2_THRUST;
                else if(a2 == "swing")
                        anim2 = ANIM2_SWING;
                else if(a2 == "shoot")
                        anim2 = ANIM2_SHOOT;
                else if(a2 == "burst")
                        anim2 = ANIM2_BRUST;
                else if(a2 == "dead_up")
                {
                        anim1 = ANIM1_DEAD;
                        anim2 = ANIM2_DEAD_UP;
                }
                else if(a2 == "dead_down")
                {
                        anim1 = ANIM1_DEAD;
                        anim2 = ANIM2_DEAD_DOWN;
                }
                else if(a2 == "dead_mess")
                {
                        anim1 = ANIM1_DEAD;
                        anim2 = ANIM2_DEAD_MESS;
                }
                else if(a2 == "dead_burn")
                {
                        anim1 = ANIM1_DEAD;
                        anim2 = ANIM2_DEAD_BURN;
                }
                else if(a2 == "dead_head")
                {
                        anim1 = ANIM1_DEAD;
                        anim2 = ANIM2_DEAD_HEAD;
                }
                else if(a2 == "dead_burst")
                {
                        anim1 = ANIM1_DEAD;
                        anim2 = ANIM2_DEAD_BRUST;
                }
                else if(a2 == "dead_pulse")
                {
                        anim1 = ANIM1_DEAD;
                        anim2 = ANIM2_DEAD_PULSE;
                }
                else if(a2 == "dead_laser")
                {
                        anim1 = ANIM1_DEAD;
                        anim2 = ANIM2_DEAD_LASER;
                }
                else if(a2 == "dead_burn2")
                {
                        anim1 = ANIM1_DEAD;
                        anim2 = ANIM2_DEAD_BURN2;
                }
                else if(a2 == "dead_pulse2")
                {
                        anim1 = ANIM1_DEAD;
                        anim2 = ANIM2_DEAD_PULSE2;
                }
                else if(a2 == "dead_explode")
                {
                        anim1 = ANIM1_DEAD;
                        anim2 = ANIM2_DEAD_EXPLODE;
                }
                else if(a2 == "dead_fused")
                {
                        anim1 = ANIM1_DEAD;
                        anim2 = ANIM2_DEAD_FUSED;
                }
                else if(a2 == "dead_burn_run")
                {
                        anim1 = ANIM1_DEAD;
                        anim2 = ANIM2_DEAD_BURN_RUN;
                }
                else if(a2 == "dead_up2")
                {
                        anim1 = ANIM1_DEAD;
                        anim2 = ANIM2_DEAD_UP2;
                }
                else if(a2 == "dead_down2")
                {
                        anim1 = ANIM1_DEAD;
                        anim2 = ANIM2_DEAD_DOWN2;
                }

                // even more sophisticated
                string ct = GetParameterString(command, "-c");
                uint8 crType = 0xFF;
                StrToInt(ct, crType);

                // finally, animate
                target.Animate(crType, anim1, anim2, 0xFF, 0, true, true, true);
        }
   }*/

void ExecSetAnimCommand(array<string@>@ command, Critter& player, Critter@ target, bool mass)
{
    if(command.length() < 4)
    {
        player.Say(SAY_NETMSG, "Missing arguments.");
        return;
    }

    int anim1 = 0;
    int anim2 = 0;

    StrToInt(command[2], anim1);
    StrToInt(command[3], anim2);

    player.Say(SAY_NETMSG, "Dance for me!");
    if(mass)
    {
        array<Critter@> crits;
        uint            num = player.GetCritters(false, FIND_ALL, crits);
        for(uint i = 0; i < num; i++)
        {
            if(!GodOfTheRealm(crits[i].Id))
                crits[i].SetAnims(0, anim1, anim2);
        }

    }
    else
        target.SetAnims(0, anim1, anim2);
}

//
// Changes critter sprites
//
void ExecDisguiseCommand(array<string@>@ command, Critter& player, Critter@ target)
{
    player.Say(SAY_NETMSG, "Wearing disguise...");

    if(command.length() < 3)
    {
        player.Say(SAY_NETMSG, "Incorrect number of parameters");
        return;
    }
    uint bt = player.CrType;
    bool res = false;

    bool parsed = StrToInt(command[2], bt);
    // otherwise, check in the global dictionary
    if(!parsed)
    {
        if(!GetBaseType(command[2], bt))
        {
            player.Say(SAY_NETMSG, "Basetype does not exist");
            return;
        }
    }
    player.Say(SAY_NETMSG, "Changing from: " + target.CrType + " to " + bt);
    res = target.ChangeCrType(bt);

    if(!res)
        player.Say(SAY_NETMSG, "Couldn't change appearance");
    else
    {
        target.StatBase[ST_BASE_CRTYPE] = bt;
        target.DisguisedBy = player.Id;
    }
}

void ExecDisguiseInfoCommand(array<string@>@ command, Critter& player)
{
    array<Critter@> players;
    uint            all = GetAllOnlinePlayers(players);
    for(uint p = 0; p < all; p++)
    {
        #ifndef __DEBUG__
        if(GodOfTheRealm(players[p].Id))
            continue;

        if(players[p].GetAccess() > ACCESS_CLIENT)
            continue;
        #endif

        if(players[p].StatBase[ST_GENDER] == GENDER_MALE &&
           (players[p].StatBase[ST_BASE_CRTYPE] == CRTYPE_MALE_DEFAULT ||
            players[p].StatBase[ST_BASE_CRTYPE] == CRTYPE_MALE_JUMPSUIT ||
            players[p].StatBase[ST_BASE_CRTYPE] == CRTYPE_LHD_JUMPSUIT ||
            players[p].StatBase[ST_BASE_CRTYPE] == CRTYPE_BHD_JUMPSUIT))
            continue;

        if((players[p].StatBase[ST_GENDER] == GENDER_FEMALE &&
            players[p].StatBase[ST_BASE_CRTYPE] == CRTYPE_FEMALE_DEFAULT))
            continue;

        string info = players[p].Name + "(" + players[p].Id + "): CritterType " +
                      players[p].StatBase[ST_BASE_CRTYPE];

        if(int(players[p].CrType) != players[p].StatBase[ST_BASE_CRTYPE])
            info += " (" + players[p].CrType + ")";

        if(players[p].DisguisedBy > 0 && (players[p].DisguisedBy != players[p].Id))
        {
            info += " by ";
            string@ name = GetSafePlayerName(players[p].DisguisedBy);

            if(valid(name))
                info += name + " ";
            else
                info += "??? ";

            info += "(" + players[p].DisguisedBy + ")";
        }
        player.Say(SAY_NETMSG, info);
    }

}


void ExecConditionCommand(array<string@>@ command, Critter& player, Critter@ target)
{
    if(command.length() < 2)
    {
        player.Say(SAY_NETMSG, "Wrong number of parameters");
        return;
    }

    uint id = GetPlayerId(command[2]);

    if(id == 0)
    {
        player.Say(SAY_NETMSG, "Invalid player");
    }
    else
    {
        Critter@ target = GetCritter(id);
        if(!valid(target))
        {
            player.Say(SAY_NETMSG, "Invalid player");
        }
        else
        {
            player.Say(SAY_NETMSG, "Conditions of " + command[2] + ":");
            player.Say(SAY_NETMSG, "" + GetConditionOfCritter(target));
            player.Say(SAY_NETMSG, "" + GetExtConditionOfCritter(target));
        }
    }
}

void ExecBroadcastCommand(array<string@>@ command, Critter& player)
{
    /*
       string message;
       int showtime=10; // 10 seconds as default, 1337 = show forever.
       message = GetParameterString(command, "-m");
       StrToInt(GetParameterString(command, "-t"), showtime);

       if (message=="")
       {
       player.Say(SAY_NETMSG, "You didn't enter a message. Maybe you forgot to use '-m' ?");
       return;
       }

       bool Local = (GetIndexOfString(command, "-l")!=-1);

       Critter@[] players;
       uint num;
       if(Local)
       {
       if(player.GetMapId()==0)
       {
        player.Say(SAY_NETMSG, "Can't broadcast locally on worldmap.");
        return;
       }
        Map@ map = player.GetMap();
        if(!valid(map))
        {
            player.Say(SAY_NETMSG, "Invalid map.");
        return;
        }
        num = map.GetCritters(0, FIND_ALL | FIND_ONLY_PLAYERS, players);
       }
       else
       num = GetAllOnlinePlayers(players);

       for (uint i = 0; i < num; i++)
       {
       players[i].Say(SAY_NETMSG, "|4294901760 "+(!Local?"Server message: ":"")+message);
       players[i].RunClientScript("_BroadcastMessage", showtime, (Local?1:0), 0, message, null);
       }
     */
    IBroadcastBuffer@        msg;

    array<IBroadcastBuffer@> buf;
    FindBroadcastBufferByGM(player.Id, buf);
    string                   msgs = " broadcast message(s)";
    string                   no_msgs = "You don't have" + msgs + " in buffer.";

    // player.Say( SAY_NETMSG, "buf len = "+buf.length() );

    if(GetIndexOfString(command, "-delete") >= 0)
    {
        if(buf.length() == 0)
        {
            player.Say(SAY_NETMSG, no_msgs);
            return;
        }
        else
        {
            player.Say(SAY_NETMSG, "Deleting" + msgs);
            for(uint b = 0; b < buf.length(); b++)
            {
                buf[b].ResetStart();
                buf[b].SetLifetime(0);
                buf[b].ToDelete();
            }
        }
        return;
    }
    else if(GetIndexOfString(command, "-test") >= 0)
    {
        if(buf.length() == 0)
        {
            player.Say(SAY_NETMSG, no_msgs);
            return;
        }
        else
        {
            player.Say(SAY_NETMSG, "Testing" + msgs);
            for(uint b = 0; b < buf.length(); b++)
            {
                buf[b].ResetStart();
                buf[b].Send(player);
                buf[b].SetStart(-1);
            }
        }
        return;
    }
    else if(GetIndexOfString(command, "-send") >= 0)
    {
        if(buf.length() == 0)
        {
            player.Say(SAY_NETMSG, no_msgs);
            return;
        }
        else
        {
            player.Say(SAY_NETMSG, "Sending" + msgs);
            for(uint b = 0; b < buf.length(); b++)
            {
                buf[b].ResetStart();
                buf[b].SendToAll();
                buf[b].UnsetGM();
            }
        }
        return;
    }

    bool   wait = (GetIndexOfString(command, "-wait") != -1);

    string message = GetParameterString(command, "-m");
    if(message == "")
    {
        player.Say(SAY_NETMSG, "You didn't enter a message. Maybe you forgot to use -m ?");
        return;
    }

    array<int> data;
    if(buf.length() == 0)
    {
        @msg = AddBroadcastBuffer(BROADCAST_MESSAGE, 0, 0, "Server message: " + message, data, 0, BROADCAST_FILTER_NONE);
        if(wait)
            msg.SetStart(-1);
    }
    else if(buf.length() == 1)
    {
        @msg = @buf[0];
        msg.AppendMessage("\n" + message);
        wait = true;
    }
    else
    {
        player.Say(SAY_NETMSG, "More than one broadcast assigned to you, cannot continue.");
        return;
    }
    msg.SetGM(player.Id);

    int showtime = 0;
    string[] t = { "-t", "-time" };
    if(StrToInt(GetParameterString(command, t), showtime))
        showtime = REAL_SECOND(showtime);
    else
        showtime = REAL_SECOND(40) + REAL_MS(message.length() * 100);
    msg.SetTime(showtime);

    string[] sf = { "-f", "-filter" };
    string f = GetParameterString(command, sf);

    bool   ilog = true;

    if(f != "")
    {
        array<string@>@ filters = split(f, ",");
        if(filters.length() > 0)
        {
            ilog = false;
            for(uint f = 0; f < filters.length(); f++)
            {
                // easy flags
                if(filters[f] == "tester")
                    msg.SetFilter(BROADCAST_FILTER_TESTER);
                else if(filters[f] == "moder")
                    msg.SetFilter(BROADCAST_FILTER_MODER);
                else if(filters[f] == "admin")
                    msg.SetFilter(BROADCAST_FILTER_ADMIN);
                else if(filters[f] == "auth" || filters[f] == "authenticated")
                    msg.SetFilter(BROADCAST_FILTER_AUTHENTICATED);
                else if(filters[f] == "god")
                    msg.SetFilter(BROADCAST_FILTER_GOD);
                else if(filters[f] == "mortal")
                    msg.SetFilter(BROADCAST_FILTER_MORTAL);
                else if(filters[f] == "female")
                    msg.SetFilter(BROADCAST_FILTER_FEMALE);
                else if(filters[f] == "male")
                    msg.SetFilter(BROADCAST_FILTER_MALE);
                else if(filters[f] == "wm" || filters[f] == "worldmap")
                    msg.SetFilter(BROADCAST_FILTER_MODER);
                // things get worse
                else if(substring(filters[f], 0, 3) == "map")
                {
                    array<string@>@ map = split(filters[f], ":");
                    if(map.length() == 1)                         // map
                    {
                        if(valid(player.GetMap()))
                            msg.SetFilter(BROADCAST_FILTER_MAP, player.GetMap().Id);
                        else
                        {
                            player.Say(SAY_NETMSG, "Invalid map.");
                            return;
                        }
                    }
                    else if(map.length() == 2)                         // map:X
                    {
                        int mapId = 0;
                        StrToInt(map[1], mapId);
                        if(mapId > 0)
                        {
                            if(!valid(GetMap(mapId)))
                            {
                                player.Say(SAY_NETMSG, "Invalid map id: " + mapId);
                                return;
                            }
                            else
                                msg.SetFilter(BROADCAST_FILTER_MAP, mapId);
                        }
                        else
                        {
                            if(map[1] == "any")
                            {
                                msg.SetFilter(BROADCAST_FILTER_ANYMAP);
                            }
                            else
                            {
                                player.Say(SAY_NETMSG, "Invalid argument for filter 'map'");
                                return;
                            }
                        }
                    }
                    else
                    {
                        player.Say(SAY_NETMSG, "Wrong number of arguments for filter 'map'");
                        return;
                    }
                }
                else if(substring(filters[f], 0, 3) == "loc")
                {
                    array<string@>@ loc = split(filters[f], ":");
                    if(loc.length() == 1)                         // loc
                    {
                        if(valid(player.GetMap()) && valid(player.GetMap().GetLocation()))
                            msg.SetFilter(BROADCAST_FILTER_LOCATION, player.GetMap().GetLocation().Id);
                        else
                        {
                            player.Say(SAY_NETMSG, "Invalid map/location.");
                            return;
                        }
                    }
                    else if(loc.length() == 2)                         // loc:X
                    {
                        int locId = 0;
                        StrToInt(loc[1], locId);
                        if(locId > 0)
                        {
                            if(!valid(GetLocation(locId)))
                            {
                                player.Say(SAY_NETMSG, "Invalid location id: " + locId);
                                return;
                            }
                            else
                                msg.SetFilter(BROADCAST_FILTER_LOCATION, locId);
                        }
                        else
                        {
                            player.Say(SAY_NETMSG, "Invalid argument for filter 'loc'");
                            return;
                        }
                    }
                    else
                    {
                        player.Say(SAY_NETMSG, "Wrong number of arguments for filter 'loc'");
                        return;
                    }
                }
                else if(substring(filters[f], 0, 3) == "lvl")
                {
                    array<string@>@ lvl = split(filters[f], ":");
                    if(lvl.length() == 1)                         // lvl
                    {
                        player.Say(SAY_NETMSG, "Level not given.");
                        return;
                    }
                    else if(lvl.length() == 2)                         // lvl:X
                    {
                        int lvlNum = 0;
                        if(StrToInt(lvl[1], lvlNum))
                        {
                            if(lvlNum < 1)
                            {
                                player.Say(SAY_NETMSG, "Invalid level: " + lvlNum);
                                return;
                            }
                            else
                                msg.SetFilter(BROADCAST_FILTER_LEVEL, lvlNum);
                        }
                        else
                        {
                            player.Say(SAY_NETMSG, "Invalid argument for filter 'lvl'");
                            return;
                        }
                    }
                    else
                    {
                        player.Say(SAY_NETMSG, "Wrong number of arguments for filter 'lvl'");
                        return;
                    }
                }
                else if(substring(filters[f], 0, 7) == "faction" || substring(filters[f], 0, 4) == "gang")
                {
                    array<string@>@ faction = split(filters[f], ":");
                    if(faction.length() == 1)                         // faction/gang
                    {
                        player.Say(SAY_NETMSG, "Faction not given.");
                        return;
                    }
                    else if(faction.length() == 2)                         // faction:X
                    {
                        int factionId = 0;
                        if(StrToInt(faction[1], factionId))
                        {
                            if(factionId <= 1)                                 // don't send to 'Unknown' faction
                            {
                                player.Say(SAY_NETMSG, "Invalid faction id: " + factionId);
                                return;
                            }
                            else
                                msg.SetFilter(BROADCAST_FILTER_FACTION, factionId);
                        }
                        else
                        {
                            player.Say(SAY_NETMSG, "Invalid argument for filter 'faction'");
                            return;
                        }
                    }
                    else
                    {
                        player.Say(SAY_NETMSG, "Wrong number of arguments for filter 'faction'");
                        return;
                    }
                }
            }
        }
    }

    string[] cf = { "-c", "-color" };
    int c = 0;
    StrToInt(GetParameterString(command, cf), c);
    // if( c > 0 )
    msg.SetSetup(c);

    if(wait)
    {
        player.Say(SAY_NETMSG, "Broadcast buffered:");
        player.Say(SAY_NETMSG, msg.GetMessage());
    }
    else
    {
        if(ilog)
            ILog("broadcast", msg.GetMessage());
        msg.SendToAll();
    }
}


void ExecSetFactionCommand(array<string@>@ command, Critter& player, Critter@ target)
{
    player.Say(SAY_NETMSG, "Setting faction on this map");
    if(command.length() < 3)
        player.Say(SAY_NETMSG, "Please, specify faction id");
    else
    {
        uint id = 0;
        if(StrToInt(command[2], id))
            player.GetMap().SetData(MAP_DATA_FACTION, id);
        else
            player.Say(SAY_NETMSG, "Wrong id");
    }
}

void ExecSetLocVisibility(array<string@>@ command, Critter& player)
{
    if(command.length() < 3)
        player.Say(SAY_NETMSG, "Choose visibility flag. 1=visible, 0=hidden.");

    uint flag = 0;
    if(!StrToInt(command[2], flag))
    {
        player.Say(SAY_NETMSG, "Error.");
        return;
    }

    Location@ loc = player.GetMap().GetLocation();
    if(!valid(loc))
    {
        player.Say(SAY_NETMSG, "Are you on the worldmap? This command can only be applied to a location.");
        return;
    }

    if(flag == 0)
    {
        loc.Visible = false;
    }
    else
    {
        loc.Visible = true;
    }

    array<Critter@> players;
    uint            num = GetAllOnlinePlayers(players);

    // Hide for all players
    for(uint i = 0; i < num; i++)
    {
        if(!valid(players[i]))
            continue;
        if(!players[i].IsPlayer())
            continue;
        if(flag == 0)
            players[i].SetKnownLoc(false, loc.Id);
        else
            players[i].SetKnownLoc(true, loc.Id);
    }
    if(flag == 0)
        player.Say(SAY_NETMSG, "Location hidden.");
    else
        player.Say(SAY_NETMSG, "Location shown.");

    loc.Update();
}

void ExecSetRain(array<string@>@ command, Critter& player)
{
    player.Say(SAY_NETMSG, "Setting rain on this map");
    if(command.length() < 3)
        player.Say(SAY_NETMSG, "Please, specify rain intensity");
    else
    {
        uint intensity = 0;
        if(StrToInt(command[2], intensity))
            player.GetMap().SetRain(intensity);
        else
            player.Say(SAY_NETMSG, "Wrong intensity");
    }
}

void ExecSetMapDataCommand(array<string@>@ command, Critter& player)
{
    if(command.length() < 4)
    {
        player.Say(SAY_NETMSG, "Wrong number of parameters");
        return;
    }
    int  Index = 0;
    bool parsed = StrToInt(command[2], Index);
    if(!parsed)
    {
        if(!GetMapData(command[2], Index))
        {
            player.Say(SAY_NETMSG, "Mapdata define does not exist");
            return;
        }
    }
    int Value = 0;
    if(!StrToInt(command[3], Value))
    {
        player.Say(SAY_NETMSG, "Invalid value.");
        return;
    }
    Map@ map = player.GetMap();
    map.SetData(Index, Value);
    player.Say(SAY_NETMSG, "Mapdata set.");
}

void ExecSetTurnbasedCombat(Critter& player, bool enable)
{
    Map@ map = player.GetMap();
    if(valid(map))
    {
        map.SetTurnBasedAvailability(enable);
        if(enable)
            player.Say(SAY_NETMSG, "TB in the map enabled.");
        else
            player.Say(SAY_NETMSG, "TB in the map disabled.");
    }
}

void ExecMapDismantling(Critter& player, bool enable)
{
    Map@ map = player.GetMap();
    if(valid(map))
    {
        if((!enable &&  _MapHasMode(map, MAP_MODE_NO_DISMANTLING)) ||
           (enable  && !_MapHasMode(map, MAP_MODE_NO_DISMANTLING)))
        {
            player.Say(SAY_NETMSG, "Dismantling already " + (enable ? "en" : "dis") + "abled.");
            return;
        }
        if(enable)
            _MapUnsetMode(map, MAP_MODE_NO_DISMANTLING);
        else
            _MapSetMode(map, MAP_MODE_NO_DISMANTLING);
        player.Say(SAY_NETMSG, "Dismantling " + (enable ? "en" : "dis") + "abled.");
    }
    else
    {
        player.Say(SAY_NETMSG, "Not on worldmap.");
    }
}

void ExecMapPvp(Critter& player, bool enable)
{
    Map@ map = player.GetMap();
    if(valid(map))
    {
        if((!enable &&  _MapHasMode(map, MAP_MODE_NO_PVP)) ||
           (enable  && !_MapHasMode(map, MAP_MODE_NO_PVP)))
        {
            player.Say(SAY_NETMSG, "PvP already " + (enable ? "en" : "dis") + "abled.");
            return;
        }
        if(enable)
            _MapUnsetMode(map, MAP_MODE_NO_PVP);
        else
            _MapSetMode(map, MAP_MODE_NO_PVP);
        player.Say(SAY_NETMSG, "PvP " + (enable ? "en" : "dis") + "abled.");
    }
    else
    {
        player.Say(SAY_NETMSG, "Not on worldmap.");
    }
}

void ExecMapGrids(Critter& player, bool enable)
{
    Map@ map = player.GetMap();
    if(valid(map))
    {
        if((!enable &&  _MapHasMode(map, MAP_MODE_NO_GRIDS)) ||
           (enable  && !_MapHasMode(map, MAP_MODE_NO_GRIDS)))
        {
            player.Say(SAY_NETMSG, "Exit grids already " + (enable ? "en" : "dis") + "abled.");
            return;
        }
        if(enable)
        {
            _MapUnsetMode(map, MAP_MODE_NO_GRIDS);
            map.SetEvent(MAP_EVENT_LOOP_3, "_DoNothing");
            map.SetLoopTime(3, uint(-1));
            SetTimeoutForAll(map, TO_TRANSFER, 0);
        }
        else
        {
            // in case of changes, remember about editing main@start

            _MapSetMode(map, MAP_MODE_NO_GRIDS);
            map.SetEvent(MAP_EVENT_LOOP_3, "_LockMap");
            map.SetLoopTime(3, 500);
            SetTimeoutForAll(map, TO_TRANSFER, REAL_SECOND(2238));
        }

        player.Say(SAY_NETMSG, "Exit grids " + (enable ? "en" : "dis") + "abled.");
    }
    else
    {
        player.Say(SAY_NETMSG, "Not on worldmap.");
    }
}

void ExecClearEnemyStackCommand(array<string@>@ command, Critter& player, Critter@ target, bool all)
{
    if(!valid(player.GetMap()))          // worldmap
    {
        player.Say(SAY_NETMSG, "Not here.");
        return;
    }
    // Clear enemy stacks on all critters on the map command issuer is on
    if(all)
    {
        ClearEnemyStacksOnMap(player.GetMap());
        player.Say(SAY_NETMSG, "Cleared enemy stack of all critters on this map");
    }
    else
    {
        if(target.IsPlayer())
        {
            player.Say(SAY_NETMSG, "Target is not an NPC. Only NPCs have enemy stacks");
            return;
        }

        ClearEnemyStack(target);
        player.Say(SAY_NETMSG, "Cleared target enemy stack");
    }
}

void ExecCheckBankCommand(array<string@>@ command, Critter& player)
{
    string bankid = GetParameterString(command, "-b");
    int    id = 0;
    StrToInt(bankid, id);

    if(id > BANK_COUNT - 1 || id < 0)
    {
        player.Say(SAY_NETMSG, "Invalid bank ID");
        return;
    }

    string sid = "";
    switch(id)
    {
    case 0:
        sid = "Vault City";
        break;
    case 1:
        sid = "Redding";
        break;
    case 2:
        sid = "Broken Hills";
        break;
    case 3:
        sid = "San Francisco";
        break;
    case 4:
        sid = "Shady Sands";
        break;
    case 5:
        sid = "Hub";
        break;
    default:
        sid = "Unknown";
        break;
    }

    player.Say(SAY_NETMSG, "Bank " + id + " (" + sid + "):");
    player.Say(SAY_NETMSG, "Money reserves: " + "$" + BankGetTotalMoney(id));
    player.Say(SAY_NETMSG, "Accounts: " + BankGetNumberOfAccounts(id));
}

void ExecCheckBanksCommand(array<string@>@ command, Critter& player)
{
    command[1] = "checkbank";
    command.resize(3);

    for(uint b = 0; b < BANK_COUNT; b++)
    {
        command[3] = "" + b;
        ExecCheckBankCommand(command, player);
    }
}

void PrintAccountInfo(Critter& player, uint bank, uint acc, uint filtersum, bool verbose)
{
    if(BankGetAccountBalance(bank, acc) < int(filtersum))
        return;

    uint accountowner = BankGetAccountOwner(bank, acc);
    player.Say(SAY_NETMSG, "Owner: " + GetSafePlayerName(accountowner) + " (" + accountowner + ")");
    player.Say(SAY_NETMSG, "Balance: " + BankGetAccountBalance(bank, acc));

    if(verbose)
    {
        player.Say(SAY_NETMSG, "Account Type: " + BankGetAccountType(bank, acc));
        player.Say(SAY_NETMSG, "Access Count: " + BankGetAccessCount(bank, acc));
    }
}

void ExecCheckBankAccount(array<string@>@ command, Critter& player, bool All)
{
    string bankid = GetParameterString(command, "-b");
    string accid = GetParameterString(command, "-n");
    string filtersum = GetParameterString(command, "-f");
    int    id = 0;
    int    aid = 0;
    int    sum = 0;
    StrToInt(bankid, id);
    StrToInt(accid, aid);
    StrToInt(filtersum, sum);

    bool verbose = (GetIndexOfString(command, "-v") != -1);

    if(uint(id) > BANK_COUNT - 1 || id < 0)
    {
        player.Say(SAY_NETMSG, "Invalid bank ID");
        return;
    }

    if(All)
    {
        for(uint i = 0; i < BankGetNumberOfAccounts(id); i++)
        {
            PrintAccountInfo(player, id, i, sum, verbose);
        }
    }
    else
    {
        if(uint(id) > uint(BankGetNumberOfAccounts(id)) || id < 0)
        {
            player.Say(SAY_NETMSG, "Invalid account ID.");
            return;
        }

        PrintAccountInfo(player, id, aid, sum, verbose);
    }
}

void ExecBankMoney(array<string@>@ command, Critter& player, bool add)
{
    string bankid = GetParameterString(command, "-b");
    int    id = 0;
    StrToInt(bankid, id);

    if(id > BANK_COUNT - 1 || id < 0)
    {
        player.Say(SAY_NETMSG, "Invalid bank ID");
        return;
    }

    string stramount = GetParameterString(command, "-a");
    int    amount = 0;
    StrToInt(stramount, amount);

    if(add)
        BankAddMoney(id, amount);
    else
        BankRemoveMoney(id, amount);
}

void ExecCheckTownCommand(array<string@>@ command, Critter& player)
{
    string townid = GetParameterString(command, "-n");
    int    id = 0;
    StrToInt(townid, id);

    ITown@ town = GetTown(id);
    if(!(valid(town)))
    {
        player.Say(SAY_NETMSG, "Invalid town ID");
        return;
    }

    uint   faction = town.GetControllingFaction();
    string factionname;
    GetFactionNameStr(faction, factionname);

    if(faction == 0)
        player.Say(SAY_NETMSG, "Current controlling faction: None");
    else
    {
        player.Say(SAY_NETMSG, "Current controlling faction: " + factionname + " (" + faction + ")");
        player.Say(SAY_NETMSG, "Number of Controlcycles: " + town.GetControlCycles());
        player.Say(SAY_NETMSG, "Number of NPCs killed during this regime: " + town.GetNumberOfKilledNPCs());
    }
}

void ExecGainTownControlCommand(array<string@>@ command, Critter& player)
{
    string townid = GetParameterString(command, "-n");
    int    id = 0;
    StrToInt(townid, id);
    ITown@ town;

    if(id == 0)
        @town = RetrieveTown(player);
    else
        @town = GetTown(id);

    if(!valid(town))
        player.Say(SAY_NETMSG, "Invalid town");

    town.GainControl(player);
}

void ExecResetTownCommand(array<string@>@ command, Critter& player, bool all)
{
    if(!all)
    {
        string townid = GetParameterString(command, "-n");
        int    id = 0;
        StrToInt(townid, id);

        ITown@ town = GetTown(id);
        if(!(valid(town)))
        {
            player.Say(SAY_NETMSG, "Invalid town ID");
            return;
        }
        town.ResetControl();
        SetBestScore(TOWN_SCORE_BASE + id, null, "");
    }
    else
    {
        for(uint i = 1; i <= GetTownCount(); i++)
        {
            ITown@ town = GetTown(i);
            if valid(town)
            town.ResetControl();
            SetBestScore(TOWN_SCORE_BASE + i, null, "Unknown");
        }
    }
    player.Say(SAY_NETMSG, "Done.");
}

//
// Event handler for deathincarnate command
//
void _Kill(Critter& killer, Critter& victim)
{
    if(!GodOfTheRealm(victim.Id))
        victim.ToDead(GetRandomDeathAnimation(), null);
}

/*void _TrackingMapEntered(Map& map, Critter& cr)
   {
    Critter@ observer = GetCritter(GetLvar(cr, LVAR_command_tracking));
    if (!valid(observer))
        return;

    observer.Say(SAY_NETMSG, "> " + cr.Name + " has entered map " + map.GetProtoId());
   }

   void _TrackingMapLeft(Map& map, Critter& cr)
   {
    Critter@ observer = GetCritter(GetLvar(cr, LVAR_command_tracking));
    if (!valid(observer))
        return;

    observer.Say(SAY_NETMSG, "> " + cr.Name + " has left map " + map.GetProtoId());
   }

   void _TrackingCritterDead(Map& map, Critter& cr, Critter@ killer)
   {
    Critter@ observer = GetCritter(GetLvar(cr, LVAR_command_tracking));
    if (!valid(observer))
        return;

    observer.Say(SAY_NETMSG, "> " + cr.Name + " has died on map " + map.GetProtoId());
   }*/


//
// Perk cheats
//
void ExecSetPerkCommand(array<string@>@ command, Critter& player, Critter& target)
{
    player.Say(SAY_NETMSG, "Executing SetPerk command");

    int id = 0;
    if(command.length() < 3)
    {
        player.Say(SAY_NETMSG, "Wrong number of parameters");
        return;
    }
    // parsing doesn't work properly, use numerical values instead (from _defines.fos)
    bool parsed = StrToInt(command[2], id);
    // otherwise, check in the global dictionary
    if(!parsed)
    {
        if(!GetVarId(command[2], id))
        {
            player.Say(SAY_NETMSG, "LVAR does not exist");
            return;
        }
    }
    int val = 0;
    if(!StrToInt(command[3], val))
    {
        player.Say(SAY_NETMSG, "Wrong value");
        return;
    }
    player.PerkBase[id] = val;
}

void ExecPerkAdjust(array<string@>@ command, Critter@ player, Critter@ target)
{
    int perk = 0;
    StrToInt(GetParameterString(command, "-k"), perk);

    int level = 0;
    StrToInt(GetParameterString(command, "-l"), level);

    target.PerkBase[perk] = level;
    player.Say(SAY_NETMSG, "Perk " + perk + " set to level " + level);
}

void ExecProfAdjust(array<string@>@ command, Critter@ player, Critter@ target)
{
    int perk = 0;
    StrToInt(GetParameterString(command, "-k"), perk);

    int level = 0;
    StrToInt(GetParameterString(command, "-l"), level);

    target.PerkBase[perk] = level;
    player.Say(SAY_NETMSG, "Profession " + perk + " set to level " + level);
}

void ExecCriticalChance(array<string@>@ command, Critter@ player, Critter@ target)
{
    int level = 0;
    StrToInt(GetParameterString(command, "-l"), level);
    target.StatBase[ST_CRITICAL_CHANCE] = level;
}

void ExecSetReputationCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    player.Say(SAY_NETMSG, "Adjusting reputation for " + target.Name);

    int repIdx = 0;
    if(command.length() < 3)
    {
        player.Say(SAY_NETMSG, "Wrong number of parameters");
        return;
    }
    StrToInt(command[2], repIdx);

    int inc = 0;
    StrToInt(GetParameterString(command, "-i"), inc);
    int dec = 0;
    StrToInt(GetParameterString(command, "-d"), dec);
    int val = 0;
    StrToInt(GetParameterString(command, "-v"), val);
    if(inc > 0)
        target.ReputationBase[repIdx] += inc;
    else if(dec > 0)
        target.ReputationBase[repIdx] -= dec;
    else
        target.ReputationBase[repIdx] = val;
}
void ExecResetReputationsCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    player.Say(SAY_NETMSG, "Resetting reputations for " + target.Name);
    for(uint i = 0; i < REPUTATION_COUNT; i++)
        target.ReputationBase[i] = int(0x80000000);
}

/**
 * Regenerates location, keeps rentable domiciles containers
 */
void ExecSafeRegenCommand(array<string@>@ command, Critter@ player)
{
    Map@ map = player.GetMap();
    if(!valid(map))
    {
        player.Say(SAY_NETMSG, "No matter how much you try, you can't regenerate the world.");
        return;
    }

    player.Say(SAY_NETMSG, "Safe-regenerating the location...");

    Location@   loc = map.GetLocation();
    array<Map@> maps;
    uint        numMaps = loc.GetMaps(maps);

    // buffer container
    Item@       buffer = player.AddItem(PID_LOCKER_CLEAN_LEFT, 1);
    // pids of containers
    array<uint> pids;

    // move items that we want to save
    for(uint i = 0; i < numMaps; i++)
    {
        for(uint16 x = 0; x < maps[i].GetWidth(); x++)
        {
            for(uint16 y = 0; y < maps[i].GetHeight(); y++)
            {
                array<Item@> items;
                uint         num = maps[i].GetItems(x, y, items);
                for(uint j = 0; j < num; j++)
                {
                    if(items[j].GetType() == ITEM_TYPE_CONTAINER)                       // TODO: additional checks
                    {
                        pids.insertLast(items[j].GetProtoId());
                        // move it to our container, with special id being calculated from coords
                        MoveItem(items[j], 0, buffer, maps[i].GetHeight() * y + x);
                    }
                }
            }
        }

        array<Critter@> crits;
        uint            num = maps[i].GetCritters(0, FIND_ALL | FIND_ONLY_NPC, crits);
        for(uint i = 0; i < num; i++)
        {
            if(!_IsFollower(crits[i]))
                continue;

            TransferToNPCMap(crits[i]);
        }
    }
    loc.Reload();
    // place them back
    for(uint i = 0; i < numMaps; i++)
    {
        array<Critter@> crits;
        uint            num = maps[i].GetCritters(0, FIND_ALL | FIND_ONLY_NPC, crits);
        for(uint i = 0; i < num; i++)
            crits[i].ChangeCrType(crits[i].StatBase[ST_BASE_CRTYPE]);

        for(uint16 x = 0; x < maps[i].GetWidth(); x++)
        {
            for(uint16 y = 0; y < maps[i].GetHeight(); y++)
            {
                array<Item@> items;
                uint         num = maps[i].GetItems(x, y, items);
                if(num > 0)
                {
                    for(uint j = 0; j < num; j++)
                    {
                        if(items[j].GetType() == ITEM_TYPE_CONTAINER)                           // TODO: additional checks
                        {
                            // move it to our container, with special id being calculated from coords
                            Item@        oldContainer = buffer.GetItem(items[j].GetProtoId(), maps[i].GetHeight() * y + x);
                            array<Item@> content;
                            uint         contentCount = oldContainer.GetItems(0, content);
                            for(uint k = 0; k < contentCount; k++)
                            {
                                MoveItem(content[k], 0, items[j], 0);
                            }
                        }
                    }
                }
                // spawn new container
                else
                {
                    // Item@ item = maps[i].AddItem(x, y, pid, 1);
                    // move items to it
                    // MoveItemsContainers(buffer, item, maps[i].GetHeight() * y + x, 0);
                }
            }
        }
    }
    DeleteItem(buffer);
    player.Say(SAY_NETMSG, "Done.");
}

/**
 * Removes certain items from current map or globally.
 */
void ExecRemoveItemsCommand(array<string@>@ command, Critter@ player)
{
    player.Say(SAY_NETMSG, "Executing RemoveItems command");
    int pid = 0;
    if(command.length() < 3)
    {
        player.Say(SAY_NETMSG, "Wrong number of parameters");
        return;
    }

    bool deleteAll = (GetIndexOfString(command, "-global") != -1);

    // try to parse pid if it was passed as number
    bool parsed = StrToInt(command[2], pid);
    // otherwise, check in the global dictionary
    if(!parsed)
    {
        if(!GetItemPid(command[2], pid))
        {
            player.Say(SAY_NETMSG, "Item does not exist");
            return;
        }
    }
    uint num = 0;
    if(pid != 0)
    {
        array<Item@> items;
        if(deleteAll)
        {
            player.Say(SAY_NETMSG, "Removing ALL items with pid: " + pid);
            num = GetAllItems(pid, items);
        }
        else
        {
            player.Say(SAY_NETMSG, "Removing items with pid: " + pid);
            Map@ map = player.GetMap();
            if(!valid(map))
            {
                player.Say(SAY_NETMSG, "Can't delete local items while on worldmap.");
                return;
            }
            num = map.GetItems(pid, items);
        }

        DeleteItems(items);
        player.Say(SAY_NETMSG, "Done - removed " + num + " items.");
    }
    else
        player.Say(SAY_NETMSG, "Please specify proto id number.");
}
/**
 * Count items with given pid.
 */
void ExecCountItemsCommand(array<string@>@ command, Critter@ player)
{
    int pid = 0;
    if(command.length() < 3)
    {
        player.Say(SAY_NETMSG, "Wrong number of parameters");
        return;
    }
    // try to parse pid if it was passed as number
    bool parsed = StrToInt(command[2], pid);
    // otherwise, check in the global dictionary
    if(!parsed)
    {
        if(!GetItemPid(command[2], pid))
        {
            player.Say(SAY_NETMSG, "Item does not exist");
            return;
        }
    }
    uint num = 0;
    uint totalNum = 0;
    if(pid != 0)
    {
        array<Item@> items;
        num = GetAllItems(pid, items);
        if(num > 0)     // count number of items, not Item instances
        {
            for(uint i = 0; i < num; i++)
                totalNum += items[i].IsStackable() ? items[i].GetCount() : 1;
        }
        player.Say(SAY_NETMSG, "Number of items with pid(" + pid + "): |0xffffffff " + num + ".");
        uint totalCount = WorldItemCount(pid);
        if(totalNum > 0 || totalCount > 0)
            player.Say(SAY_NETMSG, "Total number: |0xffffffff " + totalNum + " or " + totalCount + ".");
    }
    else
        player.Say(SAY_NETMSG, "Please specify proto id number.");
}
/**
 * Counts the item of value kept in banks/encounter store.
 */
void ExecVirtualMoneyCommand(array<string@>@ command, Critter@ player)
{
    uint banks = BanksGetTotalMoney();
    int  encounters = WorldmapGetTotalValue();

    player.Say(SAY_NETMSG, "Money kept in banks: " + banks);
    player.Say(SAY_NETMSG, "Value in encounters store: " + encounters);
    player.Say(SAY_NETMSG, "--------");
    uint sum = banks + encounters;
    player.Say(SAY_NETMSG, "Total: " + sum);
}
/**
 * Checking/modifying zones' values.
 */
void ExecZoneCommand(array<string@>@ command, Critter@ player)
{
    int    v = 0;
    IZone@ zone = GetZone(player.WorldX, player.WorldY);
    // add value directly
    if(StrToInt(GetParameterString(command, "-a"), v))
    {
        zone.AddValue(v);
        player.Say(SAY_NETMSG, "Added " + v + " to zone's value.");
    }
    else if(StrToInt(GetParameterString(command, "-i"), v))
    {
        // InjectValue(player.WorldX, player.WorldY, v, INJECTVALUE_CHEATS);
        player.Say(SAY_NETMSG, "Injected " + v + " to nearby encounters' store.");
    }
    else if(StrToInt(GetParameterString(command, "-r"), v))
    {
        zone.SubValue(v);
        player.Say(SAY_NETMSG, "Substracted " + v + " from zone's value.");
    }
    else if(StrToInt(GetParameterString(command, "-s"), v))
    {
        zone.SetValue(v);
        player.Say(SAY_NETMSG, "Set zone's value to: " + v);
    }
    else
    {
        player.Say(SAY_NETMSG, "Current zone's value: " + zone.GetValue());
    }
}

void ExecSuicideCommand(array<string@>@ command, Critter@ player)
{
    player.Say(SAY_NETMSG, "Goodbye cruel world...");
    player.ToDead(GetRandomDeathAnimation(), null);
}

void ExecGetLeaderTimeCommand(array<string@>@ command, Critter@ player)
{
    uint faction = GetGroupIndex(player);
    if(faction == FACTION_NONE)
        player.Say(SAY_NETMSG, "You are not member of any faction");
    else
        player.Say(SAY_NETMSG, "Leader time left: " + (GetLeaderTime(faction) - ELAPSED_TIME));
}

void ExecGetClaimTimeCommand(array<string@>@ command, Critter@ player)
{
    uint faction = GetGroupIndex(player);
    if(faction == FACTION_NONE)
        player.Say(SAY_NETMSG, "You are not member of any faction");
    else
        player.Say(SAY_NETMSG, "Claim time left: " + (GetClaimTime(faction) - ELAPSED_TIME));
}

void ExecGetClaimCommand(array<string@>@ command, Critter@ player)
{
    uint faction = GetGroupIndex(player);
    if(faction == FACTION_NONE)
        player.Say(SAY_NETMSG, "You are not member of any faction");
    else
    {
        uint id = GetClaimId(faction);
        if(id == 0)
            player.Say(SAY_NETMSG, "No claim");
        else
            player.Say(SAY_NETMSG, "Claimee: " + GetSafePlayerName(id));
    }
}

void ExecMakeEncounterCommand(array<string@>@ command, Critter@ player)
{
    Map@ map = player.GetMap();
    if(!valid(map))
    {
        player.Say(SAY_NETMSG, "Not on the worldmap");
        return;
    }

    // verify the map
    if(map.GetData(MAP_DATA_FACTION) != 0)
    {
        player.Say(SAY_NETMSG, "This map belongs to a faction. Cannot force the encounter.");
        return;
    }

    map.SetEvent(MAP_EVENT_LOOP_4, "_ForceEncounter");
    map.SetLoopTime(4, 5000);
}

void ExecMapInfoCommand(array<string@>@ command, Critter@ player)
{
    int id = 0;
    StrToInt(GetParameterString(command, "-m"), id);

    player.Say(SAY_NETMSG, (id == 0 ? "Listing information about this map:" : "Listing information about map " + id + ":"));
    if(id == 0)
        id = player.GetMapId();
    Map@ map = GetMap(id);
    if(!valid(map))
    {
        player.Say(SAY_NETMSG, "Invalid map.");
        return;
    }
    Location@ loc = map.GetLocation();

    player.Say(SAY_NETMSG, "Map Id: " + id);
    player.Say(SAY_NETMSG, "Map PID: " + map.GetProtoId());
    player.Say(SAY_NETMSG, "Location PID: " + loc.GetProtoId());

    if(IsTent(map))
    {
        string@ owner = GetSafePlayerName(map.GetData(MAP_DATA_TENT_OWNER));
        player.Say(SAY_NETMSG, "This is a tent map, owned by: " + owner + " (" + map.GetData(MAP_DATA_TENT_OWNER) + ")");
    }
    if(map.GetData(MAP_DATA_SPAWNER) > 0)
    {
        string@ spawner = GetSafePlayerName(map.GetData(MAP_DATA_SPAWNER));
        player.Say(SAY_NETMSG, "This map was spawned by: " + spawner + " (" + map.GetData(MAP_DATA_SPAWNER) + ") " + ((ELAPSED_TIME - map.GetData(MAP_DATA_CREATED_ON)) / (60 * 60)) + " hours ago.");
    }
    if(_MapHasMode(map, MAP_MODE_SPECTATE_FREELY))
        player.Say(SAY_NETMSG, "Spectation is enabled on this map.");
    if(_MapHasMode(map, MAP_MODE_NO_DISMANTLING))
        player.Say(SAY_NETMSG, "Dismantling is disabled on this map.");
    if(_MapHasMode(map, MAP_MODE_NO_PVP))
        player.Say(SAY_NETMSG, "PvP is disabled on this map.");
    if(_MapHasMode(map, MAP_MODE_NO_GRIDS))
        player.Say(SAY_NETMSG, "Exit grids are disabled on this map.");
}

void ExecGetLeaderCommand(array<string@>@ command, Critter@ player)
{
    uint faction = GetGroupIndex(player);
    if(faction == FACTION_NONE)
        player.Say(SAY_NETMSG, "You are not member of any faction");
    else
    {
        uint id = GetLeaderId(faction);
        if(id == 0)
            player.Say(SAY_NETMSG, "No leader");
        else
            player.Say(SAY_NETMSG, "Leader: " + GetSafePlayerName(id));
    }
}

void ExecClearTimeoutsCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    player.Say(SAY_NETMSG, "Clearing timeouts");
    DropTimeouts(target);
}

void ExecClearAllTimeoutsCommand(array<string@>@ command, Critter@ player)
{
    player.Say(SAY_NETMSG, "Dropping timeouts for all online players.");
    array<Critter@> players;
    uint            num = GetAllOnlinePlayers(players);
    for(uint i = 0; i < num; i++)
    {
        DropTimeouts(players[i]);
    }
    player.Say(SAY_NETMSG, "Done.");
}

void ExecDeathIncarnateCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    player.Say(SAY_NETMSG, "Death walks the earth as " + target.Name);
    target.SetEvent(CRITTER_EVENT_SHOW_CRITTER, "_Kill");
}

void ExecNormalDeadlyCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    player.Say(SAY_NETMSG, target.Name + " is now a mere mortal again");
    target.SetEvent(CRITTER_EVENT_SHOW_CRITTER, "");
}

void ExecMoveCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    player.Say(SAY_NETMSG, "Move it, move it");
    // target.AddWalkPlane(player.HexX, player.HexY, 0, false, 0);
    target.MoveRandom();
}

void ExecKillMobsCommand(array<string@>@ command, Critter@ player)
{
    array<Critter@> critters;
    uint            num = player.GetCritters(false, FIND_ALL, critters);

    player.Say(SAY_NETMSG, "Killing all mobs in sight...");

    for(uint i = 0; i < num; i++)
    {
        if(critters[i].IsPlayer())
            continue;

        if(!critters[i].IsDead())
            critters[i].ToDead(GetRandomDeathAnimation(), null);
    }
}

void ExecRespawnCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    if(valid(target))
    {
        player.Say(SAY_NETMSG, "Raise!");
        if(target.IsPlayer() && target.GetAccess() == ACCESS_CLIENT)
            _CritUnsetMode(target, MODE_NO_LOOT);
        target.ToLife();
        Heal(target);
    }
}

void ExecRespawnAllCommand(array<string@>@ command, Critter@ player)
{
    array<Critter@> critters;
    uint            num = player.GetCritters(false, FIND_DEAD, critters);

    player.Say(SAY_NETMSG, "Respawning all critters in sight");

    for(uint i = 0; i < num; i++)
    {
        critters[i].ToLife();
        if(critters[i].IsPlayer() && critters[i].GetAccess() == ACCESS_CLIENT)
            _CritUnsetMode(critters[i], MODE_NO_LOOT);
    }
}

void ExecHealCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    if(valid(target))
    {
        player.Say(SAY_NETMSG, "Healing...");
        Heal(target);
    }
}

void ExecHealAllCommand(array<string@>@ command, Critter@ player)
{
    array<Critter@> critters;
    uint            num = player.GetCritters(false, FIND_LIFE, critters);

    player.Say(SAY_NETMSG, "Healing all critters in sight");

    for(uint i = 0; i < num; i++)
    {
        Heal(critters[i]);
    }
}

void ExecRespawnAllPlayersCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    array<Critter@> critters;
    uint            num = player.GetCritters(false, FIND_DEAD, critters);

    player.Say(SAY_NETMSG, "Respawning all players in sight");

    for(uint i = 0; i < num; i++)
    {
        if(!critters[i].IsPlayer())
            continue;
        critters[i].ToLife();
    }
}

void ExecDevEnableCommand(array<string@>@ command, Critter@ player)
{
    if(player.GetAccess() >= ACCESS_TESTER)
        player.RunClientScript("client_dev_menu@Authorize", 0, 0, 0, null, null);
}

void ExecAntiblockCommand(array<string@>@ command, Critter@ player)
{
    if(ItemOnHex(PID_TRIGGER, player.GetMap(), player.HexX, player.HexY))
    {
        player.Say(SAY_NETMSG, "Removing antiblock...");
        Item@ tr = player.GetMap().GetItem(player.HexX, player.HexY, PID_TRIGGER);
        if(GetTriggerFunction(tr) == TRIGGER_FUNC_ANTIBLOCK)
            DeleteItem(tr);
    }
    else
    {
        if(valid(player.GetMap()))
        {
            player.Say(SAY_NETMSG, "Placing antiblock...");
            Item@ tr = player.GetMap().AddItem(player.HexX, player.HexY, PID_TRIGGER, 1);
            TriggerInit(tr, TRIGGER_FUNC_ANTIBLOCK, 0, 2, 1);
        }
    }
}

/**
 * Places dynamic spawnpoint.
 */
void ExecSpawnPointCommand(array<string@>@ command, Critter@ player)
{

    Map@ map = player.GetMap();
    if(!valid(map))
    {
        player.Say(SAY_NETMSG, "Dynamic spawnpoints can't be created here.");
        return;
    }

    uint16 hx = player.HexX;
    uint16 hy = player.HexY;

    int    minigameTeam  = 0;
    int    minigameId    = 0;

    uint   capturableBy = 0;
    uint   captureFlags = 0;
    uint   captureTime  = 30;

    bool   visible  = false;

    bool   link = false;     // If true then link the new spawnpoint with spawnpoint
                             // with highest ID on the map. The new spawnpoint will
                             // have the other one set as "previous" and the previous
                             // one will have the new spawnpoint set as "next". This
                             // allows to create simple chains of spawnpoints without
                             // specifying IDs of previous/next spawnpoints.

    uint transportToMap = 0; // If > 0 and the spawnpoint is the last spawnpoint for
    // the team in the chain, then re-check spawnpoints on
    // linked map

    cheatGetOption(command, hx, "-x");
    cheatGetOption(command, hy, "-y");
    cheatGetOption(command, capturableBy, "-c");
    cheatGetOption(command, captureFlags, "-o");
    cheatGetOption(command, captureTime, "-s");
    cheatGetOption(command, visible, "-v");
    cheatGetOption(command, link, "-l");
    cheatGetOption(command, transportToMap, "-m");

    // Spawnpoint teams, minigame id 15 is used.
    string team = GetParameterString(command, "-t");
    if(team == "spectator" || team == "s")
        minigameId = 15;
    else if(StrToInt(team, minigameTeam))
    {
        minigameId = 15;
        minigameTeam = CLAMP(minigameTeam, 0, 15);
    }

    Item@ existing = map.GetItem(hx, hy, PID_RESPAWN_POINT);
    if(!valid(existing))
    {
        player.Say(SAY_NETMSG, "Placing respawn point...");

        // Grab the last spawnpoint on the map to create chains with -l
        Item@ lastDSpawn = null;
        if(link)
        {
            array<Item@> dSpawns;
            uint         dSpawnsNum = map.GetItems(PID_RESPAWN_POINT, dSpawns);
            if(dSpawnsNum > 0)
            {
                uint dSpawnsHighestId = 0;
                for(uint i = 0; i < dSpawnsNum; i++)
                {
                    if(dSpawns[i].Id > dSpawnsHighestId)
                        dSpawnsHighestId = dSpawns[i].Id;
                }
                @lastDSpawn = map.GetItem(dSpawnsHighestId);
            }
        }

        // Spawnpoints settings
        Item@ spawn = map.AddItem(hx, hy, PID_RESPAWN_POINT, 1);
        spawn.Val0 = (minigameId << 4) | minigameTeam;
        spawn.Val1 = (captureTime << 24) | (captureFlags << 16) | capturableBy;
        if(valid(lastDSpawn))
        {
            spawn.Val3 = lastDSpawn.Id;
            lastDSpawn.Val4 = spawn.Id;
        }
        spawn.Val5 = transportToMap;

        // Spawnpoint Colorization
        spawn.AnimStayBegin = minigameTeam;
        spawn.AnimStayEnd   = minigameTeam;
        spawn.AnimShowBegin = minigameTeam;
        spawn.AnimShowEnd   = minigameTeam;
        spawn.AnimHideBegin = minigameTeam;
        spawn.AnimHideEnd   = minigameTeam;

        // Initialize
        if(capturableBy > 0)
        {
            SETFLAG(spawn.Flags, ITEM_CAN_USE);
            // _DSpawn(spawn, true); // moved to proto
        }

        // Visibility
        if(visible)
        {
            UNSETFLAG(spawn.Flags, ITEM_HIDDEN);
            spawn.Update();
        }
    }
    else
    {
        player.Say(SAY_NETMSG, "Removing spawn point...");
        DeleteItem(existing);
    }
}

void ExecKillerAdminCommand(array<string@>@ command, Critter@ player)
{
    if(player.Mode[MODE_KILLER_ADMIN] > 0)
    {
        player.Say(SAY_NETMSG, "Normal admin");
        player.ModeBase[MODE_KILLER_ADMIN] = 0;

    }
    else
    {
        player.Say(SAY_NETMSG, "Killer admin");
        player.ModeBase[MODE_KILLER_ADMIN] = 1;
    }
}

void ExecHideMapCommand(array<string@>@ command, Critter@ player)
{
    Location@ loc = player.GetMap().GetLocation();
    loc.GeckVisible = false;
    loc.Visible = false;
    // loc.Save(true);

    array<Critter@> players;
    uint            num = GetAllOnlinePlayers(players);

    // Hide for all players
    for(uint i = 0; i < num; i++)
    {
        if(!valid(players[i]))
            continue;
        if(!players[i].IsPlayer())
            continue;

        players[i].SetKnownLoc(false, loc.Id);
    }
}

void ExecClearAllIllegalFlagsCommand(array<string@>@ command, Critter@ player)
{
    array<Critter@> players;
    uint            num = GetAllOnlinePlayers(players);
    for(uint i = 0; i < num; i++)
    {
        ClearIllegalFlags(players[i]);
    }
}

void ExecListAuthenticatedCommand(array<string@>@ command, Critter@ player)
{
    array<Critter@> players;
    uint            num = GetAllOnlinePlayers(players);
    for(uint i = 0; i < num; i++)
    {
        if(!GodOfTheRealm(player.Id) && GodOfTheRealm(players[i].Id) && _CritHasExtMode(players[i], MODE_EXT_GOD))
            continue;

        if(players[i].GetAccess() == ACCESS_CLIENT)
            continue;

        if(player.GetAccess() < players[i].GetAccess())
            continue;

        player.Say(SAY_NETMSG, GetSafePlayerName(players[i].Id) + " (" + players[i].Id + ")" + "(" + players[i].GetMapId() + ") - " + GetAuthString(players[i]));
    }
}

void ExecResetAllDisguisesCommand(array<string@>@ command, Critter@ player)
{
    player.Say(SAY_NETMSG, "Resetting basetypes for all players online...");
    array<Critter@> players;
    uint            num = GetAllOnlinePlayers(players);
    for(uint i = 0; i < num; i++)
    {
        bool  isMale = (players[i].StatBase[ST_GENDER] == GENDER_MALE);
        uint  baseType = (isMale ? CRTYPE_MALE_DEFAULT : CRTYPE_FEMALE_DEFAULT);
        uint  crType = baseType;
        Item@ armor = players[i].GetItem(0, SLOT_ARMOR);

        if(valid(armor))
        {
            switch(GetCritterAnimType(crType))
            {
            case ANIM_TYPE_FALLOUT:
                crType = (isMale ? armor.Proto.Armor_CrTypeMale : armor.Proto.Armor_CrTypeFemale);
                break;
                /*
                   case ANIM_TYPE_3D:
                        crType = ???;
                        break;
                 */
            }
        }

        players[i].ChangeCrType(crType);
        players[i].StatBase[ST_BASE_CRTYPE] = baseType;
        players[i].DisguisedBy = 0;
    }
    player.Say(SAY_NETMSG, "Done.");
}

//
// TODO: abused, addictions should be kept or command disabled
//
void ExecDropDrugsCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    player.Say(SAY_NETMSG, "Removing drug effects from: " + target.Name);
    DropDrugEffects(target, true);
}

void ExecZonePlayersCommand(array<string@>@ command, Critter@ player)
{
    array<Critter@>@ players = WorldmapGetPlayers(ZONE_X(player.WorldX), ZONE_Y(player.WorldY));
    player.Say(SAY_NETMSG, "" + players.length() + " players in zone:");
    for(uint i = 0, j = players.length(); i < j; i++)
        player.Say(SAY_NETMSG, players[i].Name);
}

void ExecListCommandsCommand(array<string@>@ command, Critter@ player)
{
    if(IsAdmin(player))
    {
        for(uint i = 0, j = commandlist.length(); i < j; i++)
            player.Say(SAY_NETMSG, commandlist[i]);
    }
    else if(IsGM(player))
    {
        for(uint i = 0, j = gmcommandlist.length(); i < j; i++)
            player.Say(SAY_NETMSG, gmcommandlist[i]);
    }
    else
    {
        for(uint i = 0, j = testercommandlist.length(); i < j; i++)
            player.Say(SAY_NETMSG, testercommandlist[i]);
    }
}

uint GMTrack(uint targetId, string@ message)   // Export
{
    if(targetId == 0 || GodOfTheRealm(targetId) ||
       !valid(message) || message.length() == 0)
        return(0);

    IConfigVar@ var = GetConfigVar(CHEATS_CFG, CFG_TRACKING, "" + targetId);

    if(!valid(var))
        return(0);

    array<string@>@ hunters = split(var.GetValue(), ",");
    if(hunters.length() == 0)
        return(0);

    Critter@ target = GetCritter(targetId);
    if(!valid(target))
        return(0);

    uint color = uint(4291317840);
    stringReplaceText(message, "TARGET", target.Name + "(" + target.Id + ")");

    uint huntersFound = 0;
    for(uint h = 0, hcount = hunters.length(); h < hcount; h++)
    {
        uint hunterId = 0;
        if(!StrToInt(hunters[h], hunterId))
            continue;

        if(hunterId == 0)
            continue;

        Critter@ hunter = GetCritter(hunterId);
        if(!valid(hunter))
            continue;

        if(GodOfTheRealm(target.Id) || target.GetAccess() > target.GetAccess())
        {
            target.Say(SAY_NETMSG, "|" + color + " > " + hunter.Name + " was trying to track you when you was offline.");
            IConfigVar@ var = GetConfigVar(CHEATS_CFG, CFG_TRACKING, "" + target.Id);
            if(!valid(var))
            {
                target.Say(SAY_NETMSG, "|" + color + " > Error #1 during removing you from list.");
            }
            else
            {
                array<string> innocent = var.GetValueAsArray(",");
                remove_all_from_array(innocent, "" + target.Id);
                if(Present("" + target.Id, innocent))
                {
                    target.Say(SAY_NETMSG, "|" + color + "> Error #2 during removing you from list.");
                }
                else
                {
                    remove_duplicates_from_array(innocent, array<string>);
                    innocent.sortAsc();
                    var.SetValue(innocent);
                    SaveConfig(CHEATS_CFG);
                    target.Say(SAY_NETMSG, "|" + color + "> Successfully removed you from list.");
                }
            }
            continue;
        }

        hunter.Say(SAY_NETMSG, "|" + color + " > " + message);
        huntersFound++;
    }

    return(huntersFound);
}

Critter@ GetCritterArgument(array<string@>& command)
{
    Critter@ target = null;

    uint     id = 0;
    string   targetName = GetParameterString(command, "-p");
    string   npcId = GetParameterString(command, "-n");
    StrToInt(targetName, id);

    if(targetName != "")
    {
        if(id == 0)
            @target = GetPlayer(targetName);
        else
            @target = GetCritter(id);

    }
    if(npcId != "")
    {
        StrToInt(npcId, id);
        if(id != 0)
            @target = GetCritter(NPC_BASE_ID + id);
    }

    return(target);
}

void ExecTrackPlayerCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    string offline = GetParameterString(command, "-offline");

    if(offline.length() == 0)
    {
        if(player.Id == target.Id)
        {
            player.Say(SAY_NETMSG, "Invalid target. Use trackplayer -offline [target name] to track not logged player.");
            return;
        }
    }
    else
    {
        uint id = GetPlayerId(offline);
        if(id == 0)
        {
            player.Say(SAY_NETMSG, "No such player exists in this world.");
            return;
        }

        return;
    }

    if(GodOfTheRealm(target.Id) || player.GetAccess() < target.GetAccess())
    {
        player.Say(SAY_NETMSG, "You are not authorized to track this person.");
        target.Say(SAY_NETMSG, player.Name + " was trying to track you.");
        return;
    }

    IConfigVar@   var = GetConfigVar(CHEATS_CFG, CFG_TRACKING, "" + target.Id);
    array<string> hunters = var.GetValueAsArray(",");

    if(Present("" + player.Id, hunters))
    {
        player.Say(SAY_NETMSG, "You are already tracking that person.");
        return;
    }

    hunters.insertLast("" + player.Id);
    remove_duplicates_from_array(hunters, array<string>);
    hunters.sortAsc();
    var.SetValue(hunters);
    SaveConfig(CHEATS_CFG);

    player.Say(SAY_NETMSG, "You are now tracking " + target.Name);
}

void ExecStopTrackPlayerCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    if(player.Id == target.Id)
    {
        player.Say(SAY_NETMSG, "Target not found.");
        return;
    }

    player.Say(SAY_NETMSG, "You've now stopped tracking " + target.Name);
    SetLvar(target, LVAR_command_tracking, 0);
}

void ExecListTrackedPlayersCommand(array<string@>@ command, Critter@ player)
{
    array<Critter@> players;
    uint            num = GetAllOnlinePlayers(players);

    for(uint i = 0; i < num; i++)
    {
        if(players[i].GetAccess() == ACCESS_ADMIN)
            continue;

        uint id = GetLvar(players[i], LVAR_command_tracking);
        if(id != 0)
        {
            Critter@ tracker = GetCritter(id);
            if(valid(tracker) && player.GetAccess() < tracker.GetAccess())
                continue;

            player.Say(SAY_NETMSG, GetSafePlayerName(players[i].Id) + " is tracked by " + GetSafePlayerName(id));
        }
    }
}

void ExecRotateCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    int dir = Random(0, 5);
    StrToInt(GetParameterString(command, "-dir"), dir);

    if(target.IsNpc())
        target.SetHomePos(target.HexX, target.HexY, dir);
    target.SetDir(dir);
}

void ExecStartEventCommand(array<string@>@ command, Critter@ player)
{
    SetGvar(GVAR_event_status, 1);
    player.Say(SAY_NETMSG, "Event started, all critters and items added from this point can be deleted by stopping event.");
}

void ExecStopEventCommand(array<string@>@ command, Critter@ player)
{
    SetGvar(GVAR_event_status, 0);
    uint numdelete = 0;
    for(uint i = 0; i < eventCritters.length(); i++)
    {
        Critter@ cr = GetCritter(eventCritters[i]);
        if(valid(cr))
        {
            DeleteNpc(cr);
            numdelete++;
        }
    }
    eventCritters.resize(0);

    player.Say(SAY_NETMSG, "Deleted " + numdelete + " critter that were part of the event.");

    numdelete = 0;
    for(uint y = 0; y < eventItems.length(); y++)
    {
        Item@ item = ::GetItem(eventItems[y]);
        if(valid(item))
        {
            DeleteItem(item);
            numdelete++;
        }
    }
    eventItems.resize(0);

    player.Say(SAY_NETMSG, "Deleted " + numdelete + " items that were part of the event.");
    player.Say(SAY_NETMSG, "Event cleanup completed.");
}

void PrintTentList(Critter& player, Critter& target, bool short)
{
    int tentid = GetLvar(target, LVAR_tent_id);
    if(tentid == 0)
        player.Say(SAY_NETMSG, target.Name + " has no tent.");
    else
    {
        Location@ loc = GetLocation(tentid);
        if(valid(loc))
        {
            Map@ map = loc.GetMapByIndex(0);
            if(valid(map))
            {
                if(short)
                    player.Say(SAY_NETMSG, target.Name + " - (" + map.Id + ")(" + map.GetProtoId() + ")");
                else
                {
                    player.Say(SAY_NETMSG, "Tent info for " + target.Name + ": ");
                    player.Say(SAY_NETMSG, "Map ID: " + map.Id);
                    player.Say(SAY_NETMSG, "Map PID: " + map.GetProtoId());
                }
            }
        }
        else
        {
            player.Say(SAY_NETMSG, target.Name + " has no tent.");
        }
    }
}

void ExecTentInfoCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    PrintTentList(player, target, false);
}

void ExecTentListCommand(array<string@>@ command, Critter@ player)
{
    array<Critter@> players;
    uint            num = GetAllOnlinePlayers(players);
    player.Say(SAY_NETMSG, "<Name> - (<MapID>)(<MapPID>)");
    for(uint i = 0; i < num; i++)
        PrintTentList(player, players[i], true);
}

void ExecListMapsCommand(array<string@>@ command, Critter@ player)
{
    uint pid = 0;
    StrToInt(GetParameterString(command, "-pid"), pid);

    if(pid > 0)
    {
        array<Map@> maps;
        uint        num = GetAllMaps(0, maps);
        if(num == 0)
        {
            player.Say(SAY_NETMSG, "No maps found for PID " + pid);
            return;
        }
        if(valid(maps))
        {
            for(uint x = 0; x < num; x++)
            {
                if(valid(maps[x]))
                {
                    if(maps[x].GetProtoId() == pid)
                    {
                        player.Say(SAY_NETMSG, "PID " + pid + ": " + maps[x].Id);
                    }
                }
            }
        }
    }
}

void ExecShowHandsCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    uint8 dummy = 0;
    for(int s = SLOT_HAND1; s < SLOT_GROUND; s++)
    {
        Item@ item = target.GetItem(0, s);
        if(valid(item))
        {
            string slot = "Slot";
            switch(s)
            {
            case SLOT_HAND1:
                slot = "Active hand";
                break;
            case SLOT_HAND2:
                slot = "Second hand";
                break;
            case SLOT_ARMOR:
                slot = "Armor";
                break;
            case SLOT_HEAD:
                slot = "Helmet";
                break;
            case SLOT_TROPHY:
                slot = "Trophy";
                break;
            }
            string name = "";             // TODO
            player.Say(SAY_NETMSG, slot + "(" + s + "): " + name + " (" + item.GetProtoId() + "," + item.Id + ")");
        }
    }
}

void ExecNameToIdCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    if(target.Id > 0)
        player.Say(SAY_NETMSG, "Player(" + GetSafePlayerName(target.Id) + "): " + target.Id);
    else
        player.Say(SAY_NETMSG, "Player doesn't exist.");
}

void ExecIdToNameCommand(array<string@>@ command, Critter@ player)
{
    uint id = 0;
    if(command.length() < 3)
        return;
    StrToInt(command[2], id);
    string name = GetSafePlayerName(id);
    if(name == "[player not found]")
        player.Say(SAY_NETMSG, "Player don't exists.");
    else
        player.Say(SAY_NETMSG, "Player(" + id + "): " + name);
}

void ExecListFollowersCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    uint count = 0;
    bool first = true;
    for(uint i = FOLLOWER_BEGIN; i <= FOLLOWER_END; i++)
    {
        if(target.Followers[i] != 0)
        {
            Critter@ cr = GetCritter(target.Followers[i]);
            if(!valid(cr))
            {
                target.FollowersBase[i] = 0;
                continue;
            }

            if(first)
            {
                player.Say(SAY_NETMSG, "Listing " + GetSafePlayerName(target.Id) + "'s followers:");
                first = false;
            }
            player.Say(SAY_NETMSG, "Follower #" + (i - FOLLOWER_BEGIN + 1) + ": " + (target.Followers[i]));   // removed that -5000000 it's not intuitive
            count++;
        }
    }
    if(first)
        player.Say(SAY_NETMSG, GetSafePlayerName(target.Id) + " has no followers.");
}

#define BLOCKER_VIS      (PID_PLAYERS_EAR)
#define BLOCKER_INVIS    (PID_UNVISIBLE_BLOCK)

// SAY COLORS
//
#define SCOLOR_ERROR     "|0xCC0000 "    // Error message
#define SCOLOR_ERRORB    "|0xFF4400 "    // Strong error emphasis ("bold")

#define SCOLOR_HELP      "|0xBBBBBB "    // Help message
#define SCOLOR_HELPH     "|0xFFFFFF "    // Healp header
#define SCOLOR_HELPB     "|0x00FFFF "    // Strong help emphasis ("bold")
#define SCOLOR_HELPI     "|0x00BBBB "    // Weak help emphasis ("italic")


////////////////////////////////////////////////////////////////////////////////
//
//  B L O C K E R S
//
////////////////////////////////////////////////////////////////////////////////

//  Sets / changes prototype of a blocker: visible oe invisible
//  Called after a blocker is created or when visibility changes
//  Returns false if can't change prototype
//
bool BlockerSetProto(Item@ blocker, bool visible)
{
    bool success = false;

    if(visible)
    {
        if(blocker.ChangeProto(BLOCKER_VIS))
        {
            SETFLAG(blocker.Flags, ITEM_BAD_ITEM);
            success = true;
        }
    }
    else
    {
        if(blocker.ChangeProto(BLOCKER_INVIS))
        {
            UNSETFLAG(blocker.Flags, ITEM_BAD_ITEM);
            success = true;
        }
    }
    UNSETFLAG(blocker.Flags, ITEM_NO_BLOCK);
    UNSETFLAG(blocker.Flags, ITEM_CAN_USE);
    UNSETFLAG(blocker.Flags, ITEM_CAN_PICKUP);
    blocker.Val8 = SPECIAL_ITEM_BLOCKER;
    blocker.Update();
    return success;
}

//  Creates a single blocker
//  This function should be used by all methods of creating blockers
//  Returns false if fails to create a blocker.
//
bool BlockerCreate(Critter@ creator, Map@ map, uint16 x, uint16 y, int group, bool safe, bool visible)
{
    Item@ blocker = map.AddItem(x, y, BLOCKER_INVIS, 1);

    if(valid(blocker))
    {
        blocker.Val4 = group;
        creator.Say(SAY_NETMSG, "      Blocker created at hex " + x + "," + y);
        if(BlockerSetProto(blocker, visible) == false)
        {
            creator.Say(SAY_NETMSG, SCOLOR_ERROR + "WARNING: Can't change proto of blocker at hex: " + x + "," + y);
        }
        if(safe)
        {
            UNSETFLAG(blocker.Flags, ITEM_SHOOT_THRU);
        }
        return true;
    }
    else
    {
        creator.Say(SAY_NETMSG, SCOLOR_ERROR + "WARNING: Can't spawn blocker at hex: " + x + "," + y);
        return false;
    }
}

//  Deletes a group of blockers or all blockers with specific pid
//
void BlockerDelete(Critter@ deleter, uint16 pid, uint group, bool deleteAll)
{

    Map@         blockerMap = deleter.GetMap();

    array<Item@> blockers;
    uint         blockersNum = blockerMap.GetItems(pid, blockers);

    for(uint i = 0; i < blockersNum; i++)
    {
        if(uint(blockers[i].Val8) == SPECIAL_ITEM_BLOCKER && (deleteAll || uint(blockers[i].Val4) == group))
        {
            deleter.Say(SAY_NETMSG, "Removing blocker [" + blockers[i].Val4 + "]: " + blockers[i].HexX + "," + blockers[i].HexY);
            blockerMap.RunEffect(PID_EXPLODE_EMP, blockers[i].HexX, blockers[i].HexY, 0);
            DeleteItem(blockers[i]);
        }
    }

}

//    Execute Blockers Command
//
void ExecBlockersCommand(array<string@>@ command, Critter@ player, Critter@ target)
{

    //    Default arguments
    //
    string argSubcommand = "help";

    //    Read the arguments
    //
    if(command.length() > 2)
    {
        argSubcommand = command[2];
    }

    //    Special warning, detects old "all" format
    //    Can be removed in the future.
    //
    if(command.length() > 3)
    {
        if(command[3] == "all")
        {
            player.Say(SAY_NETMSG, SCOLOR_ERROR + "WARNING: Deprecated argument.");
            player.Say(SAY_NETMSG, SCOLOR_ERROR + "Use " + SCOLOR_ERRORB + "-all " + SCOLOR_ERROR + "option instead to select all blockers.");
            return;
        }
    }

    //    Default options
    //
    Map@   optMap      = player.GetMap();
    uint16 optX      = target.HexX;
    uint16 optY      = target.HexY;
    uint   optGroup    = 0;
    uint   optRadius   = 1;
    bool   optSafe     = false;
    bool   optVisible  = false;
    bool   optAll      = false;

    /////////////////////////////////////////////////////////////////////////////////////////
    //
    //    COMMAND BLOCKERS HELP
    //    In-game help.    Termporary, to be replaced by proper help system.
    //
    if(argSubcommand == "help" || argSubcommand == "-help")
    {
        player.Say(SAY_NETMSG, "------------------------------------------\n" + SCOLOR_HELPH + "   command blockers");
        string shelp =      "------------------------------------------\n"
                       SCOLOR_HELP +   "Allows blocking hexes to prevent players from accessing places, critters or items on a map.\n"
                       SCOLOR_HELPH +  "Syntax:\n"
                       SCOLOR_HELPB +  "`blockers [subcommand] (options)\n"
                       SCOLOR_HELPH +  "Arguments:\n"
                       SCOLOR_HELPB +  "[subcommand]"
                       SCOLOR_HELP +   " : Specifies blocker action to perform. Possible values:\n"
                       SCOLOR_HELPI +  "    add"
                       SCOLOR_HELP +   " : Create a single blocker on a hex\n"
                       SCOLOR_HELPI +  "    around"
                       SCOLOR_HELP +   " : Create blockers around a hex\n"
                       SCOLOR_HELPI +  "    to"
                       SCOLOR_HELP +   " : Create line of blockers to a hex\n"
                       SCOLOR_HELPI +  "    delete"
                       SCOLOR_HELP +   " : Delete blockers\n"
                       SCOLOR_HELPI +  "    show"
                       SCOLOR_HELP +   " : Make blockers visible\n"
                       SCOLOR_HELPI +  "    hide"
                       SCOLOR_HELP +   " : Make blockers invisible\n"
                       SCOLOR_HELPI +  "    list"
                       SCOLOR_HELP +   " : Display list of blockers\n"
                       SCOLOR_HELPH +  "Options:\n"
                       SCOLOR_HELPB +  "-g [group]"
                       SCOLOR_HELP +   " : Specify group of created blockers (add, around) or perform a command on all blockers in the group (delete, show, hide, list)\n"
                       SCOLOR_HELPB +  "-all"
                       SCOLOR_HELP +   " : Perform a command on all blockers in the map (delete, show, hide, list)\n"
                       SCOLOR_HELPB +  "-x [hexx] -y [hexy]"
                       SCOLOR_HELP +   " : Coordinates of created blocker (add) or center of blocker hexagon (around) or end of blocker line (to)\n"
                       SCOLOR_HELPB +  "-r [radius]"
                       SCOLOR_HELP +   " : Radius of blocker hexagon (around)\n"
                       SCOLOR_HELPB +  "-p [id]"
                       SCOLOR_HELP +   " : Id of player to block or use the player coords as line end (around, to)\n"
                       SCOLOR_HELPB +  "-n [id]"
                       SCOLOR_HELP +   " : Id of NPC to block or use the NPC coords as line end (around, to)\n"
                       SCOLOR_HELPB +  "-s"
                       SCOLOR_HELP +   " : Created blockers will block aim (add, around)\n"
                       SCOLOR_HELPB +  "-v"
                       SCOLOR_HELP +   " : Created blockers will be visible (add, around, to)";
        player.Say(SAY_NETMSG, shelp);
        return;
    }

    //  If player is on global map, return
    //
    if(!valid(optMap))
    {
        player.Say(SAY_NETMSG, SCOLOR_ERROR + "WARNING: Can't block whole California, sorry.");
        return;
    }

    //  COMMAND BLOCKERS ADD
    //  Place a single blocker on target hex.
    //
    else if(argSubcommand == "add")
    {
        cheatGetOption(command, optX, "-x");
        cheatGetOption(command, optY, "-y");
        player.Say(SAY_NETMSG, "Placing a blocker at hex " + optX + "," + optY);
        player.Say(SAY_NETMSG, "   Group: " + cheatGetOption(command, optGroup, "-g"));
        player.Say(SAY_NETMSG, "   Safe: " + cheatGetOption(command, optSafe, "-s"));
        player.Say(SAY_NETMSG, "   Visible: " + cheatGetOption(command, optVisible, "-v"));

        BlockerCreate(player, optMap, optX, optY, optGroup, optSafe, optVisible);
    }

    //  COMMAND BLOCKERS AROUND
    //  Place a hexagon of blockers around the target hex.
    //
    else if(argSubcommand == "around")
    {
        cheatGetOption(command, optX, "-x");
        cheatGetOption(command, optY, "-y");
        player.Say(SAY_NETMSG, "Placing blockers around hex " + optX + "," + optY);
        player.Say(SAY_NETMSG, "   Group: " + cheatGetOption(command, optGroup, "-g"));
        player.Say(SAY_NETMSG, "   Radius: " + cheatGetOption(command, optRadius, "-r"));
        player.Say(SAY_NETMSG, "   Safe: " + cheatGetOption(command, optSafe, "-s"));
        player.Say(SAY_NETMSG, "   Visible: " + cheatGetOption(command, optVisible, "-v"));

        //  Prevent GM abuse: if radius == 0 hexagon can't be created
        //
        if(optRadius == 0)
        {
            player.Say(SAY_NETMSG, SCOLOR_ERROR + "ERROR: Can't create hexagon with radius 0");
            return;
        }

        uint16 stepX = optX;
        uint16 stepY = optY;

        //  Spawn hexagon of blockers
        //
        optMap.MoveHexByDir(stepX, stepY, 4, optRadius);
        for(uint8 stepDir = 0; stepDir < 6; stepDir++)
        {
            for(uint step = 0; step < optRadius; step++)
            {
                optMap.MoveHexByDir(stepX, stepY, stepDir, 1);
                BlockerCreate(player, optMap, stepX, stepY, optGroup, optSafe, optVisible);
            }
        }
    }

    //  COMMAND BLOCKERS TO
    //  Place a line of blockers from abuser to a x/y or other player/npc.
    //  The line will stop on walls.
    //
    else if(argSubcommand == "to")
    {
        cheatGetOption(command, optX, "-x");
        cheatGetOption(command, optY, "-y");
        player.Say(SAY_NETMSG, "Placing line of blockers to hex " + optX + "," + optY);
        player.Say(SAY_NETMSG, "   Group: " + cheatGetOption(command, optGroup, "-g"));
        player.Say(SAY_NETMSG, "   Visible: " + cheatGetOption(command, optVisible, "-v"));

        uint distance = GetDistantion(player.HexX, player.HexY, optX, optY);

        if(distance < 1)
        {
            player.Say(SAY_NETMSG, SCOLOR_ERROR + "ERROR: Can't create line with length 0");
            return;
        }

        //  Preserve the values because GetHexCoord will change them by reference.
        //
        uint16 saveX = optX;
        uint16 saveY = optY;

        //  Coords of previous hex, to check if it's the same (which means line hit an obstacle).
        //
        uint16 lastX = 0;
        uint16 lastY = 0;

        for(uint8 step = 1; step <= distance; step++)
        {
            optMap.GetHexCoord(player.HexX, player.HexY, optX, optY, 0.0f, step);
            if(lastX == optX && lastY == optY)
            {
                break;
            }
            BlockerCreate(player, optMap, optX, optY, optGroup, optSafe, optVisible);
            lastX = optX;
            lastY = optY;
            optX = saveX;
            optY = saveY;
        }
    }

    //  COMMAND BLOCKERS DELETE
    //  Removes blockers from current map
    //
    else if(argSubcommand == "delete" || argSubcommand == "remove")
    {
        cheatGetOption(command, optGroup, "-g");
        cheatGetOption(command, optAll, "-all");

        BlockerDelete(player, BLOCKER_VIS, optGroup, optAll);
        BlockerDelete(player, BLOCKER_INVIS, optGroup, optAll);
    }

    //  COMMAND BLOCKERS SHOW / COMMAND BLOCKERS HIDE
    //  Changing blocker proto
    //
    else if(argSubcommand == "show" || argSubcommand == "hide")
    {
        cheatGetOption(command, optGroup, "-g");
        cheatGetOption(command, optAll, "-all");

        uint16 proto = BLOCKER_INVIS;
        bool   show = true;
        if(argSubcommand == "hide")
        {
            proto = BLOCKER_VIS;
            show = false;
        }

        array<Item@> blockers;
        uint         blockersNum = optMap.GetItems(proto, blockers);

        for(uint i = 0; i < blockersNum; i++)
        {
            if(uint(blockers[i].Val8) == SPECIAL_ITEM_BLOCKER && (optAll || uint(blockers[i].Val4) == optGroup))
            {
                BlockerSetProto(blockers[i], show);
            }
        }
    }

    //  COMMAND BLOCKERS LIST
    //  Listing blockers
    //
    else if(argSubcommand == "list")
    {
        cheatGetOption(command, optGroup, "-g");
        cheatGetOption(command, optAll, "-all");

        array<Item@> blockers;
        uint         blockersNum = optMap.GetItems(0, blockers);
        uint         count = 0;

        for(uint i = 0; i < blockersNum; i++)
        {
            if(uint(blockers[i].Val8) == SPECIAL_ITEM_BLOCKER && (optAll || uint(blockers[i].Val4) == optGroup))
            {
                count += 1;
                player.Say(SAY_NETMSG, count + ". Blocker [" + blockers[i].Val4 + "]: " + blockers[i].HexX + "," + blockers[i].HexY);
            }
        }
    }

    //  UNKNOWN COMMAND
    //
    else
    {
        player.Say(SAY_NETMSG, SCOLOR_ERROR + "ERROR: Unknown argument: " + SCOLOR_ERRORB + argSubcommand);
        player.Say(SAY_NETMSG, SCOLOR_ERROR + "Type " + SCOLOR_ERRORB + "`blockers -help " + SCOLOR_ERROR + "to display command help.");
        return;
    }
}


void ExecLogCommand(array<string@>@ command, Critter@ player)
{
    string s = GetParameterString(command, "-m");
    if(s == "")
        player.Say(SAY_NETMSG, "No text specified. Did you forget to use -m?");
    FLog(LOG_COMMANDS, s);
    GMLog(player, " log call: " + s);
    /*file f;
       f.open("logs/gms/"+player.Name+".log", "a");
       f.writeString(GetCurrentDateTimeString()+" log call: "+s);
       f.close();*/
}

void ExecClearInventoryCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    array<Item@> items;
    int          count = target.GetItems(SLOT_INV, items);
    if(count > 0)
    {
        player.Say(SAY_NETMSG, "Removing " + count + " items from " + target.Name);
        _CritAnimateUse(player);
        DeleteItems(items);
    }
    else
        player.Say(SAY_NETMSG, target.Name + " has no items!");
}

void ExecDropItemsCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    array<Item@> items;
    int          count = target.GetItems(SLOT_INV, items);
    if(count > 0)
    {
        player.Say(SAY_NETMSG, "Dropping " + count + " items from " + target.Name);
        _CritAnimatePickup(player);
        MoveItems(items, player.GetMap(), player.HexX, player.HexY);
    }
    else
        player.Say(SAY_NETMSG, "Nothing to drop.");
}

void ExecPickItemsCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    Map@         map = target.GetMap();
    array<Item@> items;
    if(valid(map))
    {
        int count = map.GetItems(target.HexX, target.HexY, items);
        if(count > 0)
        {
            player.Say(SAY_NETMSG, "Picking " + count + " items for " + target.Name);
            if(target.Id == player.Id)
                _CritAnimatePickup(player);
            else
                _CritAnimateUse(player);
            MoveItems(items, player);
        }
        else
            player.Say(SAY_NETMSG, "Nothing to pick up for " + target.Name + ".");
    }
    else
    {
        player.Say(SAY_NETMSG, "Target on worldmap.");
    }
}

// helper
// order: player -> [if not on worldmap -> [current map -> current location]] -> world
Item@ FindItem(Critter@ player, uint itemId)
{
    // check Mr.Hilary first
    Item@ item = player.GetItemById(itemId);
    if(valid(item))
    {
        #ifdef __DEBUG__
        player.Say(SAY_NETMSG, "Item found: inventory");
        #endif
        return(item);
    }

    // search on map...
    Map@ map = player.GetMap();
    if(valid(map))
    {
        uint homeMap = map.Id;
        @item = map.GetItem(itemId);
        if(valid(item))
        {
            #ifdef __DEBUG__
            player.Say(SAY_NETMSG, "Item found: current map");
            #endif
            return(item);
        }
        // ...location...
        Location@ location = map.GetLocation();
        if(valid(location))
        {
            for(uint m = 0; m < location.GetMapCount(); m++)
            {
                Map@ checkmap = location.GetMapByIndex(m);
                // don't waste time on already checked map
                if(checkmap.Id == homeMap)
                    continue;
                @item = checkmap.GetItem(itemId);
                if(valid(item))
                {
                    #ifdef __DEBUG__
                    player.Say(SAY_NETMSG, "Item found: current location, map " + m);
                    #endif
                    return(item);
                }
            }
        }
    }

    // ...and finally, whole world
    uint16       dummy = 0;
    array<Item@> items;
    uint         count = GetAllItems(dummy, items);
    for(uint i = 0; i < count; i++)
    {
        if(items[i].Id == itemId)
        {
            #ifdef __DEBUG__
            player.Say(SAY_NETMSG, "Item found: somewhere...");
            #endif
            return(items[i]);
        }
    }
    return(null);
}

uint[] item_flags =
{
    ITEM_HIDDEN,
    ITEM_FLAT,
    ITEM_NO_BLOCK,
    ITEM_SHOOT_THRU,
    ITEM_LIGHT_THRU,
    ITEM_MULTI_HEX,
    ITEM_WALL_TRANS_END,
    ITEM_TWO_HANDS,
    ITEM_BIG_GUN,
    ITEM_ALWAYS_VIEW,
    ITEM_HAS_TIMER,
    ITEM_BAD_ITEM,
    ITEM_NO_HIGHLIGHT,
    ITEM_SHOW_ANIM,
    ITEM_SHOW_ANIM_EXT,
    ITEM_LIGHT,
    ITEM_GECK,
    ITEM_TRAP,
    ITEM_NO_LIGHT_INFLUENCE,
    ITEM_NO_LOOT,
    ITEM_NO_STEAL,
    ITEM_GAG,
    ITEM_COLORIZE,
    ITEM_COLORIZE_INV,
    ITEM_CAN_USE_ON_SMTH,
    ITEM_CAN_LOOK,
    ITEM_CAN_TALK,
    ITEM_CAN_PICKUP,
    ITEM_CAN_USE,
    ITEM_HOLODISK,
    ITEM_RADIO,
    ITEM_CACHED
};

string[] item_flagnames =
{
    "hidden",
    "flat",
    "no_block",
    "shoot_thru",
    "light_thru",
    "multi_hex",
    "wall_trans_end",
    "two_hands",
    "big_gun",
    "always_view",
    "has_timer",
    "bad_item",
    "no_highlight",
    "show_anim",
    "show_anim_ext",
    "light",
    "geck",
    "trap",
    "no_light_influence",
    "no_loot",
    "no_steal",
    "gag",
    "colorize",
    "colorize_inv",
    "can_use_on_smth",
    "can_look",
    "can_talk",
    "can_pickup",
    "can_use",
    "holodisk",
    "radio",
    "cached"
};

// let it be here for now...
string GetParameterString(array<string@>@ search, array<string>& this)
{
    if(this.length() == 0)
        return("");

    for(uint i = 0; i < search.length(); i++)
    {
        if(search.length() < (i + 1))
            break;
        for(uint t = 0; t < this.length(); t++)
        {
            if(search[i] == this[t] && search.length() > (i + 1))
            {
                return(search[i + 1]);
            }
        }

    }
    return("");
}

// ...this...
int GetIndexOfString(array<string>& search, string& this)
{
    for(uint i = 0; i < search.length(); i++)
    {
        if(search[i] == this)
            return(i);
    }
    ;
    return(-1);
}

// ...and this
int GetIndexOfString(array<string@>@ search, array<string>& this)
{
    for(uint i = 0; i < search.length(); i++)
    {
        for(uint t = 0; t < this.length(); t++)
        {
            if(search[i] == this[t])
            {
                return(i);
            }
        }
    }
    ;
    return(-1);
}
void ExecItemFlagsCommand(array<string@>@ command, Critter@ player)
{
    if(item_flags.length() != item_flagnames.length())
    {
        player.Say(SAY_NETMSG, "Internal error: item_flags.length() != item_flagnames.length() -> " + item_flags.length() + " != " + item_flagnames.length());
        player.Say(SAY_NETMSG, "Blame random dev.");
        return;
    }

    if(command.length() < 3)
    {
        player.Say(SAY_NETMSG, "Missing arguments.");
        return;
    }

    int   itemId = 0;
    Item@ item;
    if(command[2] == "get" || command[2] == "set" || command[2] == "unset")
    {
        if(command.length() < 4)
        {
            player.Say(SAY_NETMSG, "Missing arguments for '" + command[2] + "'");
            return;
        }
        if(StrToInt(command[3], itemId))
        {
            @item = FindItem(player, itemId);
            if(!valid(item))
            {
                player.Say(SAY_NETMSG, "Can't find item, id " + itemId);
                return;
            }
        }
        else
        {
            player.Say(SAY_NETMSG, "Wrong item id.");
            return;
        }
    }

    if(command[2] == "get")
    {
        player.Say(SAY_NETMSG, "Item " + itemId + " flags (" + item.Flags + "):");
        for(uint f = 0; f < item_flags.length(); f++)
        {
            if(FLAG(item.Flags, item_flags[f]))
            {
                player.Say(SAY_NETMSG, "  " + (item_flagnames.length() >= (f + 1) ? item_flagnames[f] : "???") + " (" + item_flags[f] + ")");
            }
        }
    }
    else if(command[2] == "set" || command[2] == "unset")
    {
        if(command.length() != 5)
        {
            player.Say(SAY_NETMSG, "Wrong number of arguments");
            return;
        }

        int index = GetIndexOfString(item_flagnames, command[4]);
        if(index == -1)
        {
            player.Say(SAY_NETMSG, "Unknown flag: " + command[4]);
            return;
        }

        player.Say(SAY_NETMSG, (command[2] == "set" ? "S" : "Uns") + "etting flag " + command[4] + " for item " + itemId);
        if(command[2] == "set")
            SETFLAG(item.Flags, item_flags[index]);
        else
            UNSETFLAG(item.Flags, item_flags[index]);
        item.Update();

        #ifdef SDK2238
        ExecCommand(player, 0, 0, 0, "command itemflags get " + itemId, null);
        #endif
    }
    else if(command[2] == "list")
    {
        player.Say(SAY_NETMSG, "Item flags list:");
        for(uint f = 0; f < item_flags.length(); f++)
        {
            player.Say(SAY_NETMSG, "  " + item_flagnames[f] + " (" + item_flags[f] + ")");
        }
        return;
    }
    else
    {
        player.Say(SAY_NETMSG, "Unknown mode " + command[2]);
        return;
    }
}

void ExecItemProtoCommand(array<string@>@ command, Critter@ player)
{
    int itemId = 0;
    string[] sitem = { "-i", "-item" };

    if(StrToInt(GetParameterString(command, sitem), itemId))
    {
        Item@ item = FindItem(player, itemId);
        if(valid(item))
        {
            uint16 proto = 0;
            string[] sproto = { "-pid", "-proto", "-protoid" };
            uint16 ammocount = 0;
            string[] sammocount = { "-ammocount" };
            int16  dir = 0;
            string[] sdir = { "-dir", "-direction" };
            int16  offsetx = 0, offsety = 0;
            string[] soffsetx = { "-ox", "-offsetx" };
            string[] soffsety = { "-oy", "-offsety" };

            string[] spicmap = { "-picmap" };
            string[] spicinv = { "-picinv" };
            string[] spic    = { "-pic" };

            int wear = 0;
            string[] swear   = { "-w", "-wear" };

            string picmap = GetParameterString(command, spicmap);
            string picinv = GetParameterString(command, spicinv);
            string pic = GetParameterString(command, spic);
            if(pic != "")
            {
                picmap = pic;
                picinv = pic;
            }

            if(StrToInt(GetParameterString(command, sproto), proto))
            {
                player.Say(SAY_NETMSG, "Changing item proto to: " + proto);
                if(item.ChangeProto(proto))
                {
                    player.Say(SAY_NETMSG, "Sim salabim!");
                    item.Update();
                }
                else
                    player.Say(SAY_NETMSG, "Can't change item proto");
            }
            else
                DPlayerLog(player, "Invalid parameter for sproto");

            if(StrToInt(GetParameterString(command, sammocount), ammocount))
            {
                player.Say(SAY_NETMSG, "Changing item ammo count to: " + ammocount);
                item.AmmoCount = ammocount;
                item.Update();
            }
            else
                DPlayerLog(player, "Invalid parameter for sammocount");

            if(picmap != "")
            {
                player.Say(SAY_NETMSG, "Changing map picture to: " + picmap);
                item.PicMap = GetStrHash(picmap);
                item.Update();
            }

            if(picinv != "")
            {
                player.Say(SAY_NETMSG, "Changing inventory picture to: " + picinv);
                item.PicInv = GetStrHash(picinv);
                item.Update();
            }
            else
                DPlayerLog(player, "Invalid parameter for spicinv");


            if(StrToInt(GetParameterString(command, sdir), dir))
            {
                player.Say(SAY_NETMSG, "Changing item directory to: " + dir);
                item.Dir = dir;
                item.Update();
            }
            else
                DPlayerLog(player, "Invalid parameter for soffsetx");

            if(StrToInt(GetParameterString(command, soffsetx), offsetx))
            {
                player.Say(SAY_NETMSG, "Changing item offset x to: " + offsetx);
                item.OffsetX = offsetx;
                item.Update();
            }
            else
                DPlayerLog(player, "Invalid parameter for soffsetx");

            if(StrToInt(GetParameterString(command, soffsety), offsety))
            {
                player.Say(SAY_NETMSG, "Changing item offset y to: " + offsety);
                item.OffsetY = offsety;
                item.Update();
            }
            else
                DPlayerLog(player, "Invalid parameter for soffsety");

            if(StrToInt(GetParameterString(command, swear), wear))
            {
                wear = CLAMP(wear, 0, 100);
                player.Say(SAY_NETMSG, "Changing wear to: " + wear + "%");
                SetWear(item, wear);
                item.Update();
            }
            else
                DPlayerLog(player, "Invalid parameter for sdir");
        }
        else
        {
            player.Say(SAY_NETMSG, "Item not found. ");
            return;
        }
    }
}

void ExecItemLightCommand(array<string@>@ command, Critter@ player)
{
    int itemId = 0;
    string[] sitem = { "-i", "-item" };

    if(StrToInt(GetParameterString(command, sitem), itemId))
    {
        Item@ item = FindItem(player, itemId);
        if(valid(item))
        {
            int arg = 0;
            string[] sintensity = { "-int", "-intensity" };
            string[] sradius = { "-r", "-radius" };
            string[] sflags = { "-f", "-flags" };
            string[] scolor = { "-c", "-color" };
            if(StrToInt(GetParameterString(command, sintensity), arg))
                item.LightIntensity = arg;
            if(StrToInt(GetParameterString(command, sradius), arg))
                item.LightDistance = arg;
            if(StrToInt(GetParameterString(command, sflags), arg))
                item.LightFlags = arg;
            if(StrToInt(GetParameterString(command, scolor), arg))
                item.LightColor = arg;
            item.Update();
        }
        else
        {
            player.Say(SAY_NETMSG, "Item not found. ");
            return;
        }
    }
    else
        player.Say(SAY_NETMSG, "Missing -i argument.");
}

void ExecSetLexemCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    int itemId = 0;
    string[] sitem = { "-i", "-item" };

    string[] slexem = { "-l", "-lexem" };
    string lexem = GetParameterString(command, slexem);
    string what = GetParameterString(command, "-m");

    if(lexem.length() == 0)
    {
        player.Say(SAY_NETMSG, "No lexem given.");
        return;
    }
    else if(lexem[0] != '$')
    {
        player.Say(SAY_NETMSG, "Invalid lexem name <" + lexem + ">");
        return;
    }

    if(StrToInt(GetParameterString(command, sitem), itemId))
    {
        Item@ item = FindItem(player, itemId);
        if(valid(item))
        {
            if(what.length() == 0)
            {
                player.Say(SAY_NETMSG, "Removing item lexem " + lexem);
                UnsetLexem(item, lexem);
            }
            else
            {
                if(what.length() >= 127)
                {
                    player.Say(SAY_NETMSG, "Lexem too long");
                    return;
                }
                player.Say(SAY_NETMSG, "Setting item lexem " + lexem + ": " + what);
                SetLexem(item, lexem, what);
            }
        }
        else
        {
            player.Say(SAY_NETMSG, "Item not found. ");
            return;
        }
    }
    else
    {
        if(what.length() == 0)
        {
            player.Say(SAY_NETMSG, "Removing " + target.Name + "(" + target.Id + ") lexem " + lexem);
            UnsetLexem(target, lexem);
        }
        else
        {
            if(target.Id != player.Id && target.IsPlayer() &&
               !GodOfTheRealm(player.Id))
            {
                player.Say(SAY_NETMSG, "Invalid target.");
                return;
            }

            if(what.length() >= 127)
            {
                player.Say(SAY_NETMSG, "Lexem too long");
                return;
            }

            player.Say(SAY_NETMSG, "Setting " + target.Name + "(" + target.Id + ") lexem " + lexem + ": " + what);
            SetLexem(target, lexem, what);
        }
    }
}

void ExecLockCarCommand(array<string@>@ command, Critter@ player, bool lock)
{
    int itemId = 0;
    string[] sitem = { "-i", "-item" };

    if(StrToInt(GetParameterString(command, sitem), itemId))
    {
        Item@ item = FindItem(player, itemId);
        if(valid(item))
        {
            if(item.GetType() != ITEM_TYPE_CAR)
            {
                player.Say(SAY_NETMSG, "It's not a car.");
                return;
            }

            string un = "";
            if(lock)
                SETFLAG(item.Val0, CAR_NO_LOCKPICK);
            else
            {
                un = "un";
                UNSETFLAG(item.Val0, CAR_NO_LOCKPICK);
            }
            player.Say(SAY_NETMSG, "Car " + un + "locked.");

        }
        else
            player.Say(SAY_NETMSG, "Car not found. ");
    }
    else
        player.Say(SAY_NETMSG, "Missing -item argument.");
}

void ExecGetItemsCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    if(player.Id == target.Id)
    {
        player.Say(SAY_NETMSG, "Invalid target.");
        return;
    }

    string[] sinv   = { "-i", "-inv", "-inventory", "-all" };
    string[] sarmor = { "-a", "-armor", "-all" };
    string[] shead  = { "-h3", "-head", "-helmet", "-all" };
    string[] shand1 = { "-h1", "-hand1", "-hands", "-all" };
    string[] shand2 = { "-h2", "-hand2", "-hands", "-all" };

    bool inv                = (GetIndexOfString(command, sinv) != -1);
    bool armor              = (GetIndexOfString(command, sarmor) != -1);
    bool head               = (GetIndexOfString(command, shead) != -1);
    bool hand1              = (GetIndexOfString(command, shand1) != -1);
    bool hand2              = (GetIndexOfString(command, shand2) != -1);

    if(!inv && !armor && !hand1 && !hand2 && !head)
    {
        player.Say(SAY_NETMSG, "Nothing to transfer.");
        return;
    }

    #ifdef __DEBUG__
    player.Say(SAY_NETMSG, "ExecGetItemsCommand:" + (inv ? " inv" : "") + (head ? " helmet" : "") + (armor ? " armor" : "") + (hand1 ? "hand1" : "") + (hand2 ? "hand2" : ""));
    #endif

    array<Item@> items;
    uint         count = 0;

    if(inv)
        count += target.GetItems(SLOT_INV, items);
    if(armor)
        count += target.GetItems(SLOT_ARMOR, items);
    if(head)
        count += target.GetItems(SLOT_HEAD, items);
    if(hand1)
        count += target.GetItems(SLOT_HAND1, items);
    if(hand2)
        count += target.GetItems(SLOT_HAND2, items);

    if(count > 0)
    {
        player.Say(SAY_NETMSG, "Transfering " + count + " items from " + target.Name);
        _CritAnimateUse(player);
        MoveItems(items, player);
    }
    else
        player.Say(SAY_NETMSG, target.Name + " has no items in given slot(s)");
}

// built-in client cheats
void ExecCoreCheats(array<string@>@ command, Critter@ player)
{
    int cheats = 0;

    if(command.length() < 3)
    {
        player.Say(SAY_NETMSG, "Wrong numer of arguments.");
        return;
    }
    else if(command[2] == "set" && command.length() < 4)
    {
        player.Say(SAY_NETMSG, "Wrong numer of arguments for 'set' mode.");
        return;
    }

    if(command[2] == "reset" || command[2] == "set")
    {
        SETFLAG(cheats, CC_TILE | CC_ROOF | CC_ITEM | CC_SCEN | CC_WALL | CC_CRIT | CC_NPCNAMES);
    }

    if(command[2] == "reset")
    {
        /* foo!=bar */
    }
    else if(command[2] == "set")
    {
        SET_CORECHEAT(command, cheats, "tile",                 CC_TILE);
        SET_CORECHEAT(command, cheats, "roof",                 CC_ROOF);
        SET_CORECHEAT(command, cheats, "item",                 CC_ITEM);
        SET_CORECHEAT(command, cheats, "scen",                 CC_SCEN);
        SET_CORECHEAT(command, cheats, "wall",                 CC_WALL);
        SET_CORECHEAT(command, cheats, "crit",                 CC_CRIT);
        SET_CORECHEAT(command, cheats, "fast",                 CC_FAST);           // what is that?
        SET_CORECHEAT(command, cheats, "npcnames",             CC_NPCNAMES);
        SET_CORECHEAT(command, cheats, "critid",               CC_CRITID);
        /*
           SET_CORECHEAT( command, cheats, "debuginfo",	CC_DEBUGINFO );
           SET_CORECHEAT( command, cheats, "debugnet",		CC_DEBUGNET );
           SET_CORECHEAT( command, cheats, "debugsprites",	CC_DEBUGSPRITES );
         */
    }
    else
    {
        player.Say(SAY_NETMSG, "Invalid switch: " + command[2]);
        return;
    }

    player.RunClientScript("_CC", cheats, 0, 0, " ", null);
}

void ExecFindCharsCommand(array<string@>@ command, Critter@ player)
{
    string halp = "Usage: findchars [param] [< <= == != >= >] [value]";
    int    param = 0;
    int    value = 0;

    // check arguments

    if(command.length() < 3 || !StrToInt(command[2], param))
    {
        player.Say(SAY_NETMSG, halp);
        return;
    }
    if(param < 0)
    {
        player.Say(SAY_NETMSG, halp);
        player.Say(SAY_NETMSG, "[param] cannot be less than 0");
        return;
    }
    if(!(command[3] == "<" || command[3] == ">" ||       // command[3] == "=" ||
         command[3] == "<=" || command[3] == ">=" || command[3] == "==" ||
         command[3] == "!="))
    {
        player.Say(SAY_NETMSG, halp);
        return;
    }
    if(!StrToInt(command[4], value))
    {
        player.Say(SAY_NETMSG, halp);
        return;
    }

    // make some output
    array<Critter@> players;
    uint            n = GetAllOnlinePlayers(players);
    uint            found = 0;
    for(uint p = 0; p < players.length(); p++)
    {
        #define _PrintPlayer    # (array, idx)GetSafePlayerName(array[idx].Id) + " (" + array[idx].Id + ")" + "(" + array[idx].GetMapId() + ") - " + GetAuthString(array[idx])

        #ifndef __DEBUG__
        if(GodOfTheRealm(players[p].Id) && _CritHasExtMode(players[p], MODE_EXT_GOD))
            continue;
        #endif

        if(player.GetAccess() < players[p].GetAccess())
            continue;

        if(command[3] == "<" && players[p].Param[param] < value)
        {
            player.Say(SAY_NETMSG, _PrintPlayer(players, p));
            found++;
        }
        else if(command[3] == "<=" && players[p].Param[param] <= value)
        {
            player.Say(SAY_NETMSG, _PrintPlayer(players, p));
            found++;
        }
        else if(command[3] == ">" && players[p].Param[param] > value)
        {
            player.Say(SAY_NETMSG, _PrintPlayer(players, p));
            found++;
        }
        else if(command[3] == ">=" && players[p].Param[param] >= value)
        {
            player.Say(SAY_NETMSG, _PrintPlayer(players, p));
            found++;
        }
        else if((/*command[3] == "=" ||*/ command[3] == "==") && players[p].Param[param] == value)
        {
            player.Say(SAY_NETMSG, _PrintPlayer(players, p));
            found++;
        }
        else if(command[3] == "!=" && players[p].Param[param] != value)
        {
            player.Say(SAY_NETMSG, _PrintPlayer(players, p));
            found++;
        }
    }
    player.Say(SAY_NETMSG, "Found " + found + " player" + (found == 1 ? "" : "s") + ".");
}

void ExecFindNpcCommand(array<string@>@ command, Critter@ player)
{
    if(command.length() < 3)
    {
        player.Say(SAY_NETMSG, "Missing arguments");
        return;
    }

    if(command[2] == "list")
    {
        if(INPC.length() > 0)
        {
            player.Say(SAY_NETMSG, "\nImportant NPCs:");
            for(uint i = 0; i < INPC.length(); i++)
            {
                string names = "";
                for(uint n = 0; n < INPC[i].names.length(); n++)                 // becouse join() is a joke
                {
                    if(n > 0)
                        names += ",";
                    names += INPC[i].names[n];
                }

                player.Say(SAY_NETMSG,
                           "[" +
                           (INPC[i].protoId < 1000  ? " " : "") +
                           (INPC[i].protoId < 100   ? " " : "") +
                           (INPC[i].protoId < 10    ? " " : "") +
                           INPC[i].protoId +
                           "," +
                           (INPC[i].dialogId < 10000 ? " " : "") +
                           (INPC[i].dialogId < 1000  ? " " : "") +
                           (INPC[i].dialogId < 100   ? " " : "") +
                           (INPC[i].dialogId < 10    ? " " : "") +
                           INPC[i].dialogId +
                           "] " +
                           names);
            }
            player.Say(SAY_NETMSG, "Total " + INPC.length() + " NPCs");
        }
    }
    else
    {
        array<CNPC@> list;
        for(uint i = 0; i < INPC.length(); i++)
        {
            for(uint n = 0; n < INPC[i].names.length(); n++)
            {
                if(strlwr(INPC[i].names[n]) == strlwr(command[2]))
                {
                    list.insertLast(INPC[i]);
                    break;
                }
            }
        }
        if(list.length() > 0)
        {
            player.Say(SAY_NETMSG, "NPC \"" + command[2] + "\" (" + list.length() + ")");
            for(uint l = 0; l < list.length(); l++)
            {
                if(!valid(list[l]))
                    continue;
                array<Critter@> npcs;
                GetAllNpc(list[l].protoId, npcs);
                if(npcs.length() > 0)
                {
                    for(uint n = 0; n < npcs.length(); n++)
                    {
                        if(list[l].IsImportant(npcs[n]))
                        {
                            uint map = npcs[n].GetMapId();
                            player.Say(SAY_NETMSG, " " +
                                       npcs[n].Id +
                                       (map > 0
                                        ? " map:" + map + ":" + npcs[n].HexX + "," + npcs[n].HexY
                                        : "worldmap:" + npcs[n].WorldX + "," + npcs[n].WorldY)
                                       );
                        }
                    }
                }
                else
                {
                    player.Say(SAY_NETMSG, "Can't find any \"" + command[2] + "\"");
                }
            }
        }
        else
        {
            player.Say(SAY_NETMSG, "Unknown NPC \"" + command[2] + "\"");
        }
    }
}


void ExecResetWorldMapCommand(array<string@>@ command, Critter@ player)
{
    for(uint x = 0; x < __GlobalMapWidth; x++)
    {
        for(uint y = 0; y < __GlobalMapHeight; y++)
        {
            player.SetFog(x, y, FOG_NONE);
        }
    }
}

void ExecPlayMusicCommand(array<string@>@ command, Critter@ player)
{
    string[] smusic = { "-m", "-music" };
    string music = GetParameterString(command, smusic);
    if(music == "")
    {
        player.Say(SAY_NETMSG, "Missing music filename.");
        return;
    }
    else
    {
        if(valid(player.GetMap()))
        {
            player.Say(SAY_NETMSG, "Playing: " + music);
            array<Critter@> critters;

            uint            allcrit = player.GetMap().GetCritters(0, FIND_ALL | FIND_ONLY_PLAYERS, critters);
            for(uint c = 0; c < allcrit; c++)
            {
                critters[c].RunClientScript("_PlayMusic", 0, 0, 0, music, null);
            }
        }
        else
        {
            player.Say(SAY_NETMSG, "Invalid map.");
            return;
        }
    }
    return;
}

void ExecPlaySoundCommand(array<string@>@ command, Critter@ player, bool speech)
{
    string[] ssound = { "-s", "-sound" };
    string sound = GetParameterString(command, ssound);
    if(sound == "")
    {
        player.Say(SAY_NETMSG, "Missing sound filename.");
        return;
    }
    else
    {
        Map@ map = player.GetMap();
        if(valid(map))
        {
            if(GetIndexOfString(command, "-x") != -1 ||
               GetIndexOfString(command, "-y") != -1 ||
               GetIndexOfString(command, "-r") != -1)
            {
                string sx = GetParameterString(command, "-x");
                int    x = 0;
                string sy = GetParameterString(command, "-y");
                int    y = 0;
                string[] sradius = { "-r", "-radius" };
                string sr = GetParameterString(command, sradius);
                int    r = 0;
                StrToInt(sx, x);
                StrToInt(sy, y);
                StrToInt(sr, r);
                if(x == 0 && sx != "0")
                    x = player.HexX;
                if(y == 0 && sy != "0")
                    y = player.HexY;
                if(r == 0)
                    r = 10;
                map.PlaySound((speech ? "sound\\speech\\" : "") + sound, x, y, r);
                return;
            }
            else
            {
                map.PlaySound((speech ? "sound\\speech\\" : "") + sound);
                return;
            }
        }
        else
        {
            player.Say(SAY_NETMSG, "Invalid map.");
            return;
        }
    }
}

void ExecGetRequestsCommand(array<string@>@ command, Critter@ player)
{
    Broadcast_DumpRequestHelpBuffer(player);
}

/*
 * Client commands replacement - remember to disable original ones in client
 */

// TODO: finish tester params table and move command to tester access
void ExecParamCommand(array<string@>@ command, Critter@ player, Critter@ target)     // ~param
{
    if(command.length() >= 4)
    {
        int  control = 0;
        int  param = -1;
        bool ok = false;
        if(!StrToInt(command[2], control))
        {
            player.Say(SAY_NETMSG, "Wrong arguments.");
            return;
        }
        else
        {
            if(control != 0)
            {
                player.Say(SAY_NETMSG, "Invalid param group.");
                return;
            }
        }

        if(StrToInt(command[3], param))
        {
            if(param < 0 || param > 999)
            {
                player.Say(SAY_NETMSG, "Invalid param number.");
                return;
            }
            if(target.Id == player.Id || (player.GetAccess() >= ACCESS_ADMIN && target.IsNpc()))
            {
                if(player.GetAccess() == ACCESS_TESTER && !Present(param, testerparamlist))
                {
                    player.Say(SAY_NETMSG, "You can't view or edit this param.");
                    return;
                }

                int  value = 0;
                bool haveValue = false;
                if(command.length >= 5)
                {
                    haveValue = true;
                    if(!StrToInt(command[4], value))
                    {
                        player.Say(SAY_NETMSG, "Invalid value argument <" + command[4] + ">");
                        return;
                    }
                }

                if(!haveValue)
                {
                    player.Say(SAY_NETMSG, "Param " + param + " of critter " + target.Name + "(" + target.Id + "): " + target.Param[param]);
                    return;
                }

                int oldValue = target.Param[param];

                // pre-process
                switch(param)
                {
                case ST_AGE:
                {
                    SetLvar(target, LVAR_birth_year, __Year - value);
                    SynchronizeAge(target);
                    if(oldValue != target.Param[ST_AGE])
                        player.Say(SAY_NETMSG, "SynchronizeAge " + target.Name + "(" + target.Id + "): " + oldValue + " -> " + target.Param[ST_AGE]);
                };
                    break;

                default:
                    target.ParamBase[param] = value;
                    break;
                }

                player.Say(SAY_NETMSG, "Changed param " + param + " of critter " + target.Name + "(" + target.Id + "): " + oldValue + " -> " + target.Param[param]);

                // post-process
                switch(param)
                {
                case ST_BASE_CRTYPE:
                    target.DisguisedBy = player.Id;
                    break;
                }
            }
            else
            {
                player.Say(SAY_NETMSG, "Wrong target: " + target.Name + "(" + target.Id + ")");
                return;
            }
        }
        else
        {
            player.Say(SAY_NETMSG, "Wrong arguments.");
            return;
        }
    }
    else
    {
        player.Say(SAY_NETMSG, "Missing arguments.");
    }
}

void ExecGetColorCommand(array<string@>@ command, Critter@ player)
{
    if(command.length() < 5)
    {
        player.Say(SAY_NETMSG, "Missing arguments.");
        return;
    }

    int r = 0;
    int g = 0;
    int b = 0;
    if(StrToInt(command[2], r) &&
       StrToInt(command[3], g) &&
       StrToInt(command[4], b))
    {
        int   color = COLOR_RGB(r, g, b);

        bool  isAlpha = false;
        uint8 a = 0;
        if(command.length() >= 6 && StrToInt(command[5], a))
        {
            isAlpha = true;
            color = COLOR_CHANGE_ALPHA(color, a);
        }

        player.Say(SAY_NETMSG, "Color: " + r + "," + g + "," + b);
        if(isAlpha)
            player.Say(SAY_NETMSG, "Alpha: " + a);
        player.Say(SAY_NETMSG, "Number: " + color);
    }
    else
        player.Say(SAY_NETMSG, "Wrong arguments.");
}

void ExecLastSpawnedCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    player.Say(SAY_NETMSG, "Last spawned by " + target.Name + ":");
    if((GodOfTheRealm(target.Id) || target.GetAccess() > player.GetAccess()) &&
       target.Id != player.Id)
    {
        player.Say(SAY_NETMSG, "No idea.");
        return;
    }

    if(target.LastSpawnedCritter == 0 &&
       target.LastSpawnedItem == 0 &&
       target.LastSpawnedLocation == 0)
    {
        player.Say(SAY_NETMSG, "Nothing, " + GenderString(player, "he's", "she's", "it's") + " clean!");
        return;
    }

    if(target.LastSpawnedItem > 0)
        player.Say(SAY_NETMSG, "Item: " + target.LastSpawnedItem);
    if(target.LastSpawnedCritter > 0)
        player.Say(SAY_NETMSG, "Critter: " + target.LastSpawnedCritter);
    if(target.LastSpawnedLocation > 0)
        player.Say(SAY_NETMSG, "Location: " + target.LastSpawnedLocation);
}

string@ spaces(int num)   // helper
{
    if(num < 1)
        return " ";
    string result = "";
    result.resize(num);
    for(int s = 0; s < num; s++)
        result[s] = ' ';
    return result;
}

void ExecGameInfoCommand(array<string@>@ command, Critter@ player)
{
    if(command.length() < 3)
    {
        player.Say(SAY_NETMSG, "Invalid arguments");
        return;
    }

    int gameinfo = 0;
    StrToInt(command[2], gameinfo);

    if(gameinfo == 1)
    {
        array<Critter@> players;
        uint            all = GetAllOnlinePlayers(players);
        uint            num = all;
        for(uint p = 0; p < all; p++)
        {
            if(!valid(players[p]))
                continue;

            if(WrathOfTheGod(players[p]))
                num--;
        }

        player.Say(SAY_NETMSG, "Players in game: " + num);
        player.Say(SAY_NETMSG, "Connections: " + all);         // TODO!

        player.Say(SAY_NETMSG, "Name                 Id        Ip              Online  Cond     X     Y     Location (Id, Pid)             Map (Id, Pid)                  Level");

        for(uint p = 0; p < all; p++)
        {
            if(!valid(players[p]))
                continue;

            if(WrathOfTheGod(players[p]))
                continue;

            string line = "";
            // collect info
            string ip = IpToString(players[p].GetIp());
            string online = (players[p].GetSocket() == -1 ? "Disconnect" : "Yes");
            string cond = "";
            switch(players[p].Cond)
            {
            case COND_LIFE:
                cond = "Life";
                break;
            case COND_KNOCKOUT:
                cond = "Knockout";
                break;
            case COND_DEAD:
                cond = "Dead";
                break;
            default:
                cond = "Unknown";
                break;
            }
            int    x = 0;
            int    y = 0;
            string locname = "";
            string mapname = "";
            if(players[p].GetMapId() == 0)
            {
                x = players[p].WorldX;
                y = players[p].WorldY;
                locname = "Global map";
            }
            else
            {
                x = players[p].HexX;
                y = players[p].HexY;

                Map@      map = players[p].GetMap();
                Location@ loc = map.GetLocation();

                map.ProtoName(mapname);
                loc.ProtoName(locname);

                mapname += " (" + map.Id + ", " + map.GetProtoId() + ")";
                locname += " (" + loc.Id + ", " + loc.GetProtoId() + ")";
            }
            // fix
            if(ip.length() == 0)
                ip = "0.0.0.0";                 // so ugly!

            // Name
            line += players[p].Name + spaces(21 - players[p].Name.length());
            // Id
            line += players[p].Id + spaces(10 - numDigits(players[p].Id));
            // Ip
            line += ip + spaces(16 - ip.length());
            // NetState
            line += online + spaces(11 - online.length());
            // Cond
            line += cond + spaces(9 - cond.length());
            // X, Y
            line += x + spaces(6 - numDigits(x));
            line += y + spaces(6 - numDigits(y));
            // Location (Id, Pid), Map (Id, Pid)
            line += locname + spaces(31 - locname.length());
            line += mapname + spaces(31 - mapname.length());
            // Level
            line += players[p].Param[ST_LEVEL] + spaces(4 - numDigits(players[p].Param[ST_LEVEL]));

            // finally - output
            player.Say(SAY_NETMSG, line);
        }
    }     // 1
    else
        player.Say(SAY_NETMSG, "Not implemented.");
}

void ExecLastRegisteredCommand(array<string@>@ command, Critter@ player)
{
    int id = GetGvar(GVAR_last_registered);

    if(id == 0)
    {
        player.Say(SAY_NETMSG, "GVAR missing");
        return;
    }

    string@ name = GetSafePlayerName(id);
    if(!valid(name))
        name = "???";

    player.Say(SAY_NETMSG, "Newest character: " + name + " (" + id + ")");
}

void ExecAccessListCommand(array<string@>@ command, Critter@ player)
{
    #ifndef __DEBUG__
    if(!WrathOfTheGod(player))
    {
        player.Say(SAY_NETMSG, "No.");
        return;
    }
    #endif

    if(command.length() < 3)
    {
        player.Say(SAY_NETMSG, "Missing parameters");
        return;
    }

    {
        LoadConfig(GETACCESS_CFG);
        IConfigFile@ config = GetConfigFile(GETACCESS_CFG);
        if(!valid(config))
        {
            Log("ERROR Can't load config/GetAccess.cfg");
            player.Say(SAY_NETMSG, "INVALID GETACCESS CONFIG. PANIC.");
            return;
        }
        DPlayerLog(player, "Config OK");
    }

    string option = command[2];

    if(option == "help")
    {
        player.Say(SAY_NETMSG, "Available commands:");
        player.Say(SAY_NETMSG, " allowregistration [nick]");
        player.Say(SAY_NETMSG, " disallowregistration [nick]");
        player.Say(SAY_NETMSG, " list");
        // player.Say( SAY_NETMSG, " reload" );
    }
    else if(option == "allowregistration")
    {
        if(command.length() < 4)
        {
            player.Say(SAY_NETMSG, "Missing parameters (required: nickname)");
            return;
        }
        if(!valid(GetConfigSection(GETACCESS_CFG, command[3], true)))
        {
            player.Say(SAY_NETMSG, "No such user exists - " + command[3]);
            return;
        }
        SetConfigValue(GETACCESS_CFG, command[3], "Reserved", "false");
        SaveConfig(GETACCESS_CFG);

        string msg = "Allowed registration of " + command[3];
        Log(msg + " : " + player.Name + "(" + player.Id + ")");
        player.Say(SAY_NETMSG, msg);
    }
    else if(option == "disallowregistration")
    {
        if(command.length() < 4)
        {
            player.Say(SAY_NETMSG, "Missing parameters (required: nickname)");
            return;
        }
        if(!valid(GetConfigSection(GETACCESS_CFG, command[3], true)))
        {
            player.Say(SAY_NETMSG, "No such user exists: " + command[3]);
            return;
        }
        SetConfigValue(GETACCESS_CFG, command[3], "Reserved", "true");
        SaveConfig(GETACCESS_CFG);

        string msg = "Disallowed registration of " + command[3];
        Log(msg + " : " + player.Name + "(" + player.Id + ")");
        player.Say(SAY_NETMSG, msg);
    }
    else if(option == "list")
    {
        IConfigFile@  config = GetConfigFile(GETACCESS_CFG);
        array<string> sections;
        config.GetSections(sections);
        if(sections.length() > 0)
        {
            player.Say(SAY_NETMSG, "Hall of Fame");
            sections.sortAsc();
            for(uint s = 0; s < sections.length(); s++)
            {
                string@ res = GetConfigValue(GETACCESS_CFG, sections[s], "Reserved");
                player.Say(SAY_NETMSG, " " + sections[s] + (valid(res) ? " (reserved)" : ""));
            }
        }
        else
        {
            player.Say(SAY_NETMSG, "Nobody in access list. What are you doing here?");
            return;
        }
    }
    /* needs better config handling
       else if( option == "reload" )
       {
            SaveConfig( GETACCESS_CFG );
            UnloadConfig( GETACCESS_CFG );
            LoadConfig( GETACCESS_CFG );
            Log( "Access list reloaded : "+player.Name+"("+player.Id+")" );
       }
     */
}

void ExecReservedNicknameCommand(array<string@>@ command, Critter@ player)
{
    LoadConfig("config/ReservedNicknames.cfg");

    if(command.length() < 3)
    {
        player.Say(SAY_NETMSG, "Missing parameters");
        return;
    }

    IConfigSection@ section = GetConfigSection("config/ReservedNicknames.cfg", "Reserved");

    if(command[2] == "list")
    {
        if(!valid(section))
            player.Say(SAY_NETMSG, "No reserved nicknames found.");
        else
        {
            array<string> nicknames;
            section.GetVars(nicknames);
            if(nicknames.length() > 0)
            {
                nicknames.sortAsc();
                player.Say(SAY_NETMSG, "Reserved nickname" + (nicknames.length() > 1 ? "s" : "") + " (" + nicknames.length() + "):");
                for(uint n = 0, ncount = nicknames.length(); n < ncount; n++)
                {
                    player.Say(SAY_NETMSG, nicknames[n]);
                }
                player.Say(SAY_NETMSG, "Reserving " + nicknames.length() + " nickname" + (nicknames.length() > 1 ? "s" : "") + ".");
            }
            else
                player.Say(SAY_NETMSG, "No reserved nicknames found.");
        }
        return;
    }

    if(command.length() < 4 || command[3].length() == 0)
    {
        player.Say(SAY_NETMSG, "Missing parameters");
        return;
    }


    if(command[2] == "add")
    {
        IConfigVar@ var = GetConfigVar("config/ReservedNicknames.cfg", "Reserved", command[3], false);
        if(valid(var))
            section.DeleteVar(var.GetName());
        SetConfigValue("config/ReservedNicknames.cfg", "Reserved", command[3], "1");
        SaveConfig("config/ReservedNicknames.cfg");
        player.Say(SAY_NETMSG, "Nickname <" + command[3] + "> reserved.");
    }
    else if(command[2] == "delete")
    {
        if(!valid(section))
            player.Say(SAY_NETMSG, "No reserved nicknames found.");

        IConfigVar@ var = GetConfigVar("config/ReservedNicknames.cfg", "Reserved", command[3], false);
        if(valid(var))
        {
            section.DeleteVar(var.GetName());
            SaveConfig("config/ReservedNicknames.cfg");
            player.Say(SAY_NETMSG, "Nickname <" + var.GetName() + "> no longer reserved.");
        }
        else
            player.Say(SAY_NETMSG, "Nickname not reserved.");
    }
}

void ExecToGlobal(Critter@ player, Critter@ target)
{
    if(target.Id != player.Id &&
       ((player.GetAccess() < ACCESS_MODER) || GodOfTheRealm(target.Id)))
    {
        player.Say(SAY_NETMSG, "No.");
        return;
    }

    string who = target.Name + "(" + target.Id + ")";

    if(!valid(target.GetMap()))
    {
        player.Say(SAY_NETMSG, who + " already on worldmap.");
        return;
    }
    ;

    player.Say(SAY_NETMSG, "Moving " + who + " to worldmap.");
    target.TransitToGlobal(false);
}

void ExecCCD(array<string@>@ command, Critter@ player)
{
    #ifndef __DEBUG__
    if(!GodOfTheRealm(player.Id))
    {
        player.Say(SAY_NETMSG, "No.");
        return;
    }
    #endif

    string ccd = GetParameterString(command, "-m");
    if(ccd.length() == 0 || ccd == "NONE")
    {
        player.Say(SAY_NETMSG, "CCD removed");
        UnsetLexem(player, "$~");
    }
    else
    {
        player.Say(SAY_NETMSG, "CCD: " + ccd);
        SetLexem(player, "$~", ccd);
    }
}

void ExecFactionNews(array<string@>@ command, Critter@ player)
{
    int id = -1;
    if(!StrToInt(GetParameterString(command, "-f"), id))
    {
        player.Say(SAY_NETMSG, "You must specify faction id.");
        return;
    }
    if(id <= 0)
    {
        player.Say(SAY_NETMSG, "Invalid id.");
        return;
    }
    if(!FactionExists(id))
    {
        player.Say(SAY_NETMSG, "Faction does not exists");
        return;
    }

    IFaction@ faction = GetFaction(id);
    if(valid(faction))
    {
        uint count = GetFactionNewsCount(id);
        player.Say(SAY_NETMSG, "Found " + count + " news");
        for(uint index = 0; index < count; index++)
        {
            uint   type = 0;
            uint   master = 0, slave = 0;
            uint16 year;
            uint8  month, day, hour, minute;
            if(GetFactionNews(id, index, master, slave, type, year, month, day, hour, minute))
            {
                string timestamp = day + "." + month + "." + year + " " + hour + ":" + (minute < 10 ? "0" : "") + minute;
                string masterName = GetSafePlayerName(master, "(" + master + ")", "Player " + master);
                string slaveName  = GetSafePlayerName(slave,  "(" + slave + ")",  "Player " + slave);

                switch(type)
                {
                case NEWS_JOINED:
                    player.Say(SAY_NETMSG, timestamp + " " + masterName + " joined the faction");
                    break;
                case NEWS_RESIGNED:
                    player.Say(SAY_NETMSG, timestamp + " " + masterName + " resigned from being a member");
                    break;
                case NEWS_EXPELLED:
                    player.Say(SAY_NETMSG, timestamp + " " + slaveName + " was expelled by " + masterName);
                    break;
                case NEWS_PROMOTED:
                    player.Say(SAY_NETMSG, timestamp + " " + slaveName + " was promoted by " + masterName);
                    break;
                case NEWS_DEMOTED:
                    player.Say(SAY_NETMSG, timestamp + " " + slaveName + " was demoted by " + masterName);
                    break;
                case NEWS_CLAIMED:
                    player.Say(SAY_NETMSG, timestamp + " " + masterName + " claimed leadership");
                    break;
                case NEWS_LEADER:
                    player.Say(SAY_NETMSG, timestamp + " " + masterName + " became new leader");
                    break;
                case NEWS_OVERTHROWN:
                    player.Say(SAY_NETMSG, timestamp + " " + masterName + " was overthrown");
                    break;
                default:
                    player.Say(SAY_NETMSG, timestamp + " UNKNOWN NEWS TYPE <" + type + "> idx<" + index + ">");
                    break;
                }
            }
        }
    }
    else
        player.Say(SAY_NETMSG, "Invalid faction");
}

void ExecRunDialog(array<string@>@ command, Critter@ player, Critter@ target)
{
    if(player.Id == target.Id)
    {
        player.Say(SAY_NETMSG, "Talking to self not implemented.");
        return;
    }
    else if(!target.IsNpc())
    {
        player.Say(SAY_NETMSG, "Please use *chat* to talk with other players.");
        return;
    }

    uint dialog = 0;
    if(StrToInt(GetParameterString(command, "-d"), dialog))
    {
        player.Say(SAY_NETMSG, "Starting dialog " + dialog + " with " + target.Name);
        if(!RunDialog(player, target, dialog, true))
            player.Say(SAY_NETMSG, "Dialog error.");
    }
    else
    {
        player.Say(SAY_NETMSG, "Starting default dialog with " + target.Name);
        if(!RunDialog(player, target, true))
            player.Say(SAY_NETMSG, "Dialog error.");
    }
}

void ExecFOArt(array<string@>@ command, Critter@ player)
{
    string filename = GetParameterString(command, "-f");
    if(filename.length() == 0)
    {
        player.Say(SAY_NETMSG, "Missing filename.");
        return;
    }

    player.RunClientScript("client_messages@_foart", 0, 0, 0, filename, null);
}

void ExecTeamCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    // Default Settings
    int  minigameTeam    = 0;
    int  minigameId      = 15;
    int  minigameFlags   = 0;
    uint radius         = 0;
    bool all            = false;
    bool info           = false;
    bool persistent     = false;

    // Prepare array with targets
    cheatGetOption(command, all, "-all");
    cheatGetOption(command, radius, "-r");
    cheatGetOption(command, persistent, "-s");
    array<Critter@> targets;
    // Set team for all players in the same map as target
    if(all)
    {
        Map@ map = target.GetMap();
        if(!valid(map))
            targets.insertLast(target);
        else
            map.GetCritters(0, FIND_ONLY_PLAYERS | FIND_ALL, targets);
    }
    else
    {
        if(radius <= 0)
            targets.insertLast(target);
        // Set team for everyone around target in a given radius
        else
        {
            Map@ map = target.GetMap();
            if(!valid(map))
                targets.insertLast(target);
            else
                map.GetCrittersHex(target.HexX, target.HexY, radius, FIND_ONLY_PLAYERS | FIND_ALL, targets);
        }
    }

    // Prepare settings
    if(command.length() > 2)
    {
        if(command[2] == "none" || command[2] == "n")
            minigameId = 0;
        else if(command[2] == "spectator" || command[2] == "s")
            minigameTeam = 0;
        else
        {
            if(StrToInt(command[2], minigameTeam))
            {
                if(minigameTeam < 1 || minigameTeam > 15)
                {
                    player.Say(SAY_NETMSG, "Error: Invalid team number.");
                    return;
                }
            }
            else
                info = true;
        }
        if(persistent)
            SETFLAG(minigameFlags, MINIGAME_PERSISTENT);
    }
    else
        info = true;

    // Execute
    if(info)
    {
        player.Say(SAY_NETMSG, "Team Info:");
        for(int i = 0, j = targets.length(); i < j; i += 1)
        {
            int minigameData = targets[i].Param[ST_MINIGAME_DATA];
            int team = _getMinigameTeam(minigameData);
            if(minigameData == 0)
                player.Say(SAY_NETMSG, GetSafePlayerName(targets[i].Id) + " : none");
            else
            {
                if(team == 0)
                    player.Say(SAY_NETMSG, GetSafePlayerName(targets[i].Id) + " : spectator");
                else
                    player.Say(SAY_NETMSG, GetSafePlayerName(targets[i].Id) + " : " + team);
            }
        }
    }
    else
        for(int i = 0, j = targets.length(); i < j; i += 1)
        {
            // Radius and All doesn't change authenticated chars
            if((targets[i].GetAccess() != ACCESS_CLIENT) && (all || radius > 0))
                continue;
            SetMinigame(targets[i], minigameTeam, minigameId, minigameFlags, 0);
        }
}

#define AURA_FLAG_VISIBLE             (0x01)
#define AURA_FLAG_NEED_CRITTERS       (0x02)
#define AURA_FLAG_KNOCKBACK           (0x04)
#define AURA_FLAG_KNOCKBACK_SIMPLE    (0x08)
#define AURA_FLAG_IGNORE_ADMINS       (0x10)
#define AURA_FLAG_GRAVITY_PULL        (0x20)

enum auraNumber
{
    AURA_RESERVED = 0,
    AURA_KNOCKBACK_ALL,
    AURA_KNOCKBACK_NPC,
    AURA_KNOCKBACK_PLAYER,
    AURA_KILL_ALL,
    AURA_KILL_NPC,
    AURA_KILL_PLAYER,
    AURA_SKIN_RANDOM,     // disabled
    AURA_SKIN_RESET,
    AURA_GOLGOTHA,
    AURA_FOREST,
    AURA_SNOWQUEEN,
    AURA_GRAVITATION_WELL,
	AURA_SKIN_RANDOM_SAFE
};

string[] auraSwitch =
{
    "",
    "-knockback",
    "-knockbacknpc",
    "-knockbackplayer",
    "-kill",
    "-killnpc",
    "-killplayer",
    "-randomskin",
    "-resetskin",
    "-golgotha",
    "-forest",
    "-snowqueen",
    "-gravitationwell",
	"-randomskinsafe"
};

string[] auraName =
{
    "RESERVED",
    "Knockback aura, all critters",
    "Knockback aura, NPCs only",
    "Knockback aura, players only",
    "Death aura, all critters",
    "Death aura, NPCs only",
    "Death aura, players only",
    "Skin aura, apply random, players only",
    "Skin aura, reset, players only",
    "Golgotha aura, spawns stakes",
    "Forest aura, spawns trees",
    "Snow Queen aura, all critters",
    "Gravitation Well aura, all critters",
	"SAFE skin aura, no armor skins, players only"
};

void ExecAuraCommand(array<string@>@ command, Critter@ player)
{
    auraNumber aura;

    bool       on = Present("-on", command), off = Present("-off", command);

    if(on && off)
    {
        player.Say(SAY_NETMSG, "Cannot use -on and -off switches at same time");
        return;
    }
    else if(!on && !off)
    {
        player.Say(SAY_NETMSG, "Enabling: `aura -on [auraSwitch], see below");
        player.Say(SAY_NETMSG, "Disabling: `aura -off");
        player.Say(SAY_NETMSG, "Available:");
        for(uint a = 1, alen = auraSwitch.length(); a < alen; a++)
        {
            player.Say(SAY_NETMSG, auraSwitch[a]);
            player.Say(SAY_NETMSG, "  " + auraName[a]);
        }
        return;
    }

    if(on)
    {
        if(Present(auraSwitch[AURA_KNOCKBACK_ALL], command))
            aura = AURA_KNOCKBACK_ALL;
        else if(Present(auraSwitch[AURA_KNOCKBACK_NPC], command))
            aura = AURA_KNOCKBACK_NPC;
        else if(Present(auraSwitch[AURA_KNOCKBACK_PLAYER], command))
            aura = AURA_KNOCKBACK_PLAYER;
        else if(Present(auraSwitch[AURA_KILL_ALL], command))
            aura = AURA_KILL_ALL;
        else if(Present(auraSwitch[AURA_KILL_NPC], command))
            aura = AURA_KILL_NPC;
        else if(Present(auraSwitch[AURA_KILL_PLAYER], command))
            aura = AURA_KILL_PLAYER;
        else if(Present(auraSwitch[AURA_SKIN_RANDOM], command))
            aura = AURA_SKIN_RANDOM;
        else if(Present(auraSwitch[AURA_SKIN_RESET], command))
            aura = AURA_SKIN_RESET;
        else if(Present(auraSwitch[AURA_GOLGOTHA], command))
            aura = AURA_GOLGOTHA;
        else if(Present(auraSwitch[AURA_FOREST], command))
            aura = AURA_FOREST;
        else if(Present(auraSwitch[AURA_SNOWQUEEN], command))
            aura = AURA_SNOWQUEEN;
        else if(Present(auraSwitch[AURA_GRAVITATION_WELL], command))
            aura = AURA_GRAVITATION_WELL;
        else if(Present(auraSwitch[AURA_SKIN_RANDOM_SAFE], command))
            aura = AURA_SKIN_RANDOM_SAFE;			
        else
        {
            player.Say(SAY_NETMSG, "Missing/unknown aura switch");
            return;
        }

        player.Say(SAY_NETMSG, "Enabled: " + auraName[aura]);
        player.EraseTimeEvents(CTE_CHEAT_AURA);
        player.AddTimeEvent("cte_Aura", REAL_SECOND(1), CTE_CHEAT_AURA, aura);
    }
    else if(off)
    {
        player.Say(SAY_NETMSG, "Removing current aura");
        player.EraseTimeEvents(CTE_CHEAT_AURA);
        return;
    }
}

uint cte_Aura(Critter& cr, int identifier, uint& value)
{
    Map@ map = cr.GetMap();

    if(!valid(map))
        return(REAL_SECOND(5));

    int aura = value;     // yea
    if(!EnumContains("auraNumber", aura) || aura == AURA_RESERVED)
    {
        cr.Say(SAY_NETMSG, "Unknown aura<" + aura + ">, disabling");
        return(0);
    }

    int  flags = 0;
    uint radius = 5;
    uint findCritters = 0, foundCritters = 0;
    uint pulse = REAL_SECOND(1);

    switch(aura)
    {
    case AURA_KNOCKBACK_ALL:
        SETFLAG(flags, AURA_FLAG_VISIBLE | AURA_FLAG_KNOCKBACK | AURA_FLAG_NEED_CRITTERS | AURA_FLAG_IGNORE_ADMINS);
        findCritters = FIND_LIFE;
        break;

    case AURA_KNOCKBACK_NPC:
        SETFLAG(flags, AURA_FLAG_VISIBLE | AURA_FLAG_KNOCKBACK | AURA_FLAG_NEED_CRITTERS);
        findCritters = FIND_LIFE | FIND_ONLY_NPC;
        break;

    case AURA_KNOCKBACK_PLAYER:
        SETFLAG(flags, AURA_FLAG_VISIBLE | AURA_FLAG_KNOCKBACK | AURA_FLAG_NEED_CRITTERS | AURA_FLAG_IGNORE_ADMINS);
        findCritters = FIND_LIFE | FIND_ONLY_PLAYERS;
        break;

    case AURA_KILL_ALL:
        SETFLAG(flags, AURA_FLAG_VISIBLE | AURA_FLAG_KNOCKBACK_SIMPLE | AURA_FLAG_NEED_CRITTERS | AURA_FLAG_IGNORE_ADMINS);
        findCritters = FIND_LIFE;
        break;

    case AURA_KILL_NPC:
        SETFLAG(flags, AURA_FLAG_VISIBLE | AURA_FLAG_KNOCKBACK_SIMPLE | AURA_FLAG_NEED_CRITTERS);
        findCritters = FIND_LIFE | FIND_ONLY_NPC;
        break;

    case AURA_KILL_PLAYER:
        SETFLAG(flags, AURA_FLAG_VISIBLE | AURA_FLAG_KNOCKBACK_SIMPLE | AURA_FLAG_NEED_CRITTERS | AURA_FLAG_IGNORE_ADMINS);
        findCritters = FIND_LIFE | FIND_ONLY_PLAYERS;
        break;

    case AURA_SKIN_RANDOM:
        SETFLAG(flags, AURA_FLAG_VISIBLE | AURA_FLAG_KNOCKBACK | AURA_FLAG_NEED_CRITTERS);
        #ifdef __DEBUG__
        findCritters = FIND_LIFE;
        #endif
        #ifndef __DEBUG__
        findCritters = FIND_LIFE | FIND_ONLY_PLAYERS;
        #endif
        break;

    case AURA_SKIN_RESET:
        SETFLAG(flags, AURA_FLAG_VISIBLE | AURA_FLAG_KNOCKBACK_SIMPLE | AURA_FLAG_NEED_CRITTERS | AURA_FLAG_IGNORE_ADMINS);
        #ifdef __DEBUG__
        findCritters = FIND_LIFE;
        #endif
        #ifndef __DEBUG__
        findCritters = FIND_LIFE | FIND_ONLY_PLAYERS;
        #endif
        break;

    case AURA_GOLGOTHA:
    case AURA_FOREST:
        break;

    case AURA_SNOWQUEEN:
        SETFLAG(flags, AURA_FLAG_NEED_CRITTERS | AURA_FLAG_IGNORE_ADMINS);
        findCritters = FIND_LIFE;
        pulse = REAL_SECOND(5);
        break;

    case AURA_GRAVITATION_WELL:
        SETFLAG(flags, AURA_FLAG_KNOCKBACK | AURA_FLAG_NEED_CRITTERS | AURA_FLAG_IGNORE_ADMINS | AURA_FLAG_GRAVITY_PULL);
        findCritters = FIND_LIFE;
        radius = 20;
        break;

    case AURA_SKIN_RANDOM_SAFE:
        SETFLAG(flags, AURA_FLAG_VISIBLE | AURA_FLAG_KNOCKBACK | AURA_FLAG_NEED_CRITTERS);
        #ifdef __DEBUG__
        findCritters = FIND_LIFE;
        #endif
        #ifndef __DEBUG__
        findCritters = FIND_LIFE | FIND_ONLY_PLAYERS;
        #endif
        break;
		
    default:
        SETFLAG(flags, AURA_FLAG_VISIBLE);
        break;
    }

    array<Critter@> crits;
    if(FLAG(flags, AURA_FLAG_NEED_CRITTERS))
    {
        foundCritters = map.GetCrittersHex(cr.HexX, cr.HexY, radius, findCritters, crits);
        for(uint c = 0; c < foundCritters; c++)
        {
            if(crits[c].Id == cr.Id)
            {
                crits.removeAt(c);
                foundCritters--;
                break;
            }
        }
    }

    if(FLAG(flags, AURA_FLAG_VISIBLE))
    {
        uint16 stepX = cr.HexX;
        uint16 stepY = cr.HexY;

        map.MoveHexByDir(stepX, stepY, 4, radius);
        for(uint8 stepDir = 0; stepDir < 6; stepDir++)
        {
            for(uint step = 0; step < radius; step++)
            {
                map.MoveHexByDir(stepX, stepY, stepDir, 1);
                map.RunEffect(PID_EXPLODE_EMP, stepX, stepY, 0);
            }
        }

        if(foundCritters > 0)
            map.RunEffect(PID_EXPLODE_EMP, cr.HexX, cr.HexY, CLAMP(foundCritters / radius, 0, radius - 1));
    }

    if(FLAG(flags, AURA_FLAG_NEED_CRITTERS))
    {
        int[] knock = { ANIM2_DEAD_BURN, ANIM2_DEAD_PULSE };
        int[] death = { ANIM2_DEAD_PULSE, ANIM2_DEAD_PULSE_DUST, ANIM2_DEAD_BURN, ANIM2_DEAD_BURN_RUN  };

        for(uint c = 0; c < foundCritters; c++)
        {
            if(!valid(crits[c]))
                continue;

            if(crits[c].IsPlayer() && FLAG(flags, AURA_FLAG_IGNORE_ADMINS) && crits[c].GetAccess() == ACCESS_ADMIN)
                continue;

            if(!GodOfTheRealm(crits[c].Id))
            {
                if(FLAG(flags, AURA_FLAG_KNOCKBACK) || FLAG(flags, AURA_FLAG_KNOCKBACK_SIMPLE) || FLAG(flags, AURA_FLAG_GRAVITY_PULL))
                {
                    uint16 knockbackX = cr.HexX, knockbackY = cr.HexY;
                    if(FLAG(flags, AURA_FLAG_GRAVITY_PULL))
                        map.GetHexCoordWall(crits[c].HexX, crits[c].HexY, knockbackX, knockbackY, 0.0f, Random(radius, radius * 2) - (crits[c].Stat[ST_STRENGTH] / 4));
                    else
                        map.GetHexCoordWall(crits[c].HexX, crits[c].HexY, knockbackX, knockbackY, (Random(180 - Random(0, 25), 180 + Random(0, 25))), Random(radius, radius * 2) - (crits[c].Stat[ST_STRENGTH] / 4));

                    map.PlaySound("was1xxx" + Random(1, 2), crits[c].HexX, crits[c].HexY, 5);
                    map.RunEffect(PID_EXPLODE_EMP, crits[c].HexX, crits[c].HexY, 0);

                    if(FLAG(flags, AURA_FLAG_KNOCKBACK_SIMPLE))
                        crits[c].ToKnockout(0, 0, 0, 0, knockbackX, knockbackY);
                    else
                        crits[c].ToKnockout(knock[Random(0, knock.length() - 1)], ANIM2_DEAD_PRONE_FRONT, ANIM2_STANDUP_FRONT, crits[c].Stat[ST_ACTION_POINTS] - Random(0, crits[c].Stat[ST_LUCK] / 2), knockbackX, knockbackY);
                }


                if(aura == AURA_KILL_ALL || aura == AURA_KILL_NPC || aura == AURA_KILL_PLAYER)
                {
                    crits[c].ToDead(death[Random(0, death.length() - 1)], null);
                }
                else if(aura == AURA_SKIN_RANDOM)
                {
                    // ??? how to get enabled crtypes list without warnings flood ???
                    // no idea, enabled for pre-wipe anyway

                    uint skin = Random(1, 134);
                    if(crits[c].ChangeCrType(skin))
                    {
                        crits[c].StatBase[ST_BASE_CRTYPE] = skin;
                        crits[c].DisguisedBy = cr.Id;
                    }
                }
                else if(aura == AURA_SKIN_RESET)
                {
                    bool  isMale = (crits[c].StatBase[ST_GENDER] == GENDER_MALE);
                    uint  baseType = (isMale ? CRTYPE_MALE_DEFAULT : CRTYPE_FEMALE_DEFAULT);
                    uint  crType = baseType;

                    Item@ armor = crits[c].GetItem(0, SLOT_ARMOR);
                    if(valid(armor))
                    {
                        switch(GetCritterAnimType(crType))
                        {
                        case ANIM_TYPE_FALLOUT:
                            crType = (isMale ? armor.Proto.Armor_CrTypeMale : armor.Proto.Armor_CrTypeFemale);
                            break;
                        }
                    }

                    crits[c].ChangeCrType(crType);
                    crits[c].StatBase[ST_BASE_CRTYPE] = baseType;
                    crits[c].DisguisedBy = 0;
                }
                else if(aura == AURA_SNOWQUEEN)
                {
                    if(crits[c].IsPlayer())
                        crits[c].RunClientScript("client_timeouts@_add_unsafe", 30, 0, 0, "Frozen", null);

                    MapMessageEx(FLOAT_ENFORCED, FLOAT_MODE_ALL, crits[c], "frozen", crits[c].HexX, crits[c].HexY, 255, COLOR_RGB(255, 255, 255), true, -50, 50, -20, -50);
                    crits[c].Wait(30000);
                }
            }
        }
    }
    else     // !FLAG( flags, AURA_FLAG_NEED_CRITTERS ))
    {
        array<Item@> items;
        {
            array<Item@> tempItems;
            int          foundItems = map.GetItems(cr.HexX, cr.HexY, radius, PID_UNVISIBLE_BLOCK, tempItems);
            for(int i = 0; i < foundItems; i++)
            {
                if(tempItems[i].Val8 == SPECIAL_ITEM_AURA)
                    items.insertLast(tempItems[i]);
            }
        }

        if(items.length() >= radius * 2)
            return(REAL_SECOND(1));

        if(aura == AURA_GOLGOTHA)
        {
            Item@ stake = map.AddItem(cr.HexX + Random(-radius, radius), cr.HexY + Random(-radius, radius), PID_UNVISIBLE_BLOCK, 1);
            if(valid(stake))
            {
                int num = Random(1, 12);
                stake.PicMap = GetStrHash("art\\scenery\\stake" + (num < 10 ? "0" : "") + num + ".frm");
                stake.PicInv = GetStrHash("art\\scenery\\stake" + (num < 10 ? "0" : "") + num + ".frm");
                stake.Val8 = SPECIAL_ITEM_AURA;
                _SetSpawner(stake, cr);                // it's never legit ;)
                stake.Update();
            }
        }
        else if(aura == AURA_FOREST)
        {
            Item@ tree = map.AddItem(cr.HexX + Random(-radius, radius), cr.HexY + Random(-radius, radius), PID_UNVISIBLE_BLOCK, 1);
            if(valid(tree))
            {
                int num = Random(1, 11);
                tree.PicMap = GetStrHash("art\\scenery\\tree" + num + ".frm");
                tree.PicInv = GetStrHash("art\\scenery\\tree" + num + ".frm");
                tree.Val8 = SPECIAL_ITEM_AURA;
                _SetSpawner(tree, cr);                // it's never legit ;)
                tree.Update();
            }
        }
    }

    cr.RefreshVisible();
    return(pulse);
}

void ExecAuraCleanupCommand(array<string@>@ command, Critter@ player)
{
    Map@ map = player.GetMap();
    if(!valid(map))
    {
        player.Say(SAY_NETMSG, "Not on worldmap.");
        return;
    }

    array<Item@> items;
    uint         count = map.GetItems(PID_UNVISIBLE_BLOCK, items);
    uint         deleted = 0;
    for(uint i = 0; i < count; i++)
    {
        if(items[i].Val8 == SPECIAL_ITEM_AURA)
        {
            DeleteItem(items[i]);
            deleted++;
        }
    }

    player.Say(SAY_NETMSG, "Removed " + deleted + " item" + (deleted > 1 ? "s" : ""));
}

// admin access
bool IsAdmin(Critter& player)
{
    return player.GetAccess() >= ACCESS_ADMIN;
}

bool IsGM(Critter& player)
{
    return player.GetAccess() >= ACCESS_MODER;
}

int AllowParameterIfAccess(int access, uint parameter, Critter& fromCr, Critter& toCr)
{
    if(access <= ACCESS_CLIENT || toCr.GetAccess() < access)
        return(0);

    return(fromCr.Param[parameter]);
}

int AllowParameterIfTester(uint parameter, Critter& fromCr, Critter& toCr)
{
    return(AllowParameterIfAccess(ACCESS_TESTER, parameter, fromCr, toCr));
}

int AllowParameterIfModer(uint parameter, Critter& fromCr, Critter& toCr)
{
    return(AllowParameterIfAccess(ACCESS_MODER, parameter, fromCr, toCr));
}

int AllowParameterIfAdmin(uint parameter, Critter& fromCr, Critter& toCr)
{
    return(AllowParameterIfAccess(ACCESS_ADMIN, parameter, fromCr, toCr));
}

int AllowParameterIfGod(uint parameter, Critter& fromCr, Critter& toCr)
{
    if(!GodOfTheRealm(toCr.Id))
        return(0);

    return(fromCr.Param[parameter]);
}

//
// Executes command
//
void unsafe_ExecCommand(Critter& player, int p0, int p1, int p2, string@ commandString, array<int>@ data)
{
    if(player.GetAccess() < ACCESS_TESTER)
        return;
    if(GetLvar(player, LVAR_authed_char) == 0)       // Move all this to GetAccess handler when we have one.
    {
        SetLvar(player, LVAR_authed_char, 1);
        SetCritterEvents(player);
    }

    ExecCommand(player, p0, p1, p2, commandString, data);
}

void ExecCommand(Critter& player, int p0, int p1, int p2, string@ commandString, array<int>@ data)
{
    if(player.GetAccess() < ACCESS_TESTER)
        return;                                         // it's here, not only inside the unsafe_ wrapper, because it's called in replays etc.
    if(!valid(commandString))
        return;

    ExecCommand(player, commandString);
}

// bool, for broken macros
bool ExecCommand(Critter& player, string@ commandString)
{
    if(player.GetAccess() < ACCESS_TESTER)
        return(false);                                           // it's here, not only inside the unsafe_ wrapper, because it's called in replays etc.
    if(!valid(commandString))
        return(false);

    if(stringReplaceText(commandString, "|", "") > 0)
    {
        player.Say(SAY_NETMSG, "" + COLOR_RGB(255, 0, 0) + " Illegal character found, command ignored.");     // yea
        return(false);
    }

    Preprocess(player, commandString);

    array<string@>@ command = split(commandString, " ");
    string name = GetSafePlayerName(player.Id);
    uint   id = 0;
    // two global target specifying methods -p for players -n for npcs
    string targetName = GetParameterString(command, "-p");
    string npcId = GetParameterString(command, "-n");

    StrToInt(targetName, id);
    // DLog("name: " + targetName + ", id: " + id);
    Critter@ target;
    uint     targetId = 0;

    // have to be player name
    if(targetName != "")
    {
        if(id == 0)
        {
            @target = GetPlayer(targetName);
            targetId = GetPlayerId(targetName);
        }
        else
        {
            // id
            @target = GetCritter(id);
            targetId = id;
        }
    }
    if(npcId != "")
    {
        StrToInt(npcId, id);
        if(id != 0)
            @target = GetCritter(NPC_BASE_ID + id);
    }

    if(!valid(target))
    {
        DLog("Target not valid, defaulting to player");
        @target = @player;
        targetId = player.Id;
    }

    if((command[1] == "init") && (!CheatsInitialized))
    {
        player.Say(SAY_NETMSG, "Running Init");
        InitCheats(false);
        return(true);
    }

    if(!GodOfTheRealm(player.Id) && GodOfTheRealm(target.Id) && _CritHasExtMode(target, MODE_EXT_GOD))
    {
        @target = @player;
        targetId = player.Id;
    }

    #ifndef __DEBUG__
    // check if player is authorized
    if(!IsAllowed(player.Id, command[1]))
    {
        player.Say(SAY_NETMSG, "Unknown command or insufficient privileges.");
        return(false);
    }
    #endif

    /*
       // all checks should be done at this moment, let's help our noob-GMs/devs!
       if( command.length() >= 3 && command[2].length() == 5 && command[2] == "-help" )
       {
            CheatHelpShow( player, "`"+command[1] );
            return;
       }
     */

    // [1] cause zero is command to invoke the listener
    if(command[1] == "accesslist")
    {
        ExecAccessListCommand(command, player);
    }
    else if(command[1] == "addbankmoney")
    {
        ExecBankMoney(command, player, true);
    }
    else if(command[1] == "addfollower")
    {
        ExecAddNpcCommand(command, player, target, false, true);
    }
    else if(command[1] == "addmob")
    {
        ExecAddNpcCommand(command, player, target, true, false);
    }
    else if(command[1] == "addnpc")
    {
        ExecAddNpcCommand(command, player, target, false, false);
    }
    else if(command[1] == "airstrike")
    {
        ExecAirstrikeCommand(command, player, target);
    }
    else if(command[1] == "alts")
    {
        ExecAltsCommand(command, player);
    }
// else if(command[1] == "animate") { ExecAnimateCommand(command, player, target); }
    else if(command[1] == "antiblock")
    {
        ExecAntiblockCommand(command, player);
    }
    else if(command[1] == "aura")
    {
        ExecAuraCommand(command, player);
    }
    else if(command[1] == "auracleanup")
    {
        ExecAuraCleanupCommand(command, player);
    }
    else if(command[1] == "spawnpoint")
    {
        ExecSpawnPointCommand(command, player);
    }
    else if(command[1] == "append")
    {
        ExecSayCommand(command, player, target, SAY_APPEND);
    }
    else if(command[1] == "bc")
    {
        ExecBroadcastCommand(command, player);
    }
    else if(command[1] == "blockers")
    {
        ExecBlockersCommand(command, player, target);
    }
    else if(command[1] == "broadcast")
    {
        ExecBroadcastCommand(command, player);
    }
    else if(command[1] == "changefaction")
    {
        ExecChangeFactionCommand(command, player, target);
    }
    else if(command[1] == "changerank")
    {
        ExecChangeRankCommand(command, player, target);
    }
    else if(command[1] == "checkbank")
    {
        ExecCheckBankCommand(command, player);
    }
    else if(command[1] == "checkbanks")
    {
        ExecCheckBanksCommand(command, player);
    }
    else if(command[1] == "checkbankaccount")
    {
        ExecCheckBankAccount(command, player, false);
    }
    else if(command[1] == "checkbankaccounts")
    {
        ExecCheckBankAccount(command, player, true);
    }
    else if(command[1] == "checktown")
    {
        ExecCheckTownCommand(command, player);
    }
    else if(command[1] == "cleanup")
    {
        ExecCleanupCommand(command, player);
    }
    else if(command[1] == "clearallillegalflags")
    {
        ExecClearAllIllegalFlagsCommand(command, player);
    }
    else if(command[1] == "clearenemystack")
    {
        ExecClearEnemyStackCommand(command, player, target, false);
    }
    else if(command[1] == "clearenemystacks" || command[1] == "ces")
    {
        ExecClearEnemyStackCommand(command, player, target, true);
    }
    else if(command[1] == "clearinventory")
    {
        ExecClearInventoryCommand(command, player, target);
    }
    else if(command[1] == "clearillegalflags")
    {
        ClearIllegalFlags(target);
    }
    else if(command[1] == "cleartimeouts" || command[1] == "cto")
    {
        ExecClearTimeoutsCommand(command, player, target);
    }
    else if(command[1] == "clone")
        ExecCloneCommand(command, player, target);
    else if(command[1] == "condition")
    {
        ExecConditionCommand(command, player, target);
    }
    else if(command[1] == "controlmobs")
    {
        ExecControlMobsCommand(command, player, target);
    }
    else if(command[1] == "controlnpc")
    {
        ExecControlNpcCommand(command, player, target);
    }
    else if(command[1] == "corecheats")
    {
        ExecCoreCheats(command, player);
    }
    else if(command[1] == "countitems")
    {
        ExecCountItemsCommand(command, player);
    }
    else if(command[1] == "createlocation")
    {
        ExecCreateLocationCommand(command, player);
    }
    else if(command[1] == "criticalchance")
    {
        ExecCriticalChance(command, player, target);
    }
    else if(command[1] == "critterinfo" || command[1] == "crinfo")
    {
        ExecCritterInfoCommand(command, player, target);
    }
    else if(command[1] == "damage")
    {
        ExecDamageCommand(command, player, target);
    }
    else if(command[1] == "deathincarnate")
    {
        ExecDeathIncarnateCommand(command, player, target);
    }
    else if(command[1] == "deathmatch")
    {
        ExecDeathmatchCommand(command, player);
    }
    else if(command[1] == "deletelocation")
    {
        ExecDeleteLocationCommand(command, player);
    }
    else if(command[1] == "devenable")
    {
        ExecDevEnableCommand(command, player);
    }
    else if(command[1] == "dialog")
    {
        ExecSayCommand(command, player, target, SAY_DIALOG);
    }
    else if(command[1] == "disabledismantling")
    {
        ExecMapDismantling(player, false);
    }
    else if(command[1] == "disablegrids")
    {
        ExecMapGrids(player, false);
    }
    else if(command[1] == "disablepvp")
    {
        ExecMapPvp(player, false);
    }
    else if(command[1] == "disabletb")
    {
        ExecSetTurnbasedCombat(player, false);
    }
    else if(command[1] == "disguise")
    {
        ExecDisguiseCommand(command, player, target);
    }
    else if(command[1] == "disguiseinfo")
    {
        ExecDisguiseInfoCommand(command, player);
    }
    else if(command[1] == "dismiss")
    {
        ExecDismissCommand(command, player, target, false);
    }
    else if(command[1] == "dismissteam")
    {
        ExecDismissCommand(command, player, target, true);
    }
    else if(command[1] == "dropalltimeouts")
    {
        ExecClearAllTimeoutsCommand(command, player);
    }
    else if(command[1] == "dropitems")
    {
        ExecDropItemsCommand(command, player, target);
    }
    else if(command[1] == "dropdrugs")
    {
        ExecDropDrugsCommand(command, player, target);
    }
    else if(command[1] == "emote")
    {
        ExecSayCommand(command, player, target, SAY_EMOTE);
    }
    else if(command[1] == "emoteh")
    {
        ExecSayCommand(command, player, target, SAY_EMOTE_ON_HEAD);
    }
    else if(command[1] == "explode")
    {
        ExecExplodeCommand(command, player, target);
    }
    else if(command[1] == "enabledismantling")
    {
        ExecMapDismantling(player, true);
    }
    else if(command[1] == "enablegrids")
    {
        ExecMapGrids(player, true);
    }
    else if(command[1] == "enablepvp")
    {
        ExecMapPvp(player, true);
    }
    else if(command[1] == "enabletb")
    {
        ExecSetTurnbasedCombat(player, true);
    }
    else if(command[1] == "factionnews")
    {
        ExecFactionNews(command, player);
    }
    else if(command[1] == "factioninfo")
    {
        ExecFactionInfoCommand(command, player, target, false);
    }
    else if(command[1] == "factiononline")
    {
        ExecFactionOnlineCommand(command, player);
    }
    else if(command[1] == "findchars")
        ExecFindCharsCommand(command, player);
    else if(command[1] == "finditems")
    {
        ExecFindItemsCommand(command, player);
    }
    else if(command[1] == "findnpc")
    {
        ExecFindNpcCommand(command, player);
    }
    else if(command[1] == "flash")
    {
        ExecSayCommand(command, player, target, SAY_FLASH_WINDOW);
    }
    else if(command[1] == "foart")
    {
        ExecFOArt(command, player);
    }
    else if(command[1] == "gaintowncontrol")
    {
        ExecGainTownControlCommand(command, player);
    }
    else if(command[1] == "gameinfo")
    {
        ExecGameInfoCommand(command, player);
    }
    else if(command[1] == "getcolor")
    {
        ExecGetColorCommand(command, player);
    }
    else if(command[1] == "getclaim")
    {
        ExecGetClaimCommand(command, player);
    }
    else if(command[1] == "getclaimtime")
    {
        ExecGetClaimTimeCommand(command, player);
    }
    else if(command[1] == "getleader")
    {
        ExecGetLeaderCommand(command, player);
    }
    else if(command[1] == "getitems")
    {
        ExecGetItemsCommand(command, player, target);
    }
    else if(command[1] == "getleadertime")
    {
        ExecGetLeaderTimeCommand(command, player);
    }
    else if(command[1] == "getrequests")
    {
        ExecGetRequestsCommand(command, player);
    }
    else if(command[1] == "getuvar")
    {
        ExecGetUVarCommand(command, player, target);
    }
    else if(command[1] == "getvar")
    {
        ExecGetVarCommand(command, player, targetId);
    }
    else if(command[1] == "give")
    {
        ExecGiveCommand(command, player, target);
    }
    else if(command[1] == "givekey")
    {
        ExecGiveKeyCommand(command, player, target);
    }
    else if(command[1] == "goto")
        ExecGoToCommand(command, player, target, false);
    else if(command[1] == "gototeam")
        ExecGoToCommand(command, player, target, true);
    else if(command[1] == "heal")
    {
        ExecHealCommand(command, player, target);
    }
    else if(command[1] == "healall")
    {
        ExecHealAllCommand(command, player);
    }
// else if(command[1] == "help") { ExecHelpCommand(command, player); } // -> cheats_help.fos
    else if(command[1] == "hideloc")
        ExecLocVisCommand(command, player, target, false);
    else if(command[1] == "hidemap")
    {
        ExecHideMapCommand(command, player);
    }
    else if(command[1] == "iddqd")
    {
        ExecGodCommand(command, player);
    }
    else if(command[1] == "idkfa")
    {
        ExecIDKFACommand(command, player, target);
    }
    else if(command[1] == "id2name")
    {
        ExecIdToNameCommand(command, player);
    }
    else if(command[1] == "inspect")
    {
        ExecInspectCommand(command, player);
    }
    else if(command[1] == "irradiate")
    {
        ExecIrradiateCommand(command, player, target);
    }
    else if(command[1] == "itemflags")
    {
        ExecItemFlagsCommand(command, player);
    }
    else if(command[1] == "itemlight")
    {
        ExecItemLightCommand(command, player);
    }
    else if(command[1] == "itemproto")
    {
        ExecItemProtoCommand(command, player);
    }
    else if(command[1] == "karma")
    {
        ExecKarmaCommand(command, player, target, false);
    }
    else if(command[1] == "karmateam")
    {
        ExecKarmaCommand(command, player, target, true);
    }
    else if(command[1] == "kill")
    {
        ExecKillCommand(command, player, target);
    }
    else if(command[1] == "killeradmin")
    {
        ExecKillerAdminCommand(command, player);
    }
    else if(command[1] == "killmobs")
    {
        ExecKillMobsCommand(command, player);
    }
    else if(command[1] == "lastregistered")
    {
        ExecLastRegisteredCommand(command, player);
    }
    else if(command[1] == "lastspawned")
    {
        ExecLastSpawnedCommand(command, player, target);
    }
    else if(command[1] == "log")
    {
        ExecLogCommand(command, player);
    }
    else if(command[1] == "listauthenticated" || command[1] == "la")
    {
        ExecListAuthenticatedCommand(command, player);
    }
    else if(command[1] == "listcommands")
    {
        ExecListCommandsCommand(command, player);
    }
    else if(command[1] == "listfactions")
    {
        ExecFactionInfoCommand(command, player, null, true);
    }
    else if(command[1] == "listfollowers")
    {
        ExecListFollowersCommand(command, player, target);
    }
    else if(command[1] == "listmaps")
    {
        ExecListMapsCommand(command, player);
    }
    else if(command[1] == "listplayers" || command[1] == "lp")
    {
        ExecListPlayersCommand(command, player);
    }
    else if(command[1] == "listtents")
    {
        ExecTentListCommand(command, player);
    }
    else if(command[1] == "listtracked" || command[1] == "lt")
    {
        ExecListTrackedPlayersCommand(command, player);
    }
    else if(command[1] == "lock")
        ExecLockCommand(command, player, target);
    else if(command[1] == "lockcar")
        ExecLockCarCommand(command, player, true);
    else if(command[1] == "makeencounter")
    {
        ExecMakeEncounterCommand(command, player);
    }
    else if(command[1] == "mapinfo")
    {
        ExecMapInfoCommand(command, player);
    }
    else if(command[1] == "modchar")
    {
        ExecModCharCommand(command, player, target);
    }
    else if(command[1] == "move")
    {
        ExecMoveCommand(command, player, target);
    }
    else if(command[1] == "name2id")
    {
        ExecNameToIdCommand(command, player, target);
    }
    else if(command[1] == "netmsg")
    {
        ExecSayCommand(command, player, target, SAY_NETMSG);
    }
    else if(command[1] == "normaldeadly")
    {
        ExecNormalDeadlyCommand(command, player, target);
    }
    else if(command[1] == "numplayers")
    {
        player.Say(SAY_NETMSG, "There are " + GetNumberOfPlayersOnline() + " players online right now");
    }
    else if(command[1] == "param")
    {
        ExecParamCommand(command, player, target);
    }
    else if(command[1] == "perkadjust")
    {
        ExecPerkAdjust(command, player, target);
    }
    else if(command[1] == "pickitems")
    {
        ExecPickItemsCommand(command, player, target);
    }
    else if(command[1] == "phase")
    {
        ExecShiftCommand(command, player, target, false, true);
    }
    else if(command[1] == "phaseteam")
    {
        ExecShiftCommand(command, player, target, true, true);
    }
    else if(command[1] == "playerkarma")
    {
        ExecPlayerKarmaCommand(command, player, target, false);
    }
    else if(command[1] == "playmusic")
    {
        ExecPlayMusicCommand(command, player);
    }
    else if(command[1] == "playsound")
    {
        ExecPlaySoundCommand(command, player, false);
    }
    else if(command[1] == "playspeech")
    {
        ExecPlaySoundCommand(command, player, true);
    }
    else if(command[1] == "profadjust")
    {
        ExecProfAdjust(command, player, target);
    }
    else if(command[1] == "registerfaction")
    {
        ExecRegisterFactionCommand(command, player);
    }
    else if(command[1] == "removebankmoney")
    {
        ExecBankMoney(command, player, false);
    }
    else if(command[1] == "removefaction")
        ExecRemoveFactionCommand(command, player);
    else if(command[1] == "removeitems")
    {
        ExecRemoveItemsCommand(command, player);
    }
    else if(command[1] == "reservednickname")
    {
        ExecReservedNicknameCommand(command, player);
    }
    else if(command[1] == "resetalldisguises")
    {
        ExecResetAllDisguisesCommand(command, player);
    }
    else if(command[1] == "resetprices")
    {
        InitPrices();
    }
    else if(command[1] == "resetreputations")
        ExecResetReputationsCommand(command, player, target);
    else if(command[1] == "resettown")
    {
        ExecResetTownCommand(command, player, false);
    }
    else if(command[1] == "resettowns")
    {
        ExecResetTownCommand(command, player, true);
    }
    else if(command[1] == "resetworldmap")
    {
        ExecResetWorldMapCommand(command, player);
    }
    else if(command[1] == "respawn" || command[1] == "revive")
    {
        ExecRespawnCommand(command, player, target);
    }
    else if(command[1] == "respawnall" || command[1] == "reviveall")
    {
        ExecRespawnAllCommand(command, player);
    }
    else if(command[1] == "respawnallplayers" || command[1] == "reviveallplayers")
    {
        ExecRespawnAllCommand(command, player);
    }
// else if(command[1] == "riddle") { ExecRiddleCommand(command, player); }
    else if(command[1] == "rotate")
    {
        ExecRotateCommand(command, player, target);
    }
    else if(command[1] == "rundialog")
    {
        ExecRunDialog(command, player, target);
    }
    else if(command[1] == "saferegen")
    {
        ExecSafeRegenCommand(command, player);
    }
    else if(command[1] == "say")
    {
        ExecSayCommand(command, player, target, SAY_NORM);
    }
    else if(command[1] == "sayh")
    {
        ExecSayCommand(command, player, target, SAY_NORM_ON_HEAD);
    }
    else if(command[1] == "setanim")
    {
        ExecSetAnimCommand(command, player, target, false);
    }
    else if(command[1] == "masssetanim")
    {
        ExecSetAnimCommand(command, player, target, true);
    }
    else if(command[1] == "setfaction")
    {
        ExecSetFactionCommand(command, player, target);
    }
    else if(command[1] == "sethp")
    {
        ExecSetHPCommand(command, player, target);
    }
    else if(command[1] == "setlexem")
    {
        ExecSetLexemCommand(command, player, target);
    }
    else if(command[1] == "setperk")
    {
        ExecSetPerkCommand(command, player, target);
    }
    else if(command[1] == "setmapdata")
    {
        ExecSetMapDataCommand(command, player);
    }
    else if(command[1] == "setlocvisibility")
    {
        ExecSetLocVisibility(command, player);
    }
    else if(command[1] == "setrain")
    {
        ExecSetRain(command, player);
    }	
    else if(command[1] == "setreputation" || command[1] == "setrep")
    {
        ExecSetReputationCommand(command, player, target);
    }
    else if(command[1] == "settimeout" || command[1] == "sto")
    {
        ExecSetTimeoutCommand(command, player, target);
    }
    else if(command[1] == "setuvar")
    {
        ExecSetUVarCommand(command, player, target);
    }
    else if(command[1] == "setvar")
    {
        ExecSetVarCommand(command, player, targetId);
    }
    else if(command[1] == "shift")
    {
        ExecShiftCommand(command, player, target, false, false);
    }
    else if(command[1] == "shiftteam")
    {
        ExecShiftCommand(command, player, target, true, false);
    }
    else if(command[1] == "shout")
    {
        ExecSayCommand(command, player, target, SAY_SHOUT);
    }
    else if(command[1] == "shouth")
    {
        ExecSayCommand(command, player, target, SAY_SHOUT_ON_HEAD);
    }
    else if(command[1] == "showhands")
    {
        ExecShowHandsCommand(command, player, target);
    }
    else if(command[1] == "showloc")
        ExecLocVisCommand(command, player, target, true);
    else if(command[1] == "showvars")
    {
        ExecShowVarsCommand(command, player, target);
    }
    else if(command[1] == "slap")
    {
        ExecSlapCommand(command, player, target);
    }
    else if(command[1] == "massslap")
    {
        ExecMassSlapCommand(command, player, target);
    }
    else if(command[1] == "startevent")
    {
        ExecStartEventCommand(command, player);
    }
    else if(command[1] == "stopevent")
    {
        ExecStopEventCommand(command, player);
    }
    else if(command[1] == "stoptrackplayer")
    {
        ExecStopTrackPlayerCommand(command, player, target);
    }
    else if(command[1] == "spawncar")
        ExecSpawnCarCommand(command, player, target);
    else if(command[1] == "spawnitem")
        ExecSpawnItemCommand(command, player, target);
    else if(command[1] == "suicide")
    {
        ExecSuicideCommand(command, player);
    }
    else if(command[1] == "summon")
    {
        ExecSummonCommand(command, player, target, false);
    }
    else if(command[1] == "summonteam")
    {
        ExecSummonCommand(command, player, target, true);
    }
    else if(command[1] == "team")
    {
        ExecTeamCommand(command, player, target);
    }
    else if(command[1] == "teleport" || command[1] == "tp")
    {
        ExecTeleportCommand(command, player, target, false);
    }
    else if(command[1] == "teleporter")
    {
        ExecTeleporterCommand(command, player);
    }
    else if(command[1] == "teleportteam")
    {
        ExecTeleportCommand(command, player, target, true);
    }
    else if(command[1] == "tentinfo")
    {
        ExecTentInfoCommand(command, player, target);
    }
    else if(command[1] == "toglobal")
    {
        ExecToGlobal(player, target);
    }
    else if(command[1] == "trackplayer")
    {
        ExecTrackPlayerCommand(command, player, target);
    }
// else if(command[1] == "usedammo") { ExecUsedAmmo(player); }
    else if(command[1] == "unlockcar")
        ExecLockCarCommand(command, player, false);
    else if(command[1] == "whisper")
    {
        ExecSayCommand(command, player, target, SAY_WHISP);
    }
    else if(command[1] == "whisperh")
    {
        ExecSayCommand(command, player, target, SAY_WHISP_ON_HEAD);
    }
    else if(command[1] == "virtualmoney")
    {
        ExecVirtualMoneyCommand(command, player);
    }
    else if(command[1] == "xp")
    {
        ExecXpCommand(command, player, target, false);
    }
    else if(command[1] == "xpteam")
    {
        ExecXpCommand(command, player, target, true);
    }
    else if(command[1] == "zeroext")
    {
        ExecZeroExtCommand(command, player, target);
    }
    else if(command[1] == "zone")
    {
        ExecZoneCommand(command, player);
    }
    else if(command[1] == "zoneplayers")
    {
        ExecZonePlayersCommand(command, player);
    }
    else
    {
        player.Say(SAY_NETMSG, "Unknown command or insufficient privileges.");
        return(false);
    }
    #ifdef __DEBUG__
    // AddAchievement( player, ACHIEVEMENT_GM_ABUSE );
    #endif

    return(true);
}

Serializator serializer;
void LoadEventSpawns()
{
    serializer.Clear();
    if(!serializer.Load("event_spawns"))
        return;

    serializer.Get(eventItems).Get(eventCritters);
}

void SaveEventSpawns()
{
    serializer.Clear();
    serializer.Set(eventItems).Set(eventCritters).Save("event_spawns");
}

void answer_Test(Critter& player, uint answerI, string& answerS)
{
    player.Say(SAY_NETMSG, "" + answerI + ", " + answerS);
}

bool _UseSkill(Item& item, Critter& crit, int skill)
{
    crit.Say(SAY_NETMSG, "Use: " + skill);
    if(skill == SK_LOCKPICK)
    {
        if(Random(0, 9) == 0)
        {
            crit.Say(SAY_NETMSG, "Picked");
            item.LockerCondition = LOCKER_ISOPEN;
            item.Update();
        }
        return true;
    }
    return false;
}

void checkbot(Critter& cr, int playerId, int, int)
{
    int      id = cr.Id;
    id ^= 0x1B7D5C7E;
    Critter@ tocheck = GetCritter(playerId);
    if(!valid(tocheck) || tocheck.IsNpc())
    {
        cr.Say(SAY_NETMSG, "Invalid player.");
        return;
    }
    tocheck.RunClientScript("client_main@_ResetTimer", id, Random(0, 0xFF), Random(0, 0xFFFF), null, null);
}

#pragma bindfunc "uint Critter::GetIp() -> Utils.dll Critter_GetIp"

void ip(Critter& cr, int, int, int)
{
    uint ip = cr.GetIp();
    cr.Say(SAY_NETMSG, "ip=" + ip);
    if(ip > 0)
    {
        string result = "";
        for(uint i = 0; i < 4; i++)
        {
            result += (i == 0 ? "" : ".") + ((ip >> (i * 8)) & 0xFF);
        }
        cr.Say(SAY_NETMSG, "ip=" + result);
    }
}

///////////////////////////////////////////////////////////////////////////////////

class FakeCombat
{
    private uint        target;
    private array<uint> result;

    FakeCombat()
    {
        this.Clear();
    }

    FakeCombat(Critter & cr)
    {
        this.Clear();
        this.Target(cr);
    }

    private void New(uint what) final
    {
        this.result.insertLast(what);
        this.result.insertLast(this.target);
    }

    FakeCombat@ Clear()
    {
        this.target = 0;
        this.result.resize(0);

        return(this);
    }

    FakeCombat@ Target(Critter& cr)
    {
        this.target = cr.Id;

        return(this);
    }

    FakeCombat@ Miss()
    {
        this.New(CMSG_MISS);

        return(this);
    }

    FakeCombat@ CritMiss(uint effects)
    {
        this.New(CMSG_CRIT_MISS);
        this.result.insertLast(effects);

        return(this);
    }

    FakeCombat@ CritMissDamage(uint effects, uint damage)
    {
        this.New(CMSG_CRIT_MISS_DAMAGE);
        this.result.insertLast(effects);
        this.result.insertLast(damage);

        return(this);
    }

    FakeCombat@ Oops(uint who2)
    {
        this.New(CMSG_OOPS);
        this.result.insertLast(who2);

        return(this);
    }

    FakeCombat@ Hit(uint damage)
    {
        this.New(CMSG_HIT);
        this.result.insertLast(damage);

        return(this);
    }

    FakeCombat@ HitRandomly()
    {
        this.New(CMSG_HIT_RANDOMLY);

        return(this);
    }

    FakeCombat@ HitDead(uint damage)
    {
        this.New(CMSG_HIT_DEAD);
        this.result.insertLast(damage);

        return(this);
    }

    FakeCombat@ AimedHit(uint location, uint damage)
    {
        this.New(CMSG_AIMED_HIT);
        this.result.insertLast(location);
        this.result.insertLast(damage);

        return(this);
    }

    FakeCombat@ AimedHitDead(uint location, uint damage)
    {
        this.New(CMSG_AIMED_HIT_DEAD);
        this.result.insertLast(location);
        this.result.insertLast(damage);

        return(this);
    }

    FakeCombat@ CritHit(uint damage, uint effect, uint message)
    {
        this.New(CMSG_CRIT_HIT);
        this.result.insertLast(damage);
        this.result.insertLast(effect);
        this.result.insertLast(message);

        return(this);
    }

    FakeCombat@ CritHitDead(uint damage, uint effect, uint message)
    {
        this.New(CMSG_CRIT_HIT_DEAD);
        this.result.insertLast(damage);
        this.result.insertLast(effect);
        this.result.insertLast(message);

        return(this);
    }

    FakeCombat@ CritAimedHit(uint location, uint damage, uint effect, uint message)
    {
        this.New(CMSG_CRIT_AIMED_HIT);
        this.result.insertLast(location);
        this.result.insertLast(damage);
        this.result.insertLast(effect);
        this.result.insertLast(message);

        return(this);
    }

    FakeCombat@ CritAimedHitDead(uint location, uint damage, uint effect, uint message)
    {
        this.New(CMSG_CRIT_AIMED_HIT_DEAD);
        this.result.insertLast(location);
        this.result.insertLast(damage);
        this.result.insertLast(effect);
        this.result.insertLast(message);

        return(this);
    }

    bool Send()
    {
        Critter@ _target = GetCritter(this.target);
        if(valid(_target))
        {
            Critter@[] realTarget = { _target };
            array<Critter@> crits;
            uint            count = _target.GetMap().GetCrittersSeeing(realTarget, true, FIND_ALL | FIND_ONLY_PLAYERS, crits);
            for(uint c = 0; c < count; c++)
            {
                this.Send(crits[c]);
                // if( !this.Send( crits[c] ))
                //	return( false );
            }

            return(true);
        }

        return(false);
    }

    bool Send(Critter& cr)
    {
        if(cr.IsNotValid || cr.IsNpc())
            return(false);

        uint len = this.result.length();

        if(len > 0)
        {
            this.result.insertAt(0, ++len);
            cr.SendCombatResult(result);
            this.result.removeAt(0);
        }

        return(true);
    }

    /*
       bool SendText( Critter& cr, string& msg )
       {
            if( cr.IsNotValid || cr.IsNpc() )
                    return( false );

            if( msg.length() > 0 )
            {
                    cr.RunClientScript( "client_messages@combat", 0, 0, 0, msg, null );
                    return( true );
            }

            return( false );
       }

       bool SendText( Critter& cr, uint16 hx, uint16 hy, string& hex, int damage = 0 )
       {
            if( cr.IsNotValid || cr.IsNpc() )
                    return( false );

            if( valid(cr.GetMap()) && hx > 0 && hy > 0 && hex.length() > 0 )
            {
                    cr.RunClientScript( "client_messages@combat", damage, hx, hy, "|"+hex, null );
                    return( true );
            }

            return( false );
       }

       bool SendText( Critter& cr, string& msg, uint16 hx, uint16 hy, string& hex, int damage = 0 )
       {
            if( cr.IsNotValid || cr.IsNpc() || msg.length() == 0 )
                    return( false );

            if( msg.length() > 0 && valid(cr.GetMap()) && hx > 0 && hy > 0 && hex.length() > 0 )
            {
                    cr.RunClientScript( "client_messages@combat", damage, hx, hy, msg+"|"+hex, null );
                    return( true );
            }

            return( false );
       }
     */
};

void ItemEvent(Item& item, int event, string& function)
{
    Critter@ spawner = GetCritter(_GetSpawner(item));
    if(!item.SetEvent(event, function))
    {
        if(valid(spawner))
            spawner.Say(SAY_NETMSG, "Can't set script to \"" + function + "\", removing item.");
        DeleteItem(item);
    }
    else
    {
        if(valid(spawner))
            spawner.Say(SAY_NETMSG, "ItemEvent " + event + " for " + item.Id + " set to " + function);
    }
}

void ItemTypeEvent(Item& item, int type, int event, string& function)
{
    Critter@ spawner = GetCritter(_GetSpawner(item));
    if(item.GetType() != uint(type))
    {
        if(valid(spawner))
            spawner.Say(SAY_NETMSG, "Invalid item type, removing item.");
        DeleteItem(item);
    }
    else
    {
        ItemEvent(item, event, function);
    }
}

///// functions for `give/`spawnitem -script

// weapons
void weapon_disconnect(Item& item, bool firstTime)
{
    ItemTypeEvent(item, ITEM_TYPE_WEAPON, ITEM_EVENT_ATTACK, "weapon_function_disconnect");
}

void weapon_explode(Item& item, bool firstTime)
{
    ItemTypeEvent(item, ITEM_TYPE_WEAPON, ITEM_EVENT_ATTACK, "weapon_function_explode");
}

void weapon_kill(Item& item, bool firstTime)
{
    ItemTypeEvent(item, ITEM_TYPE_WEAPON, ITEM_EVENT_ATTACK, "weapon_function_kill");
}

void weapon_heal(Item& item, bool firstTime)
{
    ItemTypeEvent(item, ITEM_TYPE_WEAPON, ITEM_EVENT_ATTACK, "weapon_function_heal");
}

/*
   void weapon_revive( Item& item, bool firstTime )
   {
        if( firstTime )
                ItemTypeEvent( item, ITEM_TYPE_WEAPON, ITEM_EVENT_ATTACK, "weapon_function_revive" );
   }
 */

void item_sound(Item& item, bool firstTime)
{
    ItemEvent(item, ITEM_EVENT_WALK, "item_function_sound");
}

///// cheated items events

bool weapon_function_disconnect(Item& item, Critter& sadist, Critter& victim)   // ITEM_EVENT_ATTACK
{
    if(sadist.GetAccess() < ACCESS_MODER)
    {
        sadist.Say(SAY_NETMSG, "No.");
        return(true);
    }

    if(victim.IsNpc())
    {
        sadist.Say(SAY_NETMSG, "You can't disconnect NPCs.");
        return(true);
    }

    if(sadist.GetAccess() < victim.GetAccess() || GodOfTheRealm(victim.Id))
    {
        sadist.Say(SAY_NETMSG, "No, you don't.");
        return(true);
    }

    LogCommandUsage(sadist, "ItemEventCheat: disconnected " + victim.Name + "<" + victim.Id + ">");

    sadist.Animate(0, ANIM2_BURST, item, true, false);
    victim.Disconnect();

    return(true);
}

// AS bug : import void MapMessageEx( uint8 type, uint8 mode, Critter& target, string& text, uint16 hexX, uint16 hexY, uint8 delay = 150, uint color = 0, bool fade = true, int8 fromX = 0, int8 toX = 0, int8 fromY = 0, int8 toY = 0 ) from "utils";
import void MapMessageEx(uint8 type, uint8 mode, Critter& target, string& text, uint16 hexX, uint16 hexY, uint8 delay, uint color, bool fade, int8 fromX, int8 toX, int8 fromY, int8 toY) from "utils";

bool weapon_function_explode(Item& item, Critter& sadist, Critter& victim)   // ITEM_EVENT_ATTACK
{
    if(sadist.GetAccess() < ACCESS_MODER)
    {
        sadist.Say(SAY_NETMSG, "No.");
        return(true);
    }

    if(victim.IsDead())
    {
        sadist.Say(SAY_NETMSG, GenderString(victim, "He", "She", "It") + "'s already as dead as possible.");
        return(true);
    }

    LogCommandUsage(sadist, "ItemEventCheat: exploded " + victim.Name + "<" + victim.Id + ">");

    sadist.Animate(0, ANIM2_BURST, item, true, false);
    AI_TrySayCombatText(victim, Random(COMBAT_TEXT_HIT_HEAD, COMBAT_TEXT_HIT_GROIN), true);
    victim.ToDead(ANIM2_DEAD_EXPLODE, null);

    return(true);
}

bool weapon_function_kill(Item& item, Critter& sadist, Critter& victim)   // ITEM_EVENT_ATTACK
{
    if(sadist.GetAccess() < ACCESS_MODER)
    {
        sadist.Say(SAY_NETMSG, "No.");
        return(true);
    }

    if(victim.IsDead())
    {
        sadist.Say(SAY_NETMSG, GenderString(victim, "He", "She", "It") + "'s already as dead as possible.");
        return(true);
    }

    LogCommandUsage(sadist, "ItemEventCheat: killed " + victim.Name + "<" + victim.Id + ">");

    Map@      map = victim.GetMap();
    const int mode_invulnerable = victim.Mode[MODE_INVULNERABLE];

    if(valid(map))
    {
        uint anim2 = ANIM2_BURST;
        if(IsGrenade(item))
        {
            anim2 = ANIM2_THROW;
            map.RunFlyEffect(item.GetProtoId(), sadist, victim, sadist.HexX, sadist.HexY, victim.HexX, victim.HexY);
            map.RunEffect(PID_EXPLODE_FIRE_BIG, victim.HexX, victim.HexY, 1);
            map.RunEffect(PID_EXPLODE_ROCKET, victim.HexX, victim.HexY, 1);
        }
        else if(item.Proto.ProtoId == PID_ROCKET_LAUNCHER)
        {
            map.RunFlyEffect(PID_FLYING_ROCKET, sadist, victim, sadist.HexX, sadist.HexY, victim.HexX, victim.HexY);
            map.RunEffect(PID_EXPLODE_FIRE_BIG, victim.HexX, victim.HexY, 1);
            map.RunEffect(PID_EXPLODE_ROCKET, victim.HexX, victim.HexY, 1);
        }

        if(anim2 > 0)
            sadist.Animate(0, anim2, item, true, false);

        uint location = Random(HIT_LOCATION_HEAD, HIT_LOCATION_GROIN);
        uint hp = Random(victim.Stat[ST_CURRENT_HP] + ABS(__DeadHitPoints),
                         (victim.Stat[ST_CURRENT_HP] + ABS(__DeadHitPoints)) * 2);
        uint effect = 0;

        if(location == HIT_LOCATION_HEAD || location == HIT_LOCATION_EYES)
        {
            if(Random(0, 1) == 0)
                SETFLAG(effect, HF_BLINDED);
        }
        else if(location == HIT_LOCATION_LEFT_ARM)
        {
            if(Random(0, 1) == 0)
                SETFLAG(effect, HF_CRIPPLED_LEFT_ARM);
        }
        else if(location == HIT_LOCATION_RIGHT_ARM)
        {
            if(Random(0, 1) == 0)
                SETFLAG(effect, HF_CRIPPLED_RIGHT_ARM);
        }
        else if(location == HIT_LOCATION_LEFT_LEG)
        {
            if(Random(0, 1) == 0)
                SETFLAG(effect, HF_CRIPPLED_LEFT_LEG);
        }
        else if(location == HIT_LOCATION_RIGHT_LEG)
        {
            if(Random(0, 1) == 0)
                SETFLAG(effect, HF_CRIPPLED_RIGHT_LEG);
        }

        if(Random(0, (location == HIT_LOCATION_TORSO ? 1 : 2)) == 0)
            SETFLAG(effect, HF_BYPASS_ARMOR);

        FakeCombat@ result = FakeCombat(victim);

        bool        dead = (mode_invulnerable <= 0);
        if(mode_invulnerable > 0 && GodOfTheRealm(sadist.Id) && sadist.GetAccess() == ACCESS_ADMIN)
            dead = true;

        if(location >= HIT_LOCATION_HEAD && location <= HIT_LOCATION_GROIN)
            AI_TrySayCombatText(victim, location + 9, true);

        if(dead)
            result.CritAimedHitDead(location, hp, effect, 0);
        else
            result.CritAimedHit(location, hp, effect, 0);

        result.Send();

//		if( GodOfTheRealm( sadist.Id ) && sadist.GetAccess() == ACCESS_ADMIN )
//			MapMessageEx( FLOAT_ENFORCED, FLOAT_MODE_ALL, victim, "annihilated", victim.HexX, victim.HexY, 255, COLOR_RGB(0xFF,0,0), true, -20, 20, -10, -20 );
    }

    if(GodOfTheRealm(sadist.Id) && sadist.GetAccess() == ACCESS_ADMIN)
    {
        victim.ParamBase[MODE_INVULNERABLE] = 0;
        victim.ToDead(GetRandomDeathAnimation(), null);
        victim.ParamBase[MODE_INVULNERABLE] = mode_invulnerable;
    }
    else
        victim.ToDead(GetRandomDeathAnimation(), null);

    return(true);
}

bool weapon_function_heal(Item& item, Critter& sadist, Critter& victim)   // ITEM_EVENT_ATTACK
{
    if(sadist.GetAccess() < ACCESS_MODER)
    {
        sadist.Say(SAY_NETMSG, "No.");
        return(true);
    }

    LogCommandUsage(sadist, "ItemEventCheat: healed " + victim.Name + "<" + victim.Id + ">");

    sadist.Animate(0, ANIM2_BURST, item, true, false);
    Heal(victim);

    return(true);
}

/*
   bool weapon_function_revive( Item& item, Critter& sadist, Critter& victim ) // ITEM_EVENT_ATTACK
   {
        if( !victim.IsDead() )
        {
                sadist.Say( SAY_NETMSG, victim.Name+"("+victim.Id+") is not dead." );
                return( true );
        }

        victim.ToLife();

        return( true );
   }
 */

void item_function_sound(Item& item, Critter& victim, bool entered, uint8 dir)
{
    string self = "item " + item.Id + ": ";
    uint16 hX = 0, hY = 0;
    Map@   map = item.GetMapPosition(hX, hY);

    #ifdef __DEBUG__
    if(valid(map))
        map.SetText(hX, hY, 0, self + victim.Name + "(" + victim.Id + ") entered:" + entered + " dir" + dir);
    else
        victim.Say(SAY_NETMSG, self + "entered:" + entered + " dir" + dir);
    #endif

    string lexem = (entered ? "$+" : "$-"); // TODO: confict with item description
    if(IsLexem(item, lexem))
    {
        int radius = 5;
        if(IsLexem(item, "$!"))
        {
            StrToInt(GetLexem(item, "$!"), radius);
        }
        map.PlaySound(GetLexem(item, lexem), hX, hY, radius);
    }
}

void _ForceEncounter(Map& map)
{
    Location@       loc = map.GetLocation();
    array<Critter@> crits;
    uint            n = GetGlobalMapCritters(loc.WorldX, loc.WorldY, 25, FIND_LIFE | FIND_ONLY_PLAYERS, crits);
    shuffle_ptrarray(crits, Critter@);
    for(uint i = 0; i < n; i++)
    {
        Critter@ cr = crits[i];
        if(!valid(cr.GetFollowLeader()) /* possible? */ || cr.GetFollowLeader().Id != cr.Id)
            continue;
        cr.TransitToMap(map.Id, 0, true);
        map.SetLoopTime(4, uint(-1));
        map.SetEvent(MAP_EVENT_LOOP_4, "_DoNothing");
    }
}

void SetTimeoutForAll(Map& map, int timeout, int time)
{
    array<Critter@> crits;
    uint            count = map.GetCritters(0, FIND_ALL, crits);

    for(uint c = 0; c < count; c++)
    {
        _SetTimeout(crits[c], timeout, time);
    }
}

void _LockMap(Map& map)
{
    SetTimeoutForAll(map, TO_TRANSFER, REAL_SECOND(2238) + REAL_MS(800));
}

void _DoNothing(Map& map)   // why am i needed, why?
{}

#ifdef __DEBUG__

# include "buffer_h.fos"
# include "buffer_lazy_h.fos"

void unsafe_deflect(Critter& cr, int target, int, int, string@ func, array<int32>@ data)
{
    cr.Say(SAY_NETMSG, "deflect start");

    if(!valid(func) || func.length() == 0)
    {
        cr.Say(SAY_NETMSG, "No function name");
        return;
    }

    Critter@ victim = GetCritter(target);
    if(!valid(victim))
    {
        cr.Say(SAY_NETMSG, "Invalid target<" + target + ">");
        return;
    }

    if(victim.IsNpc())
    {
        cr.Say(SAY_NETMSG, "Not on npcs");
        return;
    }

    if(!valid(data) || data.length() == 0)
    {
        cr.Say(SAY_NETMSG, "No data");
        return;
    }

    cr.Say(SAY_NETMSG, "deflect read");
    Buffer@ buffer = NewBuffer(data);
    cr.Say(SAY_NETMSG, "deflect send");
    RunLazyScript(victim, func, 0, 0, 0, null, buffer.AsInt32());
    cr.Say(SAY_NETMSG, "deflect end");
}
#endif

////

#ifdef SOME_SUNNY_DAY

# define RIDDLE_TYPE_NOT_SET     (0)
# define RIDDLE_TYPE_DIALOG      (1)

# define RIDDLE_STATE_WIP        (-1)
# define RIDDLE_STATE_STOPPED    (0)
# define RIDDLE_STATE_RUNNING    (1)

class CRiddle
{
    uint          id;
    string        name;
    string        author;

    int           type;
    int           state;

    array<string> question;
    array<string> answer;
    array<uint>   reward;               // PID, count_from, count_to
    int           reward_flags;

    CRiddle(uint id)
    {
        this.id = id;
        this.name = "noname";
        this.name = "nobody";

        this.type  = RIDDLE_TYPE_NOT_SET;
        this.state = RIDDLE_STATE_WIP;
    }

    # define _LoadSaveRiddle           \
        # (serializator, op)           \
        serializator op this.id;       \
        serializator op this.name;     \
        serializator op this.author;   \
        serializator op this.type;     \
        serializator op this.state;    \
        serializator op this.question; \
        serializator op this.answer;   \
        serializator op this.reward;   \
        serializator op this.reward_flags

    void Load(Serializator@ riddle)
    {
        _LoadSaveRiddle(riddle, >>);

        Log("Loaded riddle: " + this.name);
    }

    void Save(string prefix)
    {
        Serializator@ riddle;
        _LoadSaveRiddle(riddle, <<);
        riddle.Save(prefix + ("" + id));

        Log("Saved riddle: " + this.name);
    }
};
array<CRiddle@> Riddles;

void LoadRiddles()
{
    return;
    Serializator@ riddles;

    if(riddles.Load("Cheats:RiddleList"))
    {
        Log("Loading riddles...");
        array<uint> riddlesIDs;
        riddles >> riddlesIDs;


        for(uint r = 0, rlen = riddlesIDs.length(); r < rlen; r++)
        {
            Serializator@ sRiddle;
            if(sRiddle.Load("Cheats:Riddle:" + riddlesIDs[r]))
            {
                CRiddle@ riddle = CRiddle(riddlesIDs[r]);
                riddle.Load(sRiddle);
            }
        }
        Log("Loaded riddles.");
    }
}

void SaveRiddles()
{
    uint rlen = Riddles.length();
    if(rlen > 0)
    {
        Log("Saving riddles...");
        array<uint> riddleIDs;
        for(uint r = 0; r < rlen; r++)
        {
            Riddles[r].Save("Cheats:Riddle:");
            riddleIDs.insertLast(Riddles[r].id);
        }
        if(riddleIDs.length() > 0)
        {
            Serializator@ riddles;
            riddles << riddleIDs;
            riddles.Save("Cheats:RiddleList");
        }
        Log("Saved riddles.");
    }
}

string riddleInfo(uint idx, bool shortInfo)
{
    string result = "";
    if(idx > Riddles.length() - 1)
    {
        result = "IDX " + idx + " out of bounds!";
        return(result);
    }

    string state = "UnknownState";
    switch(Riddles[idx].state)
    {
    case RIDDLE_STATE_WIP:
        state = "WIP";
    case RIDDLE_STATE_STOPPED:
        state = "STOPPED";
    case RIDDLE_STATE_RUNNING:
        state = "RUNNING";
    }
    result += "[" + Riddles[idx].id + "] '" + Riddles[idx].name + "' " + Riddles[idx].author;

    if(!shortInfo)
    {}

    return(result);
}
void ExecRiddleCommand(array<string@>@ command, Critter@ player)
{
    if(command.length() < 3)
    {
        player.Say(SAY_NETMSG, "Missing parameters.");
        return;
    }
    else if(command[2] == "list")
    {
        if(Riddles.length() == 0)
        {
            player.Say(SAY_NETMSG, "There is no riddles.");
        }
        for(uint r = 0, rlen = Riddles.length(); r < rlen; r++)
        {
            player.Say(SAY_NETMSG, riddleInfo(r, true));
        }
    }
}
#endif
/*@}*/